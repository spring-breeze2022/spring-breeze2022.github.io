[{"title":"链表","url":"/2022/05/09/链表/","content":"\n### 例题一\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n**示例**\n\n```java\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n**限制：**\n\n```java\n0 <= 节点个数 <= 5000\n```\n\n#### 题解\n\n##### 解题思路一：迭代\n\n假设链表为 `1→2→3→∅`，我们想要把它改成`∅←1←2←3`。\n\n在遍历链表时，将当前节点的`next`指针改为指向前一个节点。由于该节点没有引用其前一个节点，因此需要事先准备一个空节点储存前一个节点，在更改引用之前还需要存储后一个节点。最后返回新的头节点。\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode p = null;      //用来储存倒叙\n        ListNode c = head;      \n        ListNode n = null;      \n        while(c != null){\n            n = c.next;\n            c.next = p;\n            p = c;\n            c = n;\n        }\n        return p;\n    }\n}\n```\n\n##### 解题思路二：递归\n\n- 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 `newHead` .\n- 此后，每次函数在返回的过程中，让当前结点的下一个结点的 `next`指针指向当前节点。\n- 同时让当前结点的 `next` 指针指向 `null` ，从而实现从链表尾部开始的局部反转\n- 当递归函数全部出栈后，链表反转完成。\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newHead;\n    }\n}\n```\n\n**递归较难理解，用笔演算一遍会好一点。**\n\n-----\n\n\n\n### 例题二\n\n请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。\n\n**示例1**\n\n![img](D:\\编程学习\\博客内容\\image\\e1.png)\n\n```java\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n```\n\n**示例2**\n\n![img](D:\\编程学习\\博客内容\\image\\e2.png)\n\n```java\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n```\n\n**示例3**\n\n![img](D:\\编程学习\\博客内容\\image\\e3.png)\n\n```java\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n```\n\n**示例 4：**\n\n```java\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n```\n\n **提示：**\n\n- `-10000 <= Node.val <= 10000`\n- `Node.random` 为空（null）或指向链表中的节点。\n- 节点数目不超过 1000 。\n\n#### 解题思路\n\n**回溯+哈希表**\n\n如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。\n\n具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。\n\n在实际代码中，我们需要特别判断给定节点为空节点的情况。\n\n```java\nclass Solution {\n    Map<Node, Node> cachedNode = new HashMap<Node, Node>();\n\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n        if (!cachedNode.containsKey(head)) {\n            Node headNew = new Node(head.val);\n            cachedNode.put(head, headNew);\n            headNew.next = copyRandomList(head.next);\n            headNew.random = copyRandomList(head.random);\n        }\n        return cachedNode.get(head);\n    }\n}\n```\n\n-----\n\n","tags":["算法","链表","哈希表"],"categories":["LeetCode学习","链表"]},{"title":"栈与队列","url":"/2022/05/04/栈与队列/","content":"\n### 例题一\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n**示例 1：**\n\n```java\n输入：\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[]]\n输出：\n[null,null,3,-1]\n```\n\n<!--more-->\n\n**示例 2：**\n\n```java\n输入：\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n输出：\n[null,-1,null,null,5,2]\n```\n\n**提示：**\n\n- `1 <= values <= 10000`\n- `最多会对 appendTail、deleteHead 进行 10000 次调用`\n\n#### 题解\n\n##### 解题思路\n\n- **栈无法实现队列功能:**\t栈为先进后出，队列为先进先出\n- **双栈可实现列表倒叙:**    用栈B元素实现对栈A的倒叙\n- **利用栈B删除队首元素**    B出栈相当于删除栈A的栈底元素，及队列首元素\n\n##### 函数设计\n\n- **加入队首`appendTail()`函数：**将数字val加入栈`A`即可。\n- **删除队尾`deleteHead()`:**分几种情况。\n  1. **当栈B不为空：**B中仍有已完成倒叙的元素，因此只需要返回B中的栈顶元素即可。\n  2. **否则，当A为空时：**当两个栈都为空时，无元素，返回-1。\n  3. **否则：**将栈A所有元素转移到栈B中，实现元素倒叙，并返回栈B元素的栈顶元素。\n\n##### 代码\n\n```java\nclass CQueue {\n    Stack<Integer> in,out;\n    public CQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void appendTail(int value) {\n        in.push(value);\n    }\n    \n    public int deleteHead() {\n        //当out栈不为空时，返回栈顶元素\n        if(!out.isEmpty()){\n            return out.pop();\n        }\n        //当in栈为空时，返回-1\n        if(in.isEmpty()){\n            return -1;\n        }\n        //当out栈为空时，将in栈中元素转到out栈中\n        while(!in.isEmpty()){\n            out.push(in.pop());\n        }\n        return out.pop();\n    }\n}\n```\n\n\n\n\n\n\n\n### 例题二\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n \n\n**示例:**\n\n```java\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.min();   --> 返回 -2.\n```\n\n**提示：**\n\n各函数的调用总次数不超过 20000 次\n\n\n\n#### 题解\n\n##### 解题思路\n\n对于栈来说，如果一个元素 `a` 在入栈时，栈里有其它的元素 `b, c, d`，那么无论这个栈在之后经历了什么操作，只要 `a` 在栈中，`b, c, d` 就一定在栈中，因为在 `a` 被弹出之前，b, c, d 不会被弹出。\n\n因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 `a, b, c, d`。\n\n那么，我们可以在每个元素 `a` 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 `a`，我们就可以直接返回存储的最小值 `m`。\n\n##### 算法\n\n按照上面的思路，我们只需要设计一个数据结构，使得每个元素`a`与其相应的最小值 `m` 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。\n\n- 当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；\n\n\n- 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；\n- 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。\n\n##### 代码\n\n```java\nclass MinStack {\n    /** initialize your data structure here. */\n\n    Stack<Integer> A,B;\n    public MinStack() {\n        A = new Stack<>();\n        B = new Stack<>();\n    }\n    \n    public void push(int x) {\n        A.push(x);\n        if(B.empty() || B.peek() >= x){\n            B.push(x);\n        }\n    }\n    \n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n    \n    public int top() {\n        return A.peek();\n    }\n    \n    public int min() {\n        return B.peek();\n    }\n}\n\n```\n\n","tags":["算法","栈与队列"],"categories":["LeetCode学习","栈"]},{"title":"Hello World","url":"/2022/05/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n   <!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]