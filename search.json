[{"title":"JDBC","url":"/2022/07/05/JDBC/","content":"<h1 id=\"JDBC的简单使用\"><a href=\"#JDBC的简单使用\" class=\"headerlink\" title=\"JDBC的简单使用\"></a>JDBC的简单使用</h1><h3 id=\"JDBC的概念\"><a href=\"#JDBC的概念\" class=\"headerlink\" title=\"JDBC的概念\"></a>JDBC的概念</h3><ul>\n<li>JDBC[Java Database ConnectivityJava]:语言连接数据库</li>\n<li>JDBC的本质:SUN公司制定的一套接口[java.sql.*]</li>\n<li>为什么要面向接口编程？<ul>\n<li>解耦合：降低程序的耦合度，提高程序的扩展力</li>\n</ul>\n</li>\n<li>为什么SUN公司要制定一套JDBC接口?<ul>\n<li>不同公司的数据库底层实现原理不同</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h3 id=\"JDBC的使用步骤\"><a href=\"#JDBC的使用步骤\" class=\"headerlink\" title=\"JDBC的使用步骤\"></a>JDBC的使用步骤</h3><ol>\n<li><p><strong>注册驱动</strong></p>\n<p><code>Class.forName(com.mysql.jdbc.Driver)</code></p>\n</li>\n<li><p><strong>获取连接</strong>（打开JVM进程和数据库进程之间的通道）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager</span><br><span class=\"line\">    .getConnection(</span><br><span class=\"line\">            <span class=\"string\">&quot;jdbc:mysql://127.0.0.1:3306/mydb?serverTimezone=UTC&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;root&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>获取数据库操作对象</strong>（专门执行SQL语句的对象）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//有动态传入的参数时，不建议使用</span></span><br><span class=\"line\"><span class=\"type\">Statement</span> <span class=\"variable\">stat</span> <span class=\"operator\">=</span> conn.createStatement();</span><br><span class=\"line\"><span class=\"comment\">//有预处理sql语句的功能</span></span><br><span class=\"line\">String sql=<span class=\"string\">&quot;select * from user where id=?&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">PreparedStatement</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>执行SQL语句</strong>（主要执行DQL和DML）</p>\n<p>执行:Statement中有execute（）的方法，返回值是boolean类型，true表示执行查询操作，false表示执行更新操作（增删改）</p>\n<p>executeUpdate（）方法是执行更新操作（增删改），返回值是受影响的行数</p>\n<p>executeQuery（）方法是执行查询操作，返回值是一个结果集ResultSet</p>\n<p>PreparedStatement和Statement方法一样（注意：PreparedStatement继承Statement）只不过在执行之前要为sql语句中的“?”赋值。</p>\n</li>\n<li><p><strong>处理查询结果集</strong>（只有当SQL语句为DQL语句时才需要）</p>\n</li>\n</ol>\n<ul>\n<li>JDBC的下标从1开始计数</li>\n<li>处理查询结果集采用下标方式不健壮,建议使用字段名</li>\n</ul>\n<p>   主要是对于结果集的处理，ResultSet 中有next()方法，它相当于一个游标，它的指向是下一条数据，返回值是boolean类型，能判断有没有一条数据，而ResultSet 中的getXxx是用来获取每一条数据中的具体内容比如：username、password等。</p>\n<ol start=\"6\">\n<li><strong>释放资源</strong>（使用完资源后一定要关闭资源）</li>\n</ol>\n<p><strong>&#x3D;&#x3D;注册驱动—&gt;获取连接—&gt;获取对象—&gt;执行语句—&gt;(处理结果)—&gt;释放资源&#x3D;&#x3D;</strong></p>\n<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><p>SQL注入是指恶意用户通过在表单中填写包含SQL关键字的数据来使数据库执行非常规代码的数据库攻击手段。</p>\n<p><strong>例如：</strong></p>\n<p><code>SELECT ….. FROM …… WHERE username=&#39;XX&#39; and password=&#39;YY&#39;</code></p>\n<ul>\n<li>初级注入：绕过验证 <code>&#39;or 1=1</code>；</li>\n<li>中级注入：借助异常获取信息 <code>&#39;or 1=(SELECT@@version)</code>；</li>\n<li>高级注入：获取服务器的所有信息 <code>&#39;or 1=(SELECT语句)</code></li>\n</ul>\n<p><strong>&#x3D;&#x3D;如何解决SQL注入&#x3D;&#x3D;</strong></p>\n<ol>\n<li>在JDBC中,使用Statement的子类PreparedStatement(被注入的SQL语句无法得到编译，从而避免了SQL注入的问题)</li>\n<li>在Mybatis中,使用占位符#{}而不是连接符${}(被注入的SQL语句无法得到编译，从而避免了SQL注入的问题)</li>\n<li>手动过滤危险参数<ul>\n<li>声明一个危险参数数组danger</li>\n<li>将前台传入的参数使用” “分隔</li>\n<li>如果产生的参数数组与danger有交集,那么终止该SQL语句执行并反馈前台[提示禁止输入非法字符]</li>\n</ul>\n</li>\n</ol>\n<p><strong>Statement和PreparedStatement的对比</strong></p>\n<table>\n<thead>\n<tr>\n<th>Statement</th>\n<th>PreparedStatement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存在SQL注入问题</td>\n<td>解决SQL注入问题</td>\n</tr>\n<tr>\n<td>编译1次执行1次</td>\n<td>编译1次执行n次</td>\n</tr>\n<tr>\n<td>没有编译阶段的类型安全检查</td>\n<td>具有编译阶段的类型安全检查</td>\n</tr>\n</tbody></table>\n<ul>\n<li>大部分情况使用PreparedStatement\\</li>\n<li>只有当业务要求支持SQL注入(需要sql语句拼接)时使用Statement</li>\n</ul>\n","categories":["Java学习","数据库"],"tags":["数据库","JDBC","知识点"]},{"title":"JDK1.8新特性","url":"/2022/08/16/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7/","content":"<h1 id=\"JDK1-8新特性\"><a href=\"#JDK1-8新特性\" class=\"headerlink\" title=\"JDK1.8新特性\"></a>JDK1.8新特性</h1><h3 id=\"一、Lambda表达式\"><a href=\"#一、Lambda表达式\" class=\"headerlink\" title=\"一、Lambda表达式\"></a>一、Lambda表达式</h3><p>Lambda 是一个匿名函数，我们可以把 Lambda  表达式理解为是一段可以传递的代码（将代码 像数据一样进行传递）。可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格，使 Java的语言表达能力得到了提升。</p>\n<p><strong>从匿名类到 Lambda 的转换</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//未使用Lambda表达式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ThreadRunnable</span> <span class=\"variable\">threadRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadRunnable</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">   \t \t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        \t\tSystem.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用Lambda表达式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>()-&gt;&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h4 id=\"具体语法\"><a href=\"#具体语法\" class=\"headerlink\" title=\"具体语法\"></a>具体语法</h4><ul>\n<li>无参，无返回值，Lambda体只需要一条语句</li>\n</ul>\n<p><code>Runnable re = ()-&gt; System.out.println(&quot;Hello World!&quot;);</code></p>\n<ul>\n<li>Lambda需要一个参数</li>\n</ul>\n<p><code>Consumer&lt;String&gt; fun = (args)-&gt; System.out.println(args);</code></p>\n<ul>\n<li>Lambda只需要一个参数时，参数的小括号可以省略</li>\n</ul>\n<p><code>Consumer&lt;String&gt; fun = args-&gt; Sytem.out.println(args);</code></p>\n<ul>\n<li>Lambda 需要两个参数，并且有返回值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">BinaryOperator&lt;Long&gt; bo = (x, y)-&gt; &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;输出内容&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当Lambda 体只有一条语句时，return 与大括号可以省略</li>\n</ul>\n<p><code>BinaryOperator&lt;Long&gt; bo = (x, y)-&gt; x + y;</code></p>\n<h3 id=\"二、函数式接口\"><a href=\"#二、函数式接口\" class=\"headerlink\" title=\"二、函数式接口\"></a>二、函数式接口</h3><ul>\n<li>只包含**&#x3D;&#x3D;一个抽象方法的接口&#x3D;&#x3D;**，称为函数式接口。</li>\n<li>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li>\n<li>可以在任意函数式接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包 含一条声明，说明这个接口是一个函数式接口。</li>\n</ul>\n<h3 id=\"三、接口\"><a href=\"#三、接口\" class=\"headerlink\" title=\"三、接口\"></a>三、接口</h3><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为 “默认方法”，默认方法使用 default 关键字修饰。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">MyFunc</span>&lt;T&gt; &#123;</span><br><span class=\"line\">\tT <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">int</span> a)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">default</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        retrun <span class=\"string\">&quot;Hello World!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>接口默认方法的”类优先”原则</strong></p>\n<p>若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时：</p>\n<ul>\n<li>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略；</li>\n<li>接口冲突。如果一个父接口提供一个默认方法，而另一个接 口也提供了一个具有相同名称和参数列表的方法（不管方法 是否是默认方法），那么必须覆盖该方法来解决冲突。</li>\n</ul>\n","categories":["Java学习","Java基础"],"tags":["知识点","JDK"]},{"title":"JVM","url":"/2022/08/18/JVM/","content":"<h1 id=\"JVM-Java-Virtual-Machine，Java虚拟机\"><a href=\"#JVM-Java-Virtual-Machine，Java虚拟机\" class=\"headerlink\" title=\"JVM(Java Virtual Machine，Java虚拟机)\"></a>JVM(Java Virtual Machine，Java虚拟机)</h1><h3 id=\"JVM内存划分\"><a href=\"#JVM内存划分\" class=\"headerlink\" title=\"JVM内存划分\"></a>JVM内存划分</h3><p><img src=\"/2022/08/18/JVM/1.png\" alt=\"image-20220818144055196\"></p>\n<span id=\"more\"></span>\n\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><ul>\n<li>是所有线程共享的区域 ；</li>\n<li>用于存储已经被虚拟机加载的类的信息，常量以及静态变量等 ；</li>\n<li>运行时的常量池也是方法区的一部分（比如字符串常量池和整数型常量池）。</li>\n</ul>\n<h4 id=\"堆区\"><a href=\"#堆区\" class=\"headerlink\" title=\"堆区\"></a>堆区</h4><ul>\n<li>是所有线程共享的区域；</li>\n<li>是程序员可以管理的区域，在虚拟机启动时创建；</li>\n<li>Java世界中基本所有的对象实例都是放在堆区的，是JVM所管理的内存区域中最大的一块，也是垃圾回收器（GC）主要管理的内存区域；</li>\n</ul>\n<h4 id=\"Java栈区（虚拟机栈）\"><a href=\"#Java栈区（虚拟机栈）\" class=\"headerlink\" title=\"Java栈区（虚拟机栈）\"></a>Java栈区（虚拟机栈）</h4><ul>\n<li>是线程私有的，生命周期与线程相同；</li>\n<li>一个线程在执行每一个方法的时候，都会创建一个对应的栈帧，栈帧中存储了方法的局部变量、方法出口等，当方法被调用时，与之对应的栈帧入栈，方法执行结束后，栈帧出栈；</li>\n</ul>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><ul>\n<li>是线程私有的；</li>\n<li>用于存储和执行native方法的。</li>\n</ul>\n<h4 id=\"PC寄存器\"><a href=\"#PC寄存器\" class=\"headerlink\" title=\"PC寄存器\"></a>PC寄存器</h4><ul>\n<li>程序计数器是线程私有的；</li>\n<li>如果线程正在执行的是Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址；</li>\n<li>如果线程执行的是native方法，则程序计数器值为空（Undefined）。</li>\n</ul>\n<h3 id=\"垃圾回收机制（GC）\"><a href=\"#垃圾回收机制（GC）\" class=\"headerlink\" title=\"垃圾回收机制（GC）\"></a>垃圾回收机制（GC）</h3><p>垃圾回收器在对堆进行回收前，需要先判断堆里面的对象有哪些是存活着的，哪些是已经不能再被使用的；那么怎么判断哪些对象是存活的，哪些是死的呢？就需要使用垃圾回收算法了。</p>\n<p><strong>详细对象引用见Java的引用</strong></p>\n<h4 id=\"内存是怎样分配的\"><a href=\"#内存是怎样分配的\" class=\"headerlink\" title=\"内存是怎样分配的\"></a>内存是怎样分配的</h4><p><img src=\"/2022/08/18/JVM/2.png\" alt=\"image-20220818150518944\"></p>\n<h5 id=\"对象分配\"><a href=\"#对象分配\" class=\"headerlink\" title=\"对象分配\"></a>对象分配</h5><p>优先在 Eden 区分配。当 Eden 区没有足够空间分配时, VM 发起一次 Minor GC，将 Eden 区和其中一块 Survivor 区内尚存活的对象放入另一块 Survivor 区域。如MinorGC 时 survivor 空间不够，对象提前进入老年代，老年代空间不够时进行 Full GC；</p>\n<p>大对象直接进入老年代，避免在 Eden 区和 Survivor 区之间产生大量的内存复制, 此外大对象容易导致还有不少空闲内存就提前触发 GC 以获取足够的连续空间.</p>\n<h5 id=\"对象晋级\"><a href=\"#对象晋级\" class=\"headerlink\" title=\"对象晋级\"></a>对象晋级</h5><p>年龄阈值：VM 为每个对象定义了一个对象年龄(Age)计数器, 经第一次 Minor GC 后仍然存活, 被移动到 Survivor 空间中, 并将年龄设为 1. 以后对象在 Survivor 区中每熬过一次 Minor GC 年龄就+1. 当增加到一定程度 (-XX:MaxTenuringThreshold, 默认 15), 将会晋升到老年代。</p>\n<p>提前晋升: 动态年龄判定；如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代, 而无须等到晋升年龄.</p>\n<h4 id=\"GC判断对象是否死亡的算法\"><a href=\"#GC判断对象是否死亡的算法\" class=\"headerlink\" title=\"GC判断对象是否死亡的算法\"></a>GC判断对象是否死亡的算法</h4><ol>\n<li><strong>引用计数法</strong><ul>\n<li>创建对象的时候给对象添加一个引用计数器；</li>\n<li>每有一个地方引用这个对象时，计数器就加1，当引用失效时，计数器就减1；</li>\n<li>任何时刻，当计数器值为0时，这个对象就是不会再被使用的，也就是可以被垃圾回收器回收的；</li>\n<li>但是主流的JVM没有使用这个算法来管理内存的，因为这个方法没法解决循环引用的问题；</li>\n</ul>\n</li>\n<li><strong>可达性分析算法</strong><ul>\n<li>通过一系列的称为“GC Roots”的对象作为起始点，从这些结点开始往下搜索，搜索所走过的路径就称为引用链，当一个对象到GC Roots没有引用链时，就证明这个对象是不可用的；</li>\n<li>在Java中，能作为GC Roots的对象包括以下几种：<ul>\n<li>虚拟机栈中引用的对象；</li>\n<li>方法区中类的静态属性引用的变量；</li>\n<li>方法区中常量引用的对象；</li>\n<li>本地方法栈中native方法引用的对象。</li>\n</ul>\n</li>\n<li>对象的生存和死亡的判定<ol>\n<li>即使一个对象在可达性分析算法中不可达，这个对象并不是“非死不可”，还处于缓刑阶段；</li>\n<li>要宣告一个对象的死亡，至少需要经过两次标记过程；</li>\n<li>如果一个对象在可达性分析算法中不可达，就会对这个对象进行一次标记并筛选，就是判断此对象是否有必要执行finalize（），如果没有重写finalize方法或者finalize方法已经被执行过了，那么就被视为“没有必要执行”； </li>\n<li>如果有必要执行，就会把这个对象放置到F-Queue的队列当中；</li>\n<li>JVM会创建一个线程来执行这个F-Queue里面的对象的finalize方法；</li>\n<li>在这个方法里面对象可以对自己进行最后一次拯救。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>回收方法区（永久代）</strong><ul>\n<li>永久代的垃圾回收主要回收两部分内容：废弃的常量和无用的类；</li>\n<li>回收废弃常量的操作和回收堆中的对象类似，会判断该常量是否还有引用指向它，要是没有，那么这个常量就会被清出常量池；</li>\n<li>怎么判定一个类是不是无用的类呢？ <ul>\n<li>该类的所有实例都已经被回收，也就是堆区不存在这个类的实例 ；</li>\n<li>加载该类的ClassLoader已经被回收；</li>\n<li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 ；</li>\n<li>无用的类并不是一定就会被回收，只是可以被回收。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"GC回收算法\"><a href=\"#GC回收算法\" class=\"headerlink\" title=\"GC回收算法\"></a>GC回收算法</h4><h5 id=\"一、新生代-标记清除算法\"><a href=\"#一、新生代-标记清除算法\" class=\"headerlink\" title=\"一、新生代-标记清除算法\"></a>一、新生代-标记清除算法</h5><p>该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象(可达性分析), 在标记完成后统一清理掉所有被标记的对象.</p>\n<p><img src=\"/2022/08/18/JVM/3.png\" alt=\"image-20220818155737989\"></p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>效率问题: 标记和清除过程的效率都不高;</li>\n<li>空间问题: 标记清除后会产生大量不连续的内存碎片, 空间碎片太多可能会导致在运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集.</li>\n</ul>\n<h5 id=\"二、新生代-复制算法\"><a href=\"#二、新生代-复制算法\" class=\"headerlink\" title=\"二、新生代-复制算法\"></a>二、新生代-复制算法</h5><p>该算法的核心是将可用内存按容量划分为大小相等的两块, 每次只用其中一块, 当这一块的内存用完, 就将还存活的对象复制到另外一块上面, 然后把已使用过的内存空间一次清理掉.</p>\n<p><img src=\"/2022/08/18/JVM/4.png\" alt=\"image-20220818160024102\"></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 </li>\n<li>垃圾回收后空间连续，只要移动堆顶指针，按顺序分配内存即可； </li>\n<li>特别适合 java 朝生夕死的对象特点；</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>对象存活率较高的时候就要执行较多的复制操作，效率变低；</li>\n<li>内存缩小为原来的一半 了，代价太高。</li>\n</ul>\n<h5 id=\"x3D-x3D-现在的虚拟机基本都采用复制算法来回收新生代，但是我们没必要把内存按照1-1的比例进行分配，我们可以把内存按照8-1-1的比例分为Edge空间和两块较小的Survivor-空间，每次只使用Edge空间和其中一个Survivor空间。-x3D-x3D\"><a href=\"#x3D-x3D-现在的虚拟机基本都采用复制算法来回收新生代，但是我们没必要把内存按照1-1的比例进行分配，我们可以把内存按照8-1-1的比例分为Edge空间和两块较小的Survivor-空间，每次只使用Edge空间和其中一个Survivor空间。-x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;现在的虚拟机基本都采用复制算法来回收新生代，但是我们没必要把内存按照1:1的比例进行分配，我们可以把内存按照8:1:1的比例分为Edge空间和两块较小的Survivor 空间，每次只使用Edge空间和其中一个Survivor空间。&#x3D;&#x3D;\"></a>&#x3D;&#x3D;现在的虚拟机基本都采用复制算法来回收新生代，但是我们没必要把内存按照1:1的比例进行分配，我们可以把内存按照8:1:1的比例分为Edge空间和两块较小的Survivor 空间，每次只使用Edge空间和其中一个Survivor空间。&#x3D;&#x3D;</h5><h5 id=\"x3D-x3D-回收时把Edge和Survivor中存活的对象复制到另外一块Survivor空间中，再清理掉Edge和用过的Survivor空间-x3D-x3D\"><a href=\"#x3D-x3D-回收时把Edge和Survivor中存活的对象复制到另外一块Survivor空间中，再清理掉Edge和用过的Survivor空间-x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;回收时把Edge和Survivor中存活的对象复制到另外一块Survivor空间中，再清理掉Edge和用过的Survivor空间&#x3D;&#x3D;\"></a>&#x3D;&#x3D;回收时把Edge和Survivor中存活的对象复制到另外一块Survivor空间中，再清理掉Edge和用过的Survivor空间&#x3D;&#x3D;</h5><h5 id=\"三、老年代-标记整理算法\"><a href=\"#三、老年代-标记整理算法\" class=\"headerlink\" title=\"三、老年代- 标记整理算法\"></a>三、老年代- 标记整理算法</h5><p>该算法分为“标记”和“清除”两个阶段: 首先标记出所有需要回收的对象 (可达性分析), 在标记完成后让所有存活的对象都向一端移动,然后清理掉端边界以外的内存；</p>\n<p><img src=\"/2022/08/18/JVM/5.png\" alt=\"image-20220818160840028\"></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>不会损失 50%的空间；</li>\n<li>垃圾回收后空间连续，只要移动堆顶指针，按顺序分配内存即可；</li>\n<li>比较适合有大量存活对象的垃圾回收；</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>标记&#x2F;整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要 整理所有存活对象的引用地址。</li>\n<li>从效率上来说，标记&#x2F;整理算法要低于复制算法。</li>\n</ul>\n<h3 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h3><ul>\n<li>Serial 单线程新生代复制算法的垃圾回收器；</li>\n<li>SerialOld 垃圾回收器，是一种单线程老年代标记整理算法；</li>\n<li>ParNew 垃圾回收器，是 Serial 的多线程实现，采用复制算法实现；</li>\n<li>Parallel Scavenge 垃圾回收器，是一种高效的多线程复制算法；</li>\n<li>ParallelOld 垃圾回收器，是 Parallel Scavenge 的一种老年代的多线程标记整理算法；</li>\n<li>CMS 垃圾回收器，是一种多线程标记清除算法；</li>\n<li>G1 垃圾回收器，是一种高吞吐量的垃圾回收器。</li>\n</ul>\n","categories":["Java学习","Java基础"],"tags":["知识点","JVM"]},{"title":"Java的引用类型","url":"/2022/08/17/Java%E7%9A%84%E5%BC%95%E7%94%A8/","content":"<h1 id=\"Java的引用类型\"><a href=\"#Java的引用类型\" class=\"headerlink\" title=\"Java的引用类型\"></a>Java的引用类型</h1><p>java提供了四种类型的引用：<strong>强引用、弱引用、软引用、虚引用</strong>。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>java中使用最多的引用是强引用，这是使用最普遍的引用。比如下面这段代码中的object和str都是强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;StrongReference&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个对象具有强引用，那就类似于<strong>必不可少的</strong>物品，不会被垃圾回收器回收。&#x3D;&#x3D;当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。&#x3D;&#x3D;</p>\n<p>如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p>\n<p>比如ArraryList类的clear方法中就是通过将引用赋值为null来实现清理工作的。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clear</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"comment\">// Let gc do its work</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">          elementData[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">      size = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用是用来描述一些<strong>有用但并不是必需</strong>的对象，在Java中用java.lang.ref.SoftReference类来表示。</p>\n<p>对于软引用关联着的对象，&#x3D;&#x3D;只有在内存不足的时候JVM才会回收该对象。&#x3D;&#x3D;因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。</p>\n<p><strong>创建：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;Obj&gt; sr = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;Obj&gt;(obj); </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用也是用来描述<code>非必需对象</code>的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。</p>\n<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。所以被&#x3D;&#x3D;软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。&#x3D;&#x3D;</p>\n<p><strong>创建：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">WeakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;String&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。</p>\n<p>弱引用还可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>虚引用和前面的软引用、弱引用不同，它并&#x3D;&#x3D;不影响对象的生命周期&#x3D;&#x3D;。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，&#x3D;&#x3D;在任何时候都可能被垃圾回收器回收&#x3D;&#x3D;。虚引用主要用来跟踪对象被垃圾回收的活动。</p>\n<p>&#x3D;&#x3D;虚引用必须和引用队列关联使用&#x3D;&#x3D;，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<p><strong>创建：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.ref.PhantomReference;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.ref.ReferenceQueue;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PhantomRef</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        ReferenceQueue&lt;String&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ReferenceQueue</span>&lt;String&gt;();</span><br><span class=\"line\">        PhantomReference&lt;String&gt; pr = <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>&lt;String&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hello&quot;</span>), queue);</span><br><span class=\"line\">        System.out.println(pr.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>被回收时间</th>\n<th>用途</th>\n<th>生存时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>强引用</td>\n<td>从来不会</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>jvm垃圾回收时</td>\n<td>对象缓存</td>\n<td>gc运行后</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>未知</td>\n<td>未知</td>\n<td>未知</td>\n</tr>\n</tbody></table>\n<p>在实际程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>\n","categories":["Java学习","Java基础"],"tags":["知识点","引用"]},{"title":"Maven","url":"/2022/08/16/Maven/","content":"<h1 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h1><p>Maven是服务于Java平台的&#x3D;&#x3D;（项目构建）&#x3D;&#x3D;和&#x3D;&#x3D;（依赖管理）&#x3D;&#x3D;的自动化构建工具</p>\n<p><strong>作用：</strong></p>\n<ul>\n<li>管理jar文件</li>\n<li>自动下载jar文件及其文档,源代码</li>\n<li>管理jar文件之间的依赖</li>\n<li>编译程序,把java编译为class</li>\n<li>测试代码是否正确。</li>\n<li>打包文件,形成jar文件或者war文件</li>\n<li>部署项目</li>\n</ul>\n<p><strong>Maven支持的构建：</strong></p>\n<ul>\n<li>clear清理:删除先前项目编译的文件为当前的编译代码做准备</li>\n<li>compile编译:批量将程序源代码编译为执行代码</li>\n<li>test测试:批量测试程序代码</li>\n<li>报告:生成测试结果的文件</li>\n<li>package打包:将项目中的所有资源打包成一个压缩文件<ul>\n<li>java应用的压缩文件的扩展名 .jar</li>\n<li>web应用的压缩文件的扩展名 .war</li>\n</ul>\n</li>\n<li>install安装:将打包步骤生成的文件[jar&#x2F;war]安装到本机仓库</li>\n<li>deploy部署:将程序安装好用于执行</li>\n</ul>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"Maven的核心功能\"><a href=\"#Maven的核心功能\" class=\"headerlink\" title=\"Maven的核心功能\"></a>Maven的核心功能</h3><p><strong>Maven的约定目录结构</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">---/src</span></span><br><span class=\"line\"><span class=\"comment\">------/main[必须有] \t#主程序java代码和配置文件</span></span><br><span class=\"line\"><span class=\"comment\">----------/java \t  #主程序包和包中的java文件</span></span><br><span class=\"line\"><span class=\"comment\">----------/resources  #主程序的配置文件 </span></span><br><span class=\"line\"><span class=\"comment\">------/test[可以无]\t#测试程序java代码和配置文件</span></span><br><span class=\"line\"><span class=\"comment\">----------/java \t  #测试程序包和包中的java文件</span></span><br><span class=\"line\"><span class=\"comment\">----------/resources  #测试程序的配置文件</span></span><br><span class=\"line\"><span class=\"comment\">---/pom.xml[必须有] \t#Maven的核心文件</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Maven仓库\"><a href=\"#Maven仓库\" class=\"headerlink\" title=\"Maven仓库\"></a>Maven仓库</h4><p>在 Maven 的术语中，仓库是一个位置（place）。</p>\n<p>Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。</p>\n<p>在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。</p>\n<p>Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。</p>\n<p>Maven 仓库有三种类型：</p>\n<ul>\n<li>本地（local）</li>\n<li>中央（central）</li>\n<li>远程（remote）</li>\n</ul>\n<h5 id=\"本地仓库\"><a href=\"#本地仓库\" class=\"headerlink\" title=\"本地仓库\"></a>本地仓库</h5><p>Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。</p>\n<p>运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。</p>\n<h5 id=\"中央仓库\"><a href=\"#中央仓库\" class=\"headerlink\" title=\"中央仓库\"></a>中央仓库</h5><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p>\n<p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。（Maven 仓库默认在国外， 国内使用难免很慢，可以更换为阿里云的仓库。）</p>\n<h5 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h5><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p>\n<p><strong>Maven 依赖搜索顺序</strong></p>\n<p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p>\n<ul>\n<li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>\n<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>\n<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>\n<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li>\n</ul>\n","categories":["Java学习","框架学习"],"tags":["知识点","Maven"]},{"title":"SpringBoot","url":"/2022/08/16/SpringBoot/","content":"<h1 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h1><p><strong>概念</strong></p>\n<p>SpringBoot是一种微服务框架，它提供了一种快速使用Spring的方式, 基于约定优于配置的思想，大大简化了spring应用的初始搭建以及各种配置。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li>Spring Boot可以建立独立的Spring应用程序；</li>\n<li>内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</li>\n<li>无需再像Spring那样搞一堆繁琐的xml文件的配置；</li>\n<li>可以自动配置Spring；</li>\n<li>提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能；</li>\n<li>提供的POM可以简化Maven的配置；</li>\n</ul>\n<h3 id=\"Spring的缺点\"><a href=\"#Spring的缺点\" class=\"headerlink\" title=\"Spring的缺点\"></a>Spring的缺点</h3><ul>\n<li>配置繁琐：需要配置各种不同的配置文件，配置过程繁琐。</li>\n<li>依赖繁琐：在pom.xml文件中需要提供各种不同的依赖，而且需要考虑不同依赖之间的版本问题。如果版本不兼容，将会无法启动。</li>\n</ul>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"Spring-Boot的功能\"><a href=\"#Spring-Boot的功能\" class=\"headerlink\" title=\"Spring Boot的功能\"></a>Spring Boot的功能</h3><ul>\n<li>自动配置<ul>\n<li>Spring Boot的自动配置是一个运行时（更准确地说，应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是SpringBoot自动完成的。</li>\n</ul>\n</li>\n<li>起步依赖<ul>\n<li>起步依赖本质上是一个Maven项目对象模型 (Project Object Model, POM)，定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</li>\n<li>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</li>\n</ul>\n</li>\n<li>辅助功能<ul>\n<li>提供了一些大型项目中常见的非功能特性，如嵌入式服务器、安全、指标、健康检测、外部配置等。</li>\n</ul>\n</li>\n<li>Spring Boot并不是针对Spring功能上的增强，而是提供了一种快速使用Spring的方式。</li>\n</ul>\n<h3 id=\"SpringBoot创建步骤\"><a href=\"#SpringBoot创建步骤\" class=\"headerlink\" title=\"SpringBoot创建步骤\"></a>SpringBoot创建步骤</h3><p><strong>一、创建一个maven工程；（jar）</strong></p>\n<p><strong>二、导入spring boot相关的依赖</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \t\t\t&lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt; \t&lt;version&gt;<span class=\"number\">1.5</span><span class=\"number\">.9</span>.RELEASE&lt;/version&gt; </span><br><span class=\"line\">&lt;/parent&gt; </span><br><span class=\"line\">&lt;dependencies&gt; </span><br><span class=\"line\">    &lt;dependency</span><br><span class=\"line\">    \t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \t\t\t&lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>三、编写一个主程序；启动springBoot应用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span> </span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldMainApplication</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// Spring应用启动起来</span></span><br><span class=\"line\">        SpringApplication.run(HelloWorldMainApplication.class,args); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>四、编写相关的Controller、Service</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloController</span> &#123; </span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span> <span class=\"meta\">@RequestMapping(&quot;/hello&quot;)</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World!&quot;</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>五、运行主程序测试</strong></p>\n<p><strong>六、简化部署</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!‐‐ 这个插件，可以将应用打包成一个可执行的jar包；‐‐&gt; </span><br><span class=\"line\">    &lt;build&gt; </span><br><span class=\"line\">    \t&lt;plugins&gt; </span><br><span class=\"line\">    \t\t&lt;plugin&gt;</span><br><span class=\"line\">    \t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class=\"line\">    \t\t\t&lt;artifactId&gt;spring‐boot‐maven‐plugin&lt;/artifactId&gt; </span><br><span class=\"line\">    \t\t&lt;/plugin&gt; </span><br><span class=\"line\">    \t&lt;/plugins&gt; </span><br><span class=\"line\">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"SpringBoot核心注解\"><a href=\"#SpringBoot核心注解\" class=\"headerlink\" title=\"SpringBoot核心注解\"></a>SpringBoot核心注解</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123;</span></span><br><span class=\"line\"><span class=\"meta\">      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>@SpringBootConfiguration：</strong></p>\n<p>组合了 @Configuration 注解，实现配置文件的功能。</p>\n</li>\n<li><p><strong>@EnableAutoConfiguration：</strong></p>\n<p>打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p>\n</li>\n<li><p><strong>@ComponentScan：</strong></p>\n<p>Spring组件扫描。</p>\n</li>\n</ul>\n<h3 id=\"运行-SpringBoot-有哪几种方式？\"><a href=\"#运行-SpringBoot-有哪几种方式？\" class=\"headerlink\" title=\"运行 SpringBoot 有哪几种方式？\"></a>运行 SpringBoot 有哪几种方式？</h3><ul>\n<li>打包用命令或者放到容器中运行</li>\n<li>用 Maven&#x2F; Gradle 插件运行</li>\n<li>直接执行 main 方法运行</li>\n</ul>\n","categories":["Java学习","框架学习"],"tags":["知识点","SpringBoot"]},{"title":"Servlet","url":"/2022/09/13/Servlet/","content":"<h1 id=\"Servlet\"><a href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"></a>Servlet</h1><h3 id=\"Servlet介绍\"><a href=\"#Servlet介绍\" class=\"headerlink\" title=\"Servlet介绍\"></a>Servlet介绍</h3><ul>\n<li>是Java编写的服务器端程序，具有独立于平台和协议的特性，主要功能是用于交互的浏览和生成数据，生成动态web内容； </li>\n<li>狭义的servlet是指Java语言实现的一个接口，广义的servlet是指任何实现了Servlet这个接口的类；</li>\n<li>servlet主要用于逻辑处理，处理完后将处理的结果交给jsp，由jsp向客户端做出响应。</li>\n</ul>\n<h3 id=\"Servlet生命周期\"><a href=\"#Servlet生命周期\" class=\"headerlink\" title=\"Servlet生命周期\"></a>Servlet生命周期</h3><ul>\n<li><strong>加载和初始化</strong></li>\n</ul>\n<p>服务器第一次访问 Servlet 时会创建 Servlet 的实例（一个 Servlet 类只有一个实例）。之后服务器调用 <code>init</code> 方法初始化 Servlet 对象，创建或加载初始化数据。</p>\n<ul>\n<li><strong>处理服务</strong></li>\n</ul>\n<p>每接收到一个 Http 请求时，服务器会产生一个新的线程并调用 <code>service</code> 方法处理请求。</p>\n<ul>\n<li><strong>销毁和垃圾回收</strong></li>\n</ul>\n<p>当 Servlet 被销毁时，服务器调用 <code>destroy</code> 方法释放 Servlet 对象所占的资源。最后由 JVM 对 Servlet 实例进行垃圾回收。</p>\n<h3 id=\"HttpServlet-类\"><a href=\"#HttpServlet-类\" class=\"headerlink\" title=\"HttpServlet 类\"></a>HttpServlet 类</h3><p>在 Java EE 中， HttpServlet 类已经实现了 Servlet 接口。实际开发中我们可以直接使用。</p>\n<p>HttpServlet 类中 service 方法会根据 HTTP 请求类型，选择调用 <code>doGet</code>、<code>doPost</code>、<code>doPut</code>，<code>doDelete</code> 等方法。</p>\n<ul>\n<li><strong>HttpServletRequest 类</strong>：用户请求</li>\n<li><strong>HttpServletResponse 类</strong>：服务器响应</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServletDemo2</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收 GET 请求</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span>  <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Get&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 接收 POST 请求</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span>  <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Post&quot;</span>);</span><br><span class=\"line\">        doGet(req,resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>HttpServletRequest&#x2F;HttpServletResponse</strong> 对象封装了 HTTP 请求头&#x2F;响应头中的所有信息，可以通过对象提供的方法获取。</p>\n<p>通过 request 对象提供的 getRequestDispatche(String path)方法返回一个 <strong>RequestDispatcher</strong> 对象，调用这个对象的 <strong>forward</strong> 方法可以实现请求转发。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">HttpSession</span> <span class=\"variable\">session</span> <span class=\"operator\">=</span> request.getSession();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (session.getAttribute(SESSION_KEY) != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 通过 ruquest 对象传递一个值</span></span><br><span class=\"line\">        request.setAttribute(<span class=\"string\">&quot;message&quot;</span>,<span class=\"string\">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 跳转登录页面（重定向）</span></span><br><span class=\"line\">        request.getRequestDispatcher(<span class=\"string\">&quot;login&quot;</span>).forward(request,response);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"请求转发和重定向的区别\"><a href=\"#请求转发和重定向的区别\" class=\"headerlink\" title=\"请求转发和重定向的区别\"></a>请求转发和重定向的区别</h4><ol>\n<li>地址方面：<ul>\n<li>请求转发：获得请求转发对象，告诉对象转发的地址；</li>\n<li>重定向：重新指定浏览器的地址；</li>\n</ul>\n</li>\n<li>地址栏显示信息方面：<ul>\n<li>请求转发方式：地址栏显示的是原来的地址，因为请求转发方式是服务器请求资源，直接访问访问目标地址的url，并读取响应内容，然后将内容发送给浏览器，浏览器并不知道目标地址 。</li>\n<li>重定向方式：地址栏显示的是新的url，因为重定向方式 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址 。</li>\n</ul>\n</li>\n<li>数据共享方面：<ul>\n<li>请求转发方式：转发页面和目标页面可以共享request里面的数据；</li>\n<li>重定向方式：不能共享数据。</li>\n</ul>\n</li>\n<li>请求转发方式效率高，重定向方式效率低。</li>\n</ol>\n","categories":["Java学习","Java后端学习"],"tags":["知识点","Redis"]},{"title":"Redis","url":"/2022/08/11/Redis/","content":"<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><ul>\n<li>Redis 默认有16个数据库；</li>\n<li>Select 数据库名   进入对应数据库；</li>\n<li>Keys * 列出所有 key 值；</li>\n<li>Dbsize  显示数据库数；</li>\n<li>Flushdb  清除该数据库的键子，flushall 清除所有</li>\n<li>Exist  key  判断 key 是否存在</li>\n</ul>\n<p>Redis 命令行操作 可以看：</p>\n<p>[Redis命令参考]: <a href=\"http://redisdoc.com/\">http://redisdoc.com/</a>\t“官网”<br>[Redis命令|菜鸟教程]:  <a href=\"https://www.runoob.com/redis/redis-tutorial.html\">https://www.runoob.com/redis/redis-tutorial.html</a>\t“菜鸟教程”</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"Redis数据类型\"><a href=\"#Redis数据类型\" class=\"headerlink\" title=\"Redis数据类型\"></a>Redis数据类型</h3><ul>\n<li>String（字符串）</li>\n<li>Hash（哈希，类似java里的map）</li>\n<li>List（列表）</li>\n<li>Set（集合）</li>\n<li>Zset（sorted set：有序集合）</li>\n</ul>\n<h4 id=\"String（字符串）\"><a href=\"#String（字符串）\" class=\"headerlink\" title=\"String（字符串）\"></a>String（字符串）</h4><p>string 是 redis 最基本的类型，可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>\n<p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p>\n<p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>\n<p><img src=\"/2022/08/11/Redis/1.png\" alt=\"image-20220813163104475\"></p>\n<h4 id=\"Hash（哈希）\"><a href=\"#Hash（哈希）\" class=\"headerlink\" title=\"Hash（哈希）\"></a>Hash（哈希）</h4><p>Redis hash 是一个键值(key&#x3D;&gt;value)对集合。</p>\n<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>\n<p><img src=\"/2022/08/11/Redis/2.png\" alt=\"image-20220813163140520\"></p>\n<h4 id=\"List（列表）\"><a href=\"#List（列表）\" class=\"headerlink\" title=\"List（列表）\"></a>List（列表）</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>\n<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>\n<p><img src=\"/2022/08/11/Redis/3.png\" alt=\"image-20220813163208664\"></p>\n<h4 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h4><p>Redis 的 Set 是 string 类型的无序集合。</p>\n<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>\n<p><strong>sadd 命令</strong></p>\n<p>添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。</p>\n<p><img src=\"/2022/08/11/Redis/4.png\" alt=\"image-20220813163432299\"></p>\n<p><strong>注意：</strong>以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p>\n<p>集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p>\n<h4 id=\"zset-sorted-set：有序集合\"><a href=\"#zset-sorted-set：有序集合\" class=\"headerlink\" title=\"zset(sorted set：有序集合)\"></a>zset(sorted set：有序集合)</h4><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>\n<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>\n<p>zset的成员是唯一的,但分数(score)却可以重复。</p>\n<p><strong>zadd 命令</strong></p>\n<p>添加元素到集合，元素在集合中存在则更新对应score</p>\n<p><img src=\"/2022/08/11/Redis/5.png\" alt=\"image-20220813163526810\"></p>\n<p>各类数据类型的应用场景</p>\n<p><img src=\"/2022/08/11/Redis/6.png\" alt=\"image-20220813163641294\"></p>\n<p><strong>注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。</strong></p>\n<h3 id=\"Redis的两种持久化RDB和AOF\"><a href=\"#Redis的两种持久化RDB和AOF\" class=\"headerlink\" title=\"Redis的两种持久化RDB和AOF\"></a>Redis的两种持久化RDB和AOF</h3><p>Redis持久化备份数据的方式有两种：RDB(Redis DataBase) 、AOF(Append Only File).</p>\n<h4 id=\"什么是RDB\"><a href=\"#什么是RDB\" class=\"headerlink\" title=\"什么是RDB\"></a>什么是RDB</h4><p>在指定时间间隔内，将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读到内存中，来达到恢复数据的。</p>\n<p>&#x3D;&#x3D;Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写进一个临时文件中，等到持久化过程结束了，再用这个临时文件替换上次持久化好的文件。&#x3D;&#x3D;</p>\n<p>在这个过程中，只有子进程来负责IO操作，主进程仍然处理客户端的请求，这就确保了极高的性能。</p>\n<h5 id=\"RDB优点与缺点\"><a href=\"#RDB优点与缺点\" class=\"headerlink\" title=\"RDB优点与缺点\"></a>RDB优点与缺点</h5><p><strong>优点：</strong></p>\n<p> （1）如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。</p>\n<p>（2）RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。</p>\n<p>（3）RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。</p>\n<p> <strong>缺点：</strong></p>\n<p> （1） RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。</p>\n<p>（2）每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作。</p>\n<h4 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h4><p>以日志的形式记录Redis每一个写操作,将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件不可以改写文件，redis启动之后会读取appendonly.aof文件来实现重新恢复数据，完成恢复数据的工作。默认不开启，需要将redis.conf中的appendonly  no改为yes启动Redis。</p>\n<p><strong>优点：</strong></p>\n<p>AOF有着多种持久化策略：</p>\n<ul>\n<li>appendfsync always:每修改同步，每一次发生数据变更都会持久化到磁盘上，性能较差，但数据完整性较好。</li>\n<li>appendfsync everysec: 每秒同步，每秒内记录操作，异步操作，如果一秒内宕机，有数据丢失。</li>\n<li>appendfsync no:不同步。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>对于相同的数据集来说，AOF文件要比RDB文件大。</li>\n<li>根据所使用的持久化策略来说，AOF的速度要慢与RDB。一般情况下，每秒同步策略效果较好。不使用同步策略的情况下，AOF与RDB速度一样快。</li>\n</ul>\n<h3 id=\"什么是缓存穿透、缓存击穿、缓存雪崩？\"><a href=\"#什么是缓存穿透、缓存击穿、缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存穿透、缓存击穿、缓存雪崩？\"></a>什么是缓存穿透、缓存击穿、缓存雪崩？</h3><h4 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h4><p>我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。</p>\n<h5 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><ul>\n<li><strong>将无效的key存进Redis中。</strong>如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value&#x3D;”null”，当下次再通过这个Key查询时就不需要再查询数据库。</li>\n</ul>\n<h4 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h4><p>其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</p>\n<h5 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><ul>\n<li>如果业务允许的话，对于热点的key可以<strong>设置永不过期的key</strong>。</li>\n<li><strong>设置阻塞队列：</strong>可以设置一个时间间隔，该时间段内的请求线程阻塞，然后启动一个线程访问数据库，再将结果给key赋值，存入Redis。</li>\n</ul>\n<h4 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h4><p>当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p>\n<ul>\n<li>在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。</li>\n<li>为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</li>\n</ul>\n<h3 id=\"Redis主从备份\"><a href=\"#Redis主从备份\" class=\"headerlink\" title=\"Redis主从备份\"></a>Redis主从备份</h3>","categories":["Java学习","中间件学习"],"tags":["知识点","Redis"]},{"title":"Hello World","url":"/2022/05/02/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n   <span id=\"more\"></span>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"io流","url":"/2022/08/11/io%E6%B5%81/","content":"<h1 id=\"io流\"><a href=\"#io流\" class=\"headerlink\" title=\"io流\"></a>io流</h1><p>在整个io包中，唯一表示与文件本身有关的类就是File类。使用File类可以进行创建或删除文件等常用操作。</p>\n<p><img src=\"/2022/08/11/io%E6%B5%81/1.png\" alt=\"image-20220811101142677\"></p>\n<p><img src=\"/2022/08/11/io%E6%B5%81/2.png\" alt=\"image-20220811101258373\"></p>\n<p><strong>file的操作存在延迟：在每次程序执行完成后，文件不会立即创建修改或删除，存在一些延迟，是因为所有的操作都需要经过JVM完成。</strong></p>\n<span id=\"more\"></span>\n\n\n\n<h4 id=\"io流的分类\"><a href=\"#io流的分类\" class=\"headerlink\" title=\"io流的分类\"></a>io流的分类</h4><p><img src=\"/2022/08/11/io%E6%B5%81/3.png\" alt=\"image-20220811101623083\"></p>\n<ul>\n<li><strong>文件相关：</strong><ul>\n<li>java.io.FileInputStream</li>\n<li>java.io.FileOutputStream</li>\n<li>java.io.FileReader</li>\n<li>java.io.FileWriter</li>\n</ul>\n</li>\n<li><strong>缓冲相关：</strong><ul>\n<li>java.io.BufferedInputStream</li>\n<li>java.io.BufferedOutputStream</li>\n<li>java.io.BufferedReader</li>\n<li>java.io.BufferedWriter</li>\n</ul>\n</li>\n<li><strong>对象相关：</strong><ul>\n<li>java.io.ObjectInputStream</li>\n<li>java.io.ObjectOutputStream</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"io流的方法\"><a href=\"#io流的方法\" class=\"headerlink\" title=\"io流的方法\"></a>io流的方法</h4><ul>\n<li><code>close()</code><ul>\n<li>流都具有close()方法[流都实现了java.io.Closeable接口]</li>\n<li>流使用完必须关闭[流都是可关闭的]</li>\n<li>关闭流的作用是关闭管道,防止占用过多资源</li>\n</ul>\n</li>\n<li><code>flush()</code>（输出流方法）<ul>\n<li>输出流都具有flush()方法[输出流都实现了java.io.Flushable接口]</li>\n<li>输出流使用完必须刷新[输出流都是可刷新的]</li>\n<li>刷新流的作用是清空管道[将管道中剩余未输出的数据强行输出完毕],防止数据丢失</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"对象的序列化\"><a href=\"#对象的序列化\" class=\"headerlink\" title=\"对象的序列化\"></a>对象的序列化</h4><p><code>ObjectInputStream</code>： 对象输入字节流；<code>ObjectOutputStream</code>： 对象输出字节流 </p>\n<p><code>readObject()</code> ：实现反序列化；<code>writeObject()</code>：实现序列化</p>\n<h5 id=\"序列化的作用\"><a href=\"#序列化的作用\" class=\"headerlink\" title=\"序列化的作用\"></a>序列化的作用</h5><ul>\n<li>序列化<ul>\n<li>在传递和保存对象时,保证对象的完整性和可传递性</li>\n<li>对象转换为有序字节流,以便在网络上传输或者保存在本地文件中</li>\n</ul>\n</li>\n<li>反序列化 <ul>\n<li>根据字节流中保存的对象状态及描述信息重建对象</li>\n</ul>\n</li>\n<li>核心作用<ul>\n<li>对象状态的保存和重建[字节流中所保存的对象状态及描述信息]</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><ol>\n<li>参与序列化和反序列化的对象,其类型必须实现**&#x3D;&#x3D;Serializable接口&#x3D;&#x3D;<strong>和</strong>提供序列版本号**</li>\n<li>如果没有实现Serializable接口或者没有提供序列版本号,那么会抛出NotSerializableException不可序列化异常</li>\n<li>序列化版本号使用于区分类[建议手动提供]</li>\n<li>关键字transient表示游离,不参与序列化操作</li>\n</ol>\n","categories":["Java学习","Java基础"],"tags":["知识点","io流"]},{"title":"动态规划","url":"/2022/05/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>写一个函数，输入<code>n</code>，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">F(<span class=\"number\">0</span>) = <span class=\"number\">0</span>,   F(<span class=\"number\">1</span>) = <span class=\"number\">1</span></span><br><span class=\"line\">F(N) = F(N - <span class=\"number\">1</span>) + F(N - <span class=\"number\">2</span>), 其中 N &gt; <span class=\"number\">1.</span></span><br></pre></td></tr></table></figure>\n\n\n<p>斐波那契数列由 <code>0</code> 和 <code>1</code> 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n<p>答案需要取模 <code>1e9+7(1000000007)</code>，如计算初始结果为：<code>1000000008</code>，请返回 <code>1</code>。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = <span class=\"number\">2</span></span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = <span class=\"number\">5</span></span><br><span class=\"line\">输出：<span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= n &lt;= 100</code></li>\n</ul>\n<span id=\"more\"></span>\n\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>斐波那契数列的定义是 <em>f</em>(<em>n</em>+1)&#x3D;<em>f</em>(<em>n</em>)+<em>f</em>(<em>n</em>−1) ，生成第 <em>n</em> 项的做法有以下几种：</p>\n<ol>\n<li><strong>递归法：</strong><ul>\n<li>把<em>f</em>(<em>n</em>+1)拆分为<em>f</em>(<em>n</em>)和<em>f</em>(<em>n</em>−1)两个式子计算，递归计算，直到<em>f</em>(0)和<em>f</em>(1)为终止条件。</li>\n<li><strong>缺点：</strong> 需要进行大量递归计算，时间复杂度为$O(2^n)$;</li>\n</ul>\n</li>\n<li><strong>动态规划：</strong><ul>\n<li><strong>原理：</strong> 以斐波那契数列性质 f*(<em>n</em>+1)&#x3D;<em>f</em>(<em>n</em>)+<em>f</em>(<em>n</em>−1) 为转移方程。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h5><p><strong>动态规划解析：</strong></p>\n<ul>\n<li><p><strong>状态定义：</strong> 设 <em>dp</em> 为一维数组，其中 <em>dp[i]</em> 的值代表 斐波那契数列第 <em>i</em> 个数字 。</p>\n</li>\n<li><p><strong>转移方程：</strong> <em>dp[i+1]&#x3D;dp[i]+dp[i−1]</em> ，即对应数列定义 <em>f(n+1)&#x3D;f(n)+f(n−1)</em> ；</p>\n</li>\n<li><p><strong>初始状态：</strong> <em>dp[0]&#x3D;0</em>,<em>dp[1]&#x3D;1</em> ，即初始化前两个数字；</p>\n</li>\n<li><p><strong>返回值：</strong> <em>dp[n]</em> ，即斐波那契数列的第 <em>n</em> 个数字。</p>\n<p><strong>需要对结果循环求余：</strong>防止因<em>n</em>的增大，*f(n)*会超过<code>Int32</code>甚至<code>Int64</code>的取值范围，导致结果错误。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, b = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> (a + b)%<span class=\"number\">1000000007</span>;</span><br><span class=\"line\">            a = b;</span><br><span class=\"line\">            b = sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释: 在第 <span class=\"number\">2</span> 天（股票价格 = <span class=\"number\">1</span>）的时候买入，在第 <span class=\"number\">5</span> 天（股票价格 = <span class=\"number\">6</span>）的时候卖出，最大利润 = <span class=\"number\">6</span>-<span class=\"number\">1</span> = <span class=\"number\">5</span> 。</span><br><span class=\"line\">     注意利润不能是 <span class=\"number\">7</span>-<span class=\"number\">1</span> = <span class=\"number\">6</span>, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出: <span class=\"number\">0</span></span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<p><code>0 &lt;= 数组长度 &lt;= 10^5</code></p>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>在题目中，我们只要用一个变量记录一个历史最低价格 <code>minprice</code>，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 <code>prices[i] - minprice</code>。</p>\n<p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p>\n<h5 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h5><ul>\n<li><strong>初始化：</strong>定义最低价为一个最大整型数<code>minprice = Integer.MAX_VALUE</code>,定义盈利<code>maxprofit = 0</code>;</li>\n<li><strong>遍历：</strong>求出当前时间段的最低价与最大盈利；</li>\n<li><strong>返回值：</strong>返回最大盈利值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> prices[])</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">minprice</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxprofit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class=\"line\">                minprice = prices[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class=\"line\">                maxprofit = prices[i] - minprice;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxprofit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题三\"><a href=\"#例题三\" class=\"headerlink\" title=\"例题三\"></a>例题三</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出: <span class=\"number\">12</span></span><br><span class=\"line\">解释: 路径 <span class=\"number\">1</span>→<span class=\"number\">3</span>→<span class=\"number\">5</span>→<span class=\"number\">2</span>→<span class=\"number\">1</span> 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt; grid.length &lt;= 200</code></li>\n<li><code>0 &lt; grid[0].length &lt;= 200</code></li>\n</ul>\n<h4 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>题目说明：从棋盘的左上角开始拿格子里的礼物，并每次 <strong>向右</strong> 或者 <strong>向下</strong> 移动一格、直到到达棋盘的右下角。<br>根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。</p>\n<p>设 $f(i,j)$ 为从棋盘左上角走至单元格 (i ,j)(i,j) 的礼物最大累计价值，易得到以下递推关系：$f(i,j)$ 等于 $f(i,j-1)$ 和 $f(i-1,j)$ 中的较大值加上当前单元格礼物价值 $grid(i,j)$ 。</p>\n<p>​        $f(i,j) &#x3D; \\max[f(i,j-1), f(i-1,j)] + grid(i,j)$</p>\n<p>因此，可用动态规划解决此问题，以上公式便为转移方程。</p>\n<img src=\"/2022/05/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.png\" alt=\"Picture1.png\" style=\"zoom: 67%;\">\n\n\n\n<h5 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h5><ul>\n<li><p><strong>状态定义：</strong> 设动态规划矩阵 dpdp ，dp(i,j)dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j)(i,j) 时能拿到礼物的最大累计价值。</p>\n</li>\n<li><p><strong>转移方程：</strong></p>\n<ul>\n<li><p>当 $i &#x3D; 0$ 且 $j &#x3D; 0$ 时，为起始元素；</p>\n</li>\n<li><p>当 $i &#x3D; 0$ 且 $j \\ne 0$ 时，为矩阵第一行元素，只可从左边到达；</p>\n</li>\n<li><p>当 $i \\ne 0$ 且 $j &#x3D; 0$ 时，为矩阵第一列元素，只可从上边到达；</p>\n</li>\n<li><p>当 $i \\ne 0$ 且 $j \\ne 0$ 时，可从左边或上边到达；<br>$$<br>dp(i,j)&#x3D; \\begin{cases} grid(i,j) &amp; {,i&#x3D;0, j&#x3D;0}\\ grid(i,j) + dp(i,j-1) &amp; {,i&#x3D;0, j \\ne 0}\\ grid(i,j) + dp(i-1,j) &amp; {,i \\ne 0, j&#x3D;0}\\ grid(i,j) + \\max[dp(i-1,j),dp(i,j-1)]&amp; ,{i \\ne 0, j \\ne 0} \\end{cases}<br>$$</p>\n</li>\n</ul>\n</li>\n<li><p><strong>初始状态：</strong> $dp[0][0] &#x3D; grid[0][0]$，即到达单元格 $(0,0)$ 时能拿到礼物的最大累计价值为 $grid[0][0]$ ；</p>\n</li>\n<li><p><strong>返回值：</strong> $dp[m-1][n-1]$，$m, n$ 分别为矩阵的行高和列宽，即返回 $dp$ 矩阵右下角元素。</p>\n</li>\n</ul>\n<p><strong>可直接在原矩阵中进行修改，省去$dp$矩阵使用的额外空间，空间复杂度从$O(MN)$降低位$O(1)$</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxValue</span><span class=\"params\">(<span class=\"type\">int</span>[][] grid)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> grid.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i&lt; m;i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;j &lt; n;j++)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    grid[i][j] += grid[i][j - <span class=\"number\">1</span>] ;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    grid[i][j] += grid[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    grid[i][j] += Math.max(grid[i][j - <span class=\"number\">1</span>], grid[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> grid[m-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：jyd、LeetCode-Solution</p>\n</blockquote>\n","categories":["LeetCode学习","动态规划"],"tags":["算法","数组","动态规划"]},{"title":"动态规划二","url":"/2022/05/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%8C/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"number\">12258</span></span><br><span class=\"line\">输出: <span class=\"number\">5</span></span><br><span class=\"line\">解释: <span class=\"number\">12258</span>有<span class=\"number\">5</span>种不同的翻译，分别是<span class=\"string\">&quot;bccfi&quot;</span>, <span class=\"string\">&quot;bwfi&quot;</span>, <span class=\"string\">&quot;bczi&quot;</span>, <span class=\"string\">&quot;mcfi&quot;</span>和<span class=\"string\">&quot;mzi&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<p><code>0 &lt;= num &lt; 231</code></p>\n<span id=\"more\"></span>\n\n\n\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>本题使用动态规划，及通过前一步状态推导下一步状态，由题意可推导转移方程，流程如下图。</p>\n<img src=\"/2022/05/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%8C/1.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\">\n\n\n\n<h5 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h5><ul>\n<li><p><strong>状态定义：</strong>设动态规划列表 $dp$ ，$dp[i]$ 代表以 $x_i$ 为结尾的数字的翻译方案数量。</p>\n</li>\n<li><p><strong>转移方程：</strong>若 $x_i$和 $x_{i-1}$组成的两位数字可以被翻译，则$dp[i] &#x3D; dp[i - 1] + dp[i - 2]$；否则 $dp[i] &#x3D; dp[i - 1]$。</p>\n<p>可被翻译的两位数区间：当 $x_{i-1} &#x3D; 0$时，组成的两位数是无法被翻译的（例如 $00, 01, 02, \\cdots$），因此区间为 $[10, 25]$。<br>$dp[i] &#x3D; \\begin{cases} dp[i - 1] + dp[i - 2] &amp; {, 10 x_{i-1} + x_i \\in [10,25]} \\ dp[i - 1] &amp; {, 10 x_{i-1} + x_i \\in [0, 10) \\cup (25, 99]} \\end{cases}$</p>\n</li>\n<li><p><strong>返回值：</strong>$dp[n]$，及此数字的翻译方案数量。</p>\n</li>\n<li><p><strong>初始状态：</strong>$dp[0]&#x3D;dp[1]&#x3D;1$，即 “无数字” 和 “第 1 位数字” 的翻译方法数量均为 1 。</p>\n</li>\n<li><p><strong>空间优化：</strong>$dp[i],dp[i - 1]$，所以可使用两个变量 p,q 分别记录 $dp[i], dp[i - 1]$，两变量交替前进即可。此方法可省去 $dp$ 列表使用的 $O(N)$ 的额外空间。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">translateNum</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> String.valueOf(num);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>,q = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;i &lt;= s.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">nums</span> <span class=\"operator\">=</span> s.substring(i-<span class=\"number\">2</span>, i);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> nums.compareTo(<span class=\"string\">&quot;10&quot;</span>) &gt;= <span class=\"number\">0</span> &amp;&amp; nums.compareTo(<span class=\"string\">&quot;25&quot;</span>) &lt;=<span class=\"number\">0</span> ? p + q : q;</span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">            q = c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;abcabcbb&quot;</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">&quot;abc&quot;</span>，所以其长度为 <span class=\"number\">3</span>。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;bbbbb&quot;</span></span><br><span class=\"line\">输出: <span class=\"number\">1</span></span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">&quot;b&quot;</span>，所以其长度为 <span class=\"number\">1</span>。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;pwwkew&quot;</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span></span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">&quot;wke&quot;</span>，所以其长度为 <span class=\"number\">3</span>。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，<span class=\"string\">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p><code>s.length &lt;= 40000</code></p>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路一：动态规划-哈希表\"><a href=\"#解题思路一：动态规划-哈希表\" class=\"headerlink\" title=\"解题思路一：动态规划 + 哈希表\"></a>解题思路一：动态规划 + 哈希表</h5><p>使用动态规划记录每增加一个字符的“最长不重复子字符串” 的长度是多少。</p>\n<p><strong>动态规划解析：</strong></p>\n<ul>\n<li><strong>状态定义：</strong> 设动态规划列表 $dp$ ，$dp[j]$代表以字符 $s[j]$ 为结尾的 “最长不重复子字符串” 的长度。</li>\n<li><strong>转移方程：</strong> 固定右边界 $j$ ，设字符 $s[j]$ 左边距离最近的相同字符为 $s[i]$ ，即 $s[i] &#x3D; s[j]$ 。<ul>\n<li>当 $i &lt; 0$，即 $s[j]$ 左边无相同字符，则 $dp[j] &#x3D; dp[j-1] + 1$；</li>\n<li>当 $dp[j - 1] &lt; j - i$，说明字符 $s[i]$ 在子字符串 $dp[j-1]$ <strong>区间之外</strong> ，则 $dp[j] &#x3D; dp[j - 1] + 1$ ；</li>\n<li>当 $dp[j - 1] \\geq j - i$，说明字符 $s[i]$ 在子字符串 $dp[j-1]$ <strong>区间之中</strong> ，则 $dp[j]$的左边界由 $s[i]$ 决定，即 $dp[j] &#x3D; j - i$；</li>\n<li>当 $i &lt; 0$ 时，由于 $dp[j - 1] \\leq j$ 恒成立，因而 $dp[j - 1] &lt; j - i$ 恒成立，因此分支 <code>1.</code> 和 <code>2.</code> 可被合并。</li>\n</ul>\n</li>\n</ul>\n<p>$$<br>dp[j] &#x3D; \\begin{cases} dp[j - 1] + 1 &amp; , dp[j-1] &lt; j - i \\ j - i &amp; , dp[j-1] \\geq j - i \\end{cases}<br>$$</p>\n<ul>\n<li><strong>返回值：</strong> $\\max(dp)$，即全局的 “最长不重复子字符串” 的长度。</li>\n</ul>\n<img src=\"/2022/05/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%8C/2.png\" alt=\"Picture1.png\" style=\"zoom: 67%;\">\n\n<p><strong>优化空间复杂度</strong></p>\n<ul>\n<li>由于返回值是取 $dp$ 列表最大值，因此可借助变量 $tmp$ 存储 $dp[j]$ ，变量 $res$ 每轮更新最大值即可。</li>\n<li>此优化可节省 $dp$ 列表使用的 $O(N)$ 大小的额外空间。</li>\n</ul>\n<p><strong>哈希表</strong></p>\n<ul>\n<li>哈希表统计： 遍历字符串 $s$ 时，使用哈希表（记为 $dic$ ）统计 各字符最后一次出现的索引位置 。</li>\n<li>左边界 $i$ 获取方式： 遍历到 $s[j]$ 时，可通过访问哈希表 $dic[s[j]]$ 获取最近的相同字符的索引 $i$ 。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; dic = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> dic.getOrDefault(s.charAt(j), -<span class=\"number\">1</span>); <span class=\"comment\">// 获取索引 i</span></span><br><span class=\"line\">            dic.put(s.charAt(j), j); <span class=\"comment\">// 更新哈希表</span></span><br><span class=\"line\">            tmp = tmp &lt; j - i ? tmp + <span class=\"number\">1</span> : j - i; <span class=\"comment\">// dp[j - 1] -&gt; dp[j]</span></span><br><span class=\"line\">            res = Math.max(res, tmp); <span class=\"comment\">// max(dp[j - 1], dp[j])</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"解题思路二：滑动窗口\"><a href=\"#解题思路二：滑动窗口\" class=\"headerlink\" title=\"解题思路二：滑动窗口\"></a>解题思路二：滑动窗口</h5><p>找出<strong>从每一个字符开始的，不包含重复字符的最长子串</strong>，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p>\n<ul>\n<li><p>使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着「枚举子串的起始位置」，而右指针即为最长子串结束位置的 $r_k$；</p>\n</li>\n<li><p>在每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。记录下这个子串的长度；</p>\n</li>\n<li><p>在枚举结束后，找到的最长的子串的长度即为答案。</p>\n</li>\n</ul>\n<p><strong>判断重复字符</strong></p>\n<p>在上面的流程中，还需要使用一种数据结构来判断 <strong>是否有重复的字符</strong>，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 哈希集合，记录每个字符是否出现过</span></span><br><span class=\"line\">        Set&lt;Character&gt; occ = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Character&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"comment\">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rk</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 左指针向右移动一格，移除一个字符</span></span><br><span class=\"line\">                occ.remove(s.charAt(i - <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rk + <span class=\"number\">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class=\"number\">1</span>))) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 不断地移动右指针</span></span><br><span class=\"line\">                occ.add(s.charAt(rk + <span class=\"number\">1</span>));</span><br><span class=\"line\">                ++rk;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class=\"line\">            ans = Math.max(ans, rk - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：jyd、LeetCode-Solution</p>\n</blockquote>\n","categories":["LeetCode学习","动态规划"],"tags":["算法","动态规划","字符串"]},{"title":"双指针","url":"/2022/05/22/%E5%8F%8C%E6%8C%87%E9%92%88/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>输入两个链表，找出它们的第一个公共节点。</p>\n<p>如下面的两个链表：</p>\n<p>​\t\t\t\t\t\t\t\t\t\t<img src=\"/2022/05/22/%E5%8F%8C%E6%8C%87%E9%92%88/1.png\" alt=\"img\"></p>\n<p>在节点 c1 开始相交。</p>\n<p><strong>示例 1：</strong></p>\n<p>​\t\t\t\t\t\t\t\t\t\t <img src=\"/2022/05/22/%E5%8F%8C%E6%8C%87%E9%92%88/2.png\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = <span class=\"number\">8</span>, listA = [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], listB = [<span class=\"number\">5</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], skipA = <span class=\"number\">2</span>, skipB = <span class=\"number\">3</span></span><br><span class=\"line\">输出：Reference of the node <span class=\"type\">with</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">8</span></span><br><span class=\"line\">输入解释：相交节点的值为 <span class=\"number\">8</span> （注意，如果两个列表相交则不能为 <span class=\"number\">0</span>）。从各自的表头开始算起，链表 A 为 [<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]，链表 B 为 [<span class=\"number\">5</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]。在 A 中，相交节点前有 <span class=\"number\">2</span> 个节点；在 B 中，相交节点前有 <span class=\"number\">3</span> 个节点。</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>示例 2：</strong></p>\n<img src=\"/2022/05/22/%E5%8F%8C%E6%8C%87%E9%92%88/3.png\" alt=\"img\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = <span class=\"number\">2</span>, listA = [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>], listB = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>], skipA = <span class=\"number\">3</span>, skipB = <span class=\"number\">1</span></span><br><span class=\"line\">输出：Reference of the node <span class=\"type\">with</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\">输入解释：相交节点的值为 <span class=\"number\">2</span> （注意，如果两个列表相交则不能为 <span class=\"number\">0</span>）。从各自的表头开始算起，链表 A 为 [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>]，链表 B 为 [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>]。在 A 中，相交节点前有 <span class=\"number\">3</span> 个节点；在 B 中，相交节点前有 <span class=\"number\">1</span> 个节点。</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"/2022/05/22/%E5%8F%8C%E6%8C%87%E9%92%88/4.png\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = <span class=\"number\">0</span>, listA = [<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>], listB = [<span class=\"number\">1</span>,<span class=\"number\">5</span>], skipA = <span class=\"number\">3</span>, skipB = <span class=\"number\">2</span></span><br><span class=\"line\">输出：<span class=\"literal\">null</span></span><br><span class=\"line\">输入解释：从各自的表头开始算起，链表 A 为 [<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>]，链表 B 为 [<span class=\"number\">1</span>,<span class=\"number\">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class=\"number\">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class=\"line\">解释：这两个链表不相交，因此返回 <span class=\"literal\">null</span>。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果两个链表没有交点，返回 <code>null</code>.</li>\n<li>在返回结果后，两个链表仍须保持原有的结构。</li>\n<li>可假定整个链表结构中没有循环。</li>\n<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>\n</ul>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>设「第一个公共节点」为 <code>node</code> ，「链表 <code>headA</code>」的节点数量为 $a$ ，「链表 <code>headB</code>」的节点数量为 $b$ ，「两链表的公共尾部」的节点数量为 $c$ ，则有：</p>\n<p>头节点 <code>headA</code> 到 <code>node</code> 前，共有 $a - c$ 个节点；<br>头节点 <code>headB</code> 到 <code>node</code> 前，共有 $b - c$ 个节点；</p>\n<img src=\"/2022/05/22/%E5%8F%8C%E6%8C%87%E9%92%88/5.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\">\n\n<p>考虑构建两个节点指针 <code>A</code> , <code>B</code> 分别指向两链表头节点 <code>headA</code> , <code>headB</code></p>\n<p>当头节点<code>nodeA</code>与头节点<code>nodeB</code>分别循环一遍自己的节点，并走一遍对方的公共节点前的节点，指针步长相同。即：</p>\n<ul>\n<li>指针 <code>A</code> 先遍历完链表 <code>headA</code> ，再开始遍历链表 <code>headB</code> ，当走到 <code>node</code> 时，共走步数为：</li>\n</ul>\n<p>$$<br>a + (b - c)<br>$$</p>\n<ul>\n<li>指针 <code>B</code> 先遍历完链表 <code>headB</code> ，再开始遍历链表 <code>headA</code> ，当走到 <code>node</code> 时，共走步数为：</li>\n</ul>\n<p>$$<br>b+(a−c)<br>$$</p>\n<p>如下式所示，此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况：<br>$$<br>a + (b - c) &#x3D; b + (a - c)<br>$$</p>\n<ol>\n<li>若两链表 <strong>有</strong> 公共尾部 (即 c &gt; 0<em>c</em>&gt;0 ) ：指针 <code>A</code> , <code>B</code> 同时指向「第一个公共节点」<code>node</code> 。</li>\n<li>若两链表 <strong>无</strong> 公共尾部 (即 c &#x3D; 0<em>c</em>&#x3D;0 ) ：指针 <code>A</code> , <code>B</code> 同时指向 $null$ 。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">A</span> <span class=\"operator\">=</span> headA, B = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (A != B) &#123;</span><br><span class=\"line\">            A = A != <span class=\"literal\">null</span> ? A.next : headB;</span><br><span class=\"line\">            B = B != <span class=\"literal\">null</span> ? B.next : headA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”.student a am I”。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;the sky is blue&quot;</span></span><br><span class=\"line\">输出: <span class=\"string\">&quot;blue is sky the&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;  hello world!  &quot;</span></span><br><span class=\"line\">输出: <span class=\"string\">&quot;world! hello&quot;</span></span><br><span class=\"line\">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">&quot;a good   example&quot;</span></span><br><span class=\"line\">输出: <span class=\"string\">&quot;example good a&quot;</span></span><br><span class=\"line\">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明：</strong></p>\n<ul>\n<li>无空格字符构成一个单词。</li>\n<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>\n<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>\n</ul>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><h5 id=\"算法解析：\"><a href=\"#算法解析：\" class=\"headerlink\" title=\"算法解析：\"></a>算法解析：</h5><ul>\n<li>倒序遍历字符串 $s$，记录单词左右索引边界 $i$ , $j$；</li>\n<li>每确定一个单词的边界，则将其添加至单词列表 $res$；</li>\n<li>最终，将单词列表拼接为字符串，并返回即可。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">reverseWords</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        s = s.trim(); <span class=\"comment\">// 删除首尾空格</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> s.length() - <span class=\"number\">1</span>, i = j;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(i) != <span class=\"string\">&#x27; &#x27;</span>) i--; <span class=\"comment\">// 搜索首个空格</span></span><br><span class=\"line\">            res.append(s.substring(i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>) + <span class=\"string\">&quot; &quot;</span>); <span class=\"comment\">// 添加单词</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(i) == <span class=\"string\">&#x27; &#x27;</span>) i--; <span class=\"comment\">// 跳过单词间空格</span></span><br><span class=\"line\">            j = i; <span class=\"comment\">// j 指向下个单词的尾字符</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toString().trim(); <span class=\"comment\">// 转化为字符串并返回</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：jyd</p>\n</blockquote>\n","categories":["LeetCode学习","双指针"],"tags":["算法","数组","双指针","链表"]},{"title":"多线程","url":"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h3 id=\"什么是线程？\"><a href=\"#什么是线程？\" class=\"headerlink\" title=\"什么是线程？\"></a>什么是线程？</h3><h4 id=\"程序、进程和线程之间的区别？\"><a href=\"#程序、进程和线程之间的区别？\" class=\"headerlink\" title=\"程序、进程和线程之间的区别？\"></a>程序、进程和线程之间的区别？</h4><ul>\n<li>程序是静态的，进程是被执行的程序，进程就是动态的。</li>\n<li>进程是能分配资源和独立运行的，线程不能独立运行。</li>\n<li>一个进程能有多个线程，但至少有一个线程。</li>\n<li>进程无法共享内存，但线程可以：因为每个线程都分配独立的栈空间，但堆空间共享。</li>\n</ul>\n<h4 id=\"为什么说Java本身支持多线程？\"><a href=\"#为什么说Java本身支持多线程？\" class=\"headerlink\" title=\"为什么说Java本身支持多线程？\"></a>为什么说Java本身支持多线程？</h4><p>​\t\t因为java的线程由jvm管理，它如何映射到操作系统的线程由jvm实现决定。jvm采用一种轻量级线程，对内核线程做一层封装提供给用户线程调用，实现用户线程与操作系统线程形成一比一映射关系。</p>\n<h4 id=\"进程的三个特征\"><a href=\"#进程的三个特征\" class=\"headerlink\" title=\"进程的三个特征\"></a>进程的三个特征</h4><ol>\n<li><strong>独立性：</strong>进程是系统独立存在的实体，它可以拥有自己独立的资源。</li>\n<li><strong>动态性：</strong>进程是正在系统活动中的指令集合。</li>\n<li><strong>并发性：</strong>多个进程可以在单处理器上执行。</li>\n</ol>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"Java中创建线程的四种方法以及它们的区别\"><a href=\"#Java中创建线程的四种方法以及它们的区别\" class=\"headerlink\" title=\"Java中创建线程的四种方法以及它们的区别\"></a>Java中创建线程的四种方法以及它们的区别</h3><ol>\n<li><p><strong>继承<code>Thread</code>类重写<code>run()</code>方法：</strong>继承<code>Thread</code>类比较冗余，而且不支持多线程对同一全局变量进行访问。</p>\n</li>\n<li><p><strong>实现<code>Runnable</code>接口，重写<code>run()</code>方法：</strong>通过<code>Thread</code>含参构造函数创建对象。实现类也可以继承或实现其他类&#x2F;接口，提高代码的灵活性，也方便多线程对同一全局变量进行访问。</p>\n</li>\n<li><p><strong>实现<code>Callable</code>接口，重写<code>call()</code>方法：</strong>需要使用<code>FutureTask</code>类包装，因为<code>FutureTask</code>类实现了<code>Runnable</code>接口。实现<code>Callable</code>方法可以抛出异常，而且可以有返回值以及带参数。继承<code>Thread</code>和实现<code>Runnable</code>接口不能。</p>\n</li>\n<li><p><strong>当然也可以通过创建线程池来创建线程</strong></p>\n<ul>\n<li><p>在经常创建和销毁、使用量特别大的资源，比如并发情况下的线程<br> 对性能影响很大。</p>\n</li>\n<li><p>JDK5.0提供了<strong>ExecutorService接口</strong>和<strong>Executors工具类</strong></p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.png\" alt=\"image-20220802193905003\"></p>\n</li>\n</ul>\n</li>\n<li><p><strong>自定义线程池</strong></p>\n<p><strong>ThreadPoolExecutor 类分析</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolExecutor</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * ⽤给定的初始参数创建⼀个新的ThreadPoolExecutor。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                              <span class=\"type\">int</span> maximumPoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                              <span class=\"type\">long</span> keepAliveTime,</span></span><br><span class=\"line\"><span class=\"params\">                              TimeUnit unit,</span></span><br><span class=\"line\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class=\"line\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span><br><span class=\"line\"><span class=\"params\">                              RejectedExecutionHandler handler)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>corePoolSize: 最大核心线程数量，常驻线程。</p>\n</li>\n<li><p>maximumPoolSize：最大线程数量，临时线程。</p>\n</li>\n<li><p>keepAliveTime：临时线程的最大空闲时间，超过这个时间的临时线程将会被销毁。</p>\n</li>\n<li><p>unit：空闲时间的单位。</p>\n</li>\n<li><p>workQueue：存放任务的阻塞队列。JDK提供的有：</p>\n<ul>\n<li>LinkedBlockingQueue：链表队列，最大长度为int类型最大值。</li>\n<li>SynchronousQueue：转发队列，长度为0，只对任务转发，不存储任务。</li>\n<li>DelayedWorkQueue：延迟队列，数据结构为堆，按照任务延迟时间排序。</li>\n</ul>\n</li>\n<li><p>threadFactory：线程创建工厂类，可以通过实现<code>java.util.concurrent.ThreadFactory</code>接口创建自己的工厂类。</p>\n</li>\n<li><p>handler：任务拒绝策略，线程池无法处理任务时执行的策略，可以通过实现java.util.concurrent.RejectedExecutionHandler接口创建自己的策略。</p>\n<p>JDK提供的策略如下：</p>\n<ul>\n<li>AbortPolicy：拒绝任务时会抛出一个异常。</li>\n<li>DiscardPolicy：拒绝任务时不会有任何提示，有数据丢失风险。</li>\n<li>DiscardOldestPolicy：拒绝任务时丢弃存活时间最长的任务。</li>\n<li>CallerRunsPolicy：拒绝任务时，将任务给提交的线程执行，同时可以减缓任务提交线程的提交速度，减轻线程池压力。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h3><ol>\n<li><p><strong>新建状态</strong></p>\n<p>当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。</p>\n</li>\n<li><p><strong>就绪状态</strong></p>\n<p>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的**<code>start()</code>方法**。当线程对象调用<code>start()</code>方法即启动了线程，<code>start()</code>方法创建线程运行的系统资源，并调度线程运行<code>run()</code>方法。当<code>start()</code>方法返回后，线程就处于就绪状态。</p>\n<p>处于就绪状态的线程并不一定立即运行<code>run()</code>方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。</p>\n</li>\n<li><p><strong>运行状态（running）</strong></p>\n<p>当线程获得CPU时间后，它才进入运行状态，真正开始执行<code>run()</code>方法。</p>\n</li>\n<li><p><strong>阻塞状态（blocked）</strong></p>\n<p>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。线程被堵塞可能是由下述五方面的原因造成的：</p>\n<p>(1) 调用<code>sleep</code>(毫秒数)，使线程进入”睡眠”状态。在规定的时间内，这个线程是不会运行的。</p>\n<p>(2) 用<code>suspend()</code>暂停了线程的执行。除非线程收到<code>resume()</code>消息，否则不会返回”可运行”状态。</p>\n<p>(3) 用<code>wait()</code>暂停了线程的执行。除非线程收到<code>nofify()</code>或者<code>notifyAll()</code>消息，否则不会变成”可运行”（是的，这看起来同原因2非常相象，但有一个明显的区别是我们马上要揭示的）。</p>\n<p>(4) 线程正在等候一些<code>IO</code>（输入输出）操作完成。</p>\n<p>(5) 线程试图调用另一个对象的”同步”方法，但那个对象处于锁定状态，暂时无法使用。</p>\n</li>\n<li><p><strong>死亡状态（dead）</strong></p>\n<p>有三个原因会导致线程死亡：</p>\n<ul>\n<li><code>run</code>方法正常退出而自然死亡；</li>\n<li>一个未捕获的异常终止了run方法而使线程猝死；</li>\n<li><code>stop()</code>方法。</li>\n</ul>\n<p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用<code>isAlive</code>方法，如果是可运行或被阻塞，这个方法返回<code>true</code>；如果线程仍旧是<code>new</code>状态且不是可运行的，或者线程死亡了，则返回<code>false</code>。</p>\n</li>\n</ol>\n<h3 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h3><p>​\t<img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.png\" alt=\"image-20220802194148223\"></p>\n<h3 id=\"线程同步和线程互斥\"><a href=\"#线程同步和线程互斥\" class=\"headerlink\" title=\"线程同步和线程互斥\"></a>线程同步和线程互斥</h3><ul>\n<li><strong>线程互斥：</strong>多个线程之间共享同一资源时会发生线程互斥。</li>\n<li><strong>线程同步：</strong>某个线程需要另一线程完成工作才能正常运行，称为线程同步。</li>\n</ul>\n<p><strong>由线程同步互斥问题引出线程的安全问题</strong></p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>当多条线程访问同一共享资源时容易引发线程安全问题。</p>\n<ol>\n<li><p>同步代码块：用<code>synchronized</code>关键字括起来的是同步代码块，在线程执行这块代码时，需要获得同步监视器的锁定，而若已被锁定，则只能等待。从而阻止两条线程对同一共享资源的并发访问。</p>\n</li>\n<li><p>同步方法：用<code>synchronized</code>关键字修饰的方法。原理与上相同。</p>\n</li>\n<li><p>同步锁（<code>Lock</code>）：<code>Lock</code>是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对<code>Lock</code>对象加锁，线程开始访问共享资源对象之前应先获得<code>Lock</code>对象。从而实现显式的加锁解锁。</p>\n<p><code>Java</code>提供了一种可重用锁<code>ReentranLock</code>，该锁对象会维持一个计数器来追踪<code>lock</code>方法的调用，从而可以对已经加锁的共享资源再次加锁。线程每次调用<code>lock</code>方法加锁后，必须显示调用<code>unlock</code>方法释放锁。</p>\n</li>\n</ol>\n<p><strong>Lock和Synchronized的区别</strong>：</p>\n<ul>\n<li><p>Synchronized 是Java的一个关键字，而Lock是java.util.concurrent.Locks 包下的一个接口；</p>\n</li>\n<li><p>Synchronized 使用过后，会自动释放锁，而Lock需要手动上锁、手动释放锁。（在 finally 块中）</p>\n</li>\n<li><p>Lock提供了更多的实现方法，而且 可响应中断、可定时， 而synchronized 关键字不能响应中断；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Lock() ; <span class=\"comment\">//获取锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">tryLock(); <span class=\"comment\">//获取锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">tryLock(<span class=\"type\">long</span> time, TimeUnit unit); <span class=\"comment\">//在一定时间单位内等待后，尝试获取锁；</span></span><br><span class=\"line\"></span><br><span class=\"line\">lockInterruptibly(); <span class=\"comment\">//获取锁，可响应中断；</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">响应中断：</span></span><br><span class=\"line\"><span class=\"comment\">A、B 线程同时想获取到锁，A获取锁以后，B会进行等待，这时候等待着锁的线程B，会被Tread.interrupt()方法给中断等待状态、然后去执行其他的事情，</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>synchronized关键字是非公平锁，即，不能保证等待锁的那些线程们的顺序，而Lock的子类ReentrantLock默认是非公平锁，但是可通过一个布尔参数的构造方法实例化出一个公平锁；</p>\n</li>\n<li><p>二者的底层实现不一样：synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略（底层基于volatile关键字和CAS算法实现）</p>\n</li>\n</ul>\n<h4 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h4><p>当两个线程互相需要对方线程锁住的资源才能继续运行时会发生死锁，因为两个线程都在等待对方释放同步监视器。一旦出现死锁，整个程序既不会发生异常，也不会有任何提示，而是所有线程处于阻塞状态无法继续。</p>\n<h3 id=\"守护线程-x2F-后台线程\"><a href=\"#守护线程-x2F-后台线程\" class=\"headerlink\" title=\"守护线程&#x2F;后台线程\"></a>守护线程&#x2F;后台线程</h3><ul>\n<li><strong>代表：</strong>垃圾回收线程；</li>\n<li><strong>特点：</strong>守护线程内部是一个死循环守护线程随着所有用户线程的结束而结束；</li>\n<li><strong>作用：</strong>数据自动备份,垃圾回收……</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DeamonThread</span> <span class=\"variable\">dt</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DeamonThread</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置为后台线程</span></span><br><span class=\"line\">\t\tdt.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\tdt.start();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"定时器机制\"><a href=\"#定时器机制\" class=\"headerlink\" title=\"定时器机制\"></a>定时器机制</h3><ul>\n<li><strong>特点：</strong>间隔特定时间执行特定程序；</li>\n<li><strong>定时器的实现 ：</strong><ul>\n<li>Thread.sleep()方法</li>\n<li>java.util.Timer类</li>\n<li>SpringTask框架</li>\n</ul>\n</li>\n<li><strong>作用：</strong>定时器和守护线程的联合使用实现数据自动备份</li>\n</ul>\n<h3 id=\"线程协调运行（线程的通信）\"><a href=\"#线程协调运行（线程的通信）\" class=\"headerlink\" title=\"线程协调运行（线程的通信）\"></a>线程协调运行（线程的通信）</h3><p><code>Object</code>类提供<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>三个方法来实现线程协调，这三个方法必须同步监视器对象调用。</p>\n<ol>\n<li><code>wait()</code>：导致当前线程等待，直到其他线程调用<code>notify()</code>或<code>notifyAll()</code>来唤醒该线程。<code>Wait()</code>会释放对同步监视器的锁定。</li>\n<li><code>notify()</code>：唤醒在等待的单个线程。如果等待的线程有复数个，则只是随机选择其中一个唤醒。<br><code>notifyAll()</code>：唤醒所有在等待中的线程。</li>\n</ol>\n<p>使用Condition类控制线程通信</p>\n<ul>\n<li>当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。</li>\n<li>Condition将同步监视器方法(wait(),notify()和notifyAll())分解成截然不同的对象，以便通过讲这些对象与Lock对象组合使用，为每个对象提供多个等待集(wait-set)。在这种情况下，Lock替代了同步方法或同步代码块，Condition替代了同步监视器的功能。</li>\n<li>await():类似于隐式同步监视器上的wait()方法，导致当前线程等待，知道其他线程调用Condition的signal()方法或signalAll()方法来唤醒该线程。该await()方法有更多变体，如long awaitNanos(long nanosTimeout)、void awaitUninterruptible()、awaitUnitl(Date deadline)等，可以完成更丰富的等待操作。</li>\n<li>signal():唤醒在此Lock对象上等待的单个线程，如果所有线程都在该Lock对象上等待，则会选择唤醒其中一个线程。选择是任意性的，只有当前线程放弃对该Lock对象的锁定后(使用await()方法),才可以执行被唤醒的线程。</li>\n<li>signalAll():唤醒在此Lock对象上等待的所有线程。只有当前线程房钱对该Lock对象的锁定后，才可以执行被唤醒的线程。</li>\n</ul>\n<h3 id=\"ThreadLock\"><a href=\"#ThreadLock\" class=\"headerlink\" title=\"ThreadLock\"></a>ThreadLock</h3><p>ThreadLock叫做**&#x3D;&#x3D;线程变量&#x3D;&#x3D;**，该变量是当前线程独有的变量。ThreadLock为每个线程创造一个副本，每个线程可以访问自己内部的副本变量。</p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.png\" alt=\"image-20220811092913797\"></p>\n<h3 id=\"JUC的三个辅助类\"><a href=\"#JUC的三个辅助类\" class=\"headerlink\" title=\"JUC的三个辅助类\"></a>JUC的三个辅助类</h3><h4 id=\"CountDownLatch：减少计数\"><a href=\"#CountDownLatch：减少计数\" class=\"headerlink\" title=\"CountDownLatch：减少计数\"></a>CountDownLatch：减少计数</h4><p>CountDownLatch是JUC包中线程提同步器的一种实现，又称为倒计数器，通过让一个或多个线程等待其他线程结束后再继续自己的操作，类似加强版<code>join()</code>；</p>\n<ul>\n<li>countDown：执行一次，计数器的数值-1。</li>\n<li>await：等待计数器的值为0，才进行后面的操作。</li>\n</ul>\n<h4 id=\"CyclicBarrier：循环栅栏\"><a href=\"#CyclicBarrier：循环栅栏\" class=\"headerlink\" title=\"CyclicBarrier：循环栅栏\"></a>CyclicBarrier：循环栅栏</h4><p>CyclicBarrier允许一组线程相互等待，直到达到某个<strong>公共屏障点</strong>，等待线程才继续执行。而且这个Barrier（栅栏）在释放等待线程后可以复用，所以被称为循环栅栏。</p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.png\" alt=\"image-20220811095018033\"></p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.png\" alt=\"image-20220811095058528\"></p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/6.png\" alt=\"image-20220811095117263\"></p>\n<h4 id=\"Semaphore：信号灯\"><a href=\"#Semaphore：信号灯\" class=\"headerlink\" title=\"Semaphore：信号灯\"></a>Semaphore：信号灯</h4><p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/7.png\" alt=\"image-20220811095220875\"></p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/8.png\" alt=\"image-20220811095258504\"></p>\n<h3 id=\"悲观锁与乐观锁\"><a href=\"#悲观锁与乐观锁\" class=\"headerlink\" title=\"悲观锁与乐观锁\"></a>悲观锁与乐观锁</h3><p><strong>悲观锁：</strong></p>\n<p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>\n<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>\n<p><strong>乐观锁：</strong></p>\n<p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>\n<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>读锁和写锁都会出现死锁的情况</p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/9.png\" alt=\"image-20220811100240242\"></p>\n<h3 id=\"阻塞队列-BlockingQueue-控制线程通信\"><a href=\"#阻塞队列-BlockingQueue-控制线程通信\" class=\"headerlink\" title=\"阻塞队列(BlockingQueue)控制线程通信\"></a>阻塞队列(BlockingQueue)控制线程通信</h3><p>Java5提供了一个BlockingQueue接口，虽然BlockingQueue也是Queue的子接口，但它的主要用途并不是作为容器，而是作为线程同步的工具。BlockingQueue具有一个特性：当生产者线程试图想BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。程序的两个线程通过交替想BlockingQueue中放入元素、取出元素，既可很好地控制线程的通信。</p>\n<p><img src=\"/2022/08/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.png\" alt=\"image-20220811100442724\"></p>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>volatile是jvm提供的轻量级同步机制。</p>\n<h4 id=\"volatile的三大特性：\"><a href=\"#volatile的三大特性：\" class=\"headerlink\" title=\"volatile的三大特性：\"></a>volatile的三大特性：</h4><ul>\n<li>保证可见性</li>\n</ul>\n<p><strong>只要有一个线程修改了主内存的变量的值以后，其他的线程能马上知道并获取到最新的值</strong></p>\n<ul>\n<li>不保证原子性</li>\n<li>有序性</li>\n</ul>\n<h4 id=\"运用场景\"><a href=\"#运用场景\" class=\"headerlink\" title=\"运用场景\"></a>运用场景</h4><p><strong>单例模式(懒汉式)：</strong></p>\n<p>&#x3D;&#x3D;未使用volatile关键字&#x3D;&#x3D;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">type5</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> type5 type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">type5</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> type5 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(type == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(type5.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(type == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    type = <span class=\"keyword\">new</span> <span class=\"title class_\">type5</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在有A B两个线程同时进来，都通过了第一次检查。现在到达了synchronized同步锁外面</li>\n<li>A线程运气好，被先放进去了，再次检查发现type确实为null，好，放行</li>\n<li>A线程new了一个实例出来，这是把这个最新的实例返回给主内存，主内存的对象变量从Null变为有值</li>\n<li>A线程完成，B线程被放synchronized开始进行B线程的第二次检查</li>\n<li>但由于type5 变量没有volatile修饰，所以线程B不能马上获取到最新的值，它不知道现在对象已经被new出来了，在线程B自己的工作内存了对象依然为null。</li>\n<li>B线程通过第二次检查，又new了一个对象出来。单例的目标没有达成，上面的代码失败。</li>\n</ul>\n<p>&#x3D;&#x3D;使用volatile关键字&#x3D;&#x3D;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> type5 type;</span><br></pre></td></tr></table></figure>\n\n<p>保证属性的可见性，单例目标达成！</p>\n<h3 id=\"BIO-NIO-AIO-有什么区别\"><a href=\"#BIO-NIO-AIO-有什么区别\" class=\"headerlink\" title=\"BIO,NIO,AIO 有什么区别?\"></a>BIO,NIO,AIO 有什么区别?</h3><ul>\n<li><strong>BIO (Blocking I&#x2F;O):</strong> 同步阻塞 I&#x2F;O 模式，数据的读取写⼊必须阻塞在⼀个线程内等待其完成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐᫾不错的，可以让每⼀个连接专注于⾃⼰的 I&#x2F;O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。线程池本身就是⼀个天然的漏⽃，可以缓冲⼀些系统处理不了的连接或请求。但是，当⾯对⼗万甚⾄百万级连接的时候，传统的 BIO 模型是⽆能为⼒的。因此，我们需要⼀种更⾼效的 I&#x2F;O 处理模型来应对更⾼的并发量。</li>\n<li><strong>NIO (Non-blocking&#x2F;New I&#x2F;O):</strong> NIO 是⼀种同步⾮阻塞的 I&#x2F;O 模型，在 Java 1.4 中引⼊了NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I&#x2F;O 操作⽅法。 NIO提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都⽀持阻塞和⾮阻塞两种模式。阻塞模式使⽤就像传统中的⽀持⼀样，比较简单，但是性能和可靠性都不好；⾮阻塞模式正好与之相反。对于低负载、低并发的应⽤程序，可以使⽤同步阻塞 I&#x2F;O 来提升开发速率和更好的维护性；对于⾼负载、⾼并发的（⽹络）应⽤，应使⽤ NIO 的⾮阻塞模式来开发。</li>\n<li><strong>AIO (Asynchronous I&#x2F;O):</strong> AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是异步⾮阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应⽤操作之后会直接返回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在⽹络操作中，提供了⾮阻塞的⽅法，但是 NIO 的 IO ⾏为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程⾃⾏进⾏ IO 操作，IO 操作本身是同步的。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还不是很⼴泛，Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。</li>\n</ul>\n","categories":["Java学习","Java基础"],"tags":["知识点","多线程"]},{"title":"异常","url":"/2022/08/03/%E5%BC%82%E5%B8%B8/","content":"<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h3 id=\"一、异常的概述\"><a href=\"#一、异常的概述\" class=\"headerlink\" title=\"一、异常的概述\"></a>一、异常的概述</h3><ol>\n<li>异常是指程序执行过程中可能出现的非正常情况</li>\n<li>JAVA的异常机制提高程序健壮性和容错性</li>\n<li>异常在JAVA中以类和对象的形式存在</li>\n</ol>\n<h3 id=\"二、异常的分类\"><a href=\"#二、异常的分类\" class=\"headerlink\" title=\"二、异常的分类\"></a>二、异常的分类</h3><img src=\"/2022/08/03/%E5%BC%82%E5%B8%B8/1.png\" alt=\"image-20220803191349152\" style=\"zoom:80%;\">\n\n<table>\n<thead>\n<tr>\n<th><strong>编译时异常</strong></th>\n<th>Exception的直接子类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>运行时异常</strong></td>\n<td><strong>RuntimeException</strong></td>\n</tr>\n<tr>\n<td><strong>受检异常</strong></td>\n<td><strong>CheckException</strong></td>\n</tr>\n<tr>\n<td><strong>非受检异常</strong></td>\n<td><strong>UnCheckedException</strong></td>\n</tr>\n</tbody></table>\n<p><strong>异常的区别：</strong></p>\n<ol>\n<li>Error是指不可处理的错误,直接退出JVM虚拟机；</li>\n<li>Exception是指可以处理的异常；</li>\n<li>编译时异常是指在编写程序阶段,必须预先处理异常否则编译不通过；</li>\n<li>运行时异常是指在编写程序阶段,即使不预先处理异常也可以编译通过。</li>\n</ol>\n<span id=\"more\"></span>\n\n<p><strong>&#x3D;&#x3D;常见的异常类：&#x3D;&#x3D;</strong></p>\n<ul>\n<li><strong>NullPointerException：</strong>当应用程序试图访问空对象时，则抛出该异常。</li>\n<li><strong>SQLException</strong>：提供关于数据库访问错误或其他错误信息的异常。</li>\n<li><strong>IndexOutOfBoundsException</strong>：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>\n<li><strong>NumberFormatException</strong>：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>\n<li><strong>FileNotFoundException</strong>：当试图打开指定路径名表示的文件失败时，抛出此异常。</li>\n<li><strong>IOException</strong>：当发生某种I&#x2F;O异常时，抛出此异常。此类是失败或中断的I&#x2F;O操作生成的异常的通用类。</li>\n<li><strong>ClassCastException</strong>：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>\n<li><strong>ArrayStoreException</strong>：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>\n<li><strong>IllegalArgumentException</strong>：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>\n<li><strong>ArithmeticException</strong>：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li>\n<li><strong>NegativeArraySizeException</strong>：如果应用程序试图创建大小为负的数组，则抛出该异常。</li>\n<li><strong>NoSuchMethodException</strong>：无法找到某一特定方法时，抛出该异常。</li>\n<li><strong>SecurityException</strong>：由安全管理器抛出的异常，指示存在安全侵犯。</li>\n<li><strong>UnsupportedOperationException</strong>：当不支持请求的操作时，抛出该异常。</li>\n<li><strong>RuntimeException</strong>：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li>\n</ul>\n<h3 id=\"三、异常的处理机制\"><a href=\"#三、异常的处理机制\" class=\"headerlink\" title=\"三、异常的处理机制\"></a>三、异常的处理机制</h3><ol>\n<li><strong>异常上抛机制</strong><ul>\n<li>异常上抛机制是指发生异常时创建异常对象并将其上抛给其调用者；</li>\n<li>异常上抛机制需要在方法声明位置上使用throws关键字。</li>\n</ul>\n</li>\n<li><strong>异常捕获机制</strong><ul>\n<li>异常捕捉机制是指发生异常时创建异常对象并将其捕捉而不进行上抛；</li>\n<li>异常捕捉机制需要使用try&#x2F;catch语句块进行捕捉异常。</li>\n</ul>\n</li>\n<li><strong>&#x3D;&#x3D;注意事项&#x3D;&#x3D;</strong><ul>\n<li>如果异常一直上抛到JVM虚拟机,那么JVM会终止程序执行[main方法中不建议使用异常上抛]；</li>\n<li>异常上抛不允许后续代码执行,而异常捕捉允许后续代码执行</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"四、异常对象的常用方法及异常机制的关键字\"><a href=\"#四、异常对象的常用方法及异常机制的关键字\" class=\"headerlink\" title=\"四、异常对象的常用方法及异常机制的关键字\"></a>四、异常对象的常用方法及异常机制的关键字</h3><h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li><p>exception.getMessage()：获取异常简单的描述信息；</p>\n</li>\n<li><p>exception.printStackTrace()：打印异常追踪的堆栈信息。</p>\n</li>\n</ul>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><h5 id=\"异常上抛机制：throw-throws\"><a href=\"#异常上抛机制：throw-throws\" class=\"headerlink\" title=\"异常上抛机制：throw,throws\"></a>异常上抛机制：throw,throws</h5><ol>\n<li>throw表示在方法中手动抛出一个异常对象；</li>\n<li>throws在方法上声明,表示此方法在调用时必须处理异常。</li>\n</ol>\n<h5 id=\"异常捕获机制：try-catch-finally\"><a href=\"#异常捕获机制：try-catch-finally\" class=\"headerlink\" title=\"异常捕获机制：try,catch,finally\"></a>异常捕获机制：try,catch,finally</h5><ol>\n<li>关于try的注意事项<ul>\n<li>try语句块不能单独出现；</li>\n<li>try语句块需要和catch语句块或者finally语句块联合使用。</li>\n</ul>\n</li>\n<li>关于catch的注意事项<ul>\n<li>；catch语句块的类型既可以是确切类型,也可以是其父类</li>\n<li>catch语句块可以写多个[遵循异常类型从小到大的顺序编写catch语句块]；</li>\n<li>建议编写catch语句块时，精确到一个异常对应一个catch语句块[利于程序调试]。</li>\n</ul>\n</li>\n<li>关于finally的注意事项<ul>\n<li>finally语句块中的代码必定执行；</li>\n<li>finally语句块通常用于释放或者关闭资源。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"五、自定义异常\"><a href=\"#五、自定义异常\" class=\"headerlink\" title=\"五、自定义异常\"></a>五、自定义异常</h3><ol>\n<li>类继承Exception或者RuntimeException</li>\n<li>类提供无参构造器和带参构造器[形参为String类型]</li>\n</ol>\n<p><strong>&#x3D;&#x3D;注意&#x3D;&#x3D;</strong></p>\n<ol>\n<li><strong>final属于关键字</strong> <ul>\n<li>final修饰的变量不能重新赋值</li>\n<li>final修饰的类无法继承</li>\n<li>final修饰的方法无法覆盖</li>\n</ul>\n</li>\n<li>finally属于关键字<ul>\n<li>finally和try联合使用在异常捕捉机制中</li>\n<li>finally语句块中的代码必定执行</li>\n</ul>\n</li>\n<li>finalize属于标识符 <ul>\n<li>finalize()属于Object类中的一个方法</li>\n<li>finalize()在执行对象被销毁之前由GC[垃圾回收器]调用</li>\n<li>finalize()主要用于清理本地对象或者确保释放某些非内存资源的补充</li>\n</ul>\n</li>\n</ol>\n","categories":["Java学习","Java基础"],"tags":["知识点","异常"]},{"title":"搜索与回溯算法","url":"/2022/05/15/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n<p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">3</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p><strong>返回：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">20</span>,<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>节点总数 &lt;&#x3D; 1000</li>\n</ul>\n<span id=\"more\"></span>\n\n\n\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><ul>\n<li>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</li>\n<li>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</li>\n</ul>\n<img src=\"/2022/05/15/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.png\" alt=\"Picture0.png\" style=\"zoom: 67%;\">\n\n\n\n<h5 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h5><ol>\n<li><strong>特例处理：</strong>当根节点为空时，直接返回空列表[]；</li>\n<li><strong>初始化：</strong>打印结果列表<code>list</code>，队列<code>queue[]</code>将<code>root</code>根节点放入队列；</li>\n<li><strong>BFS循环：</strong>当队列为空时退出循环<ul>\n<li><strong>出队：</strong>队首元素出队，记为<code>T</code>；</li>\n<li><strong>打印：</strong>将<code>T.val</code>添加至列表<code>list</code>尾部；</li>\n<li><strong>添加子节点：</strong>若<code>T</code>的左(右)节点不为空，则将左(右)节点加入队列<code>queue</code>；</li>\n</ul>\n</li>\n<li><strong>返回值：</strong>将打印列表转为数组<code>res</code>，返回数组<code>res</code>即可。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();   </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">T</span> <span class=\"operator\">=</span> queue.remove();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T.left != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                queue.add(T.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(T.right != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                queue.add(T.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            list.add(T.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[list.size()];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size(); i++)</span><br><span class=\"line\">                res[i] = list.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>\n<p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">3</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">9</span>  <span class=\"number\">20</span></span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> <span class=\"number\">15</span>   <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>返回其层次遍历结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">3</span>],</span><br><span class=\"line\">  [<span class=\"number\">20</span>,<span class=\"number\">9</span>],</span><br><span class=\"line\">  [<span class=\"number\">15</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<ul>\n<li>节点总数 &lt;&#x3D; 1000</li>\n</ul>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路：层序遍历-双端队列\"><a href=\"#解题思路：层序遍历-双端队列\" class=\"headerlink\" title=\"解题思路：层序遍历 + 双端队列\"></a>解题思路：层序遍历 + 双端队列</h5><ul>\n<li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列)<code>tmp</code>，并规定：<ul>\n<li>奇数层 则添加至 <code>tmp</code> <strong>尾部</strong> ，</li>\n<li>偶数层 则添加至 <code>tmp</code> <strong>头部</strong> 。</li>\n</ul>\n</li>\n</ul>\n<img src=\"/2022/05/15/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/2.png\" alt=\"Picture1.png\" style=\"zoom: 67%;\">\n\n\n\n<h5 id=\"算法流程：\"><a href=\"#算法流程：\" class=\"headerlink\" title=\"算法流程：\"></a>算法流程：</h5><ol>\n<li><strong>特例处理：</strong> 当树的根节点为空，则直接返回空列表 <code>[]</code> ；</li>\n<li><strong>初始化：</strong> 打印结果空列表 <code>res</code> ，包含根节点的双端队列 <code>deque</code> ；</li>\n<li><strong>BFS 循环：</strong> 当 <code>deque</code> 为空时跳出；<ul>\n<li>新建列表 <code>tmp</code> ，用于临时存储当前层打印结果；</li>\n<li><strong>当前层打印循环：</strong> 循环次数为当前层节点数（即 <code>deque</code> 长度）；<ul>\n<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>\n<li><strong>打印：</strong> 若为奇数层，将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；否则，添加至 <code>tmp</code>头部；</li>\n<li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则加入 <code>deque</code> ；</li>\n</ul>\n</li>\n<li>将当前层结果 <code>tmp</code> 转化为 <code>list</code> 并添加入 <code>res</code> ；</li>\n</ul>\n</li>\n<li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">levelOrder</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root != <span class=\"literal\">null</span>) </span><br><span class=\"line\">            queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty()) &#123;</span><br><span class=\"line\">            LinkedList&lt;Integer&gt; tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> queue.size(); i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res.size() % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    tmp.addLast(node.val); <span class=\"comment\">// 偶数层 -&gt; 队列头部</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    tmp.addFirst(node.val); <span class=\"comment\">// 奇数层 -&gt; 队列尾部</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.left != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    queue.add(node.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.right != <span class=\"literal\">null</span>) </span><br><span class=\"line\">                    queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.add(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：jyd</p>\n</blockquote>\n","categories":["LeetCode学习","搜索与回溯算法"],"tags":["算法","二叉树","广度优先搜索"]},{"title":"搜索与回溯算法三","url":"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>\n<p><img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/1.jpg\" alt=\"img\"></p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：board = [[<span class=\"string\">&quot;A&quot;</span>,<span class=\"string\">&quot;B&quot;</span>,<span class=\"string\">&quot;C&quot;</span>,<span class=\"string\">&quot;E&quot;</span>],[<span class=\"string\">&quot;S&quot;</span>,<span class=\"string\">&quot;F&quot;</span>,<span class=\"string\">&quot;C&quot;</span>,<span class=\"string\">&quot;S&quot;</span>],[<span class=\"string\">&quot;A&quot;</span>,<span class=\"string\">&quot;D&quot;</span>,<span class=\"string\">&quot;E&quot;</span>,<span class=\"string\">&quot;E&quot;</span>]], word = <span class=\"string\">&quot;ABCCED&quot;</span></span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：board = [[<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>],[<span class=\"string\">&quot;c&quot;</span>,<span class=\"string\">&quot;d&quot;</span>]], word = <span class=\"string\">&quot;abcd&quot;</span></span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= board.length &lt;= 200</code></li>\n<li><code>1 &lt;= board[i].length &lt;= 200</code></li>\n<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>\n</ul>\n <span id=\"more\"></span>\n\n\n\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>\n<ul>\n<li><p><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>\n</li>\n<li><p><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（<em>例如：此矩阵元素和目标字符不同、此元素已被访问）</em>，则应立即返回，称之为 <code>可行性剪枝</code> 。</p>\n</li>\n</ul>\n<img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/2.png\" style=\"zoom: 50%;\">\n\n\n\n<h5 id=\"算法设计\"><a href=\"#算法设计\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h5><p><strong>DFS解析：</strong></p>\n<ul>\n<li><p><strong>递归参数：</strong> 当前元素在矩阵 <code>board</code> 中的行列索引 <code>i</code> 和 <code>j</code> ，当前目标字符在 <code>word</code> 中的索引 <code>k</code> 。</p>\n</li>\n<li><p><strong>终止条件：</strong></p>\n<ol>\n<li>返回 $false$：(1) 行或列索引越界 <strong>或</strong> (2) 当前矩阵元素与目标字符不同 <strong>或</strong> (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。</li>\n<li>返回 $true$ ： <code>k = len(word) - 1</code> ，即字符串 <code>word</code> 已全部匹配。</li>\n</ol>\n</li>\n<li><p><strong>递推工作：</strong></p>\n<ol>\n<li>标记当前矩阵元素： 将 <code>board[i][j]</code> 修改为 <strong>空字符</strong> <code>&#39;\\0&#39;</code> ，代表此元素已访问过，防止之后搜索时重复访问。</li>\n<li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 <code>||</code> 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 <code>res</code> 。</li>\n<li>还原当前矩阵元素： 将 <code>board[i][j]</code> 元素还原至初始值，即 <code>word[k]</code> 。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exist</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span>[] words = word.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; board.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dfs(board, words, i, j, <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">dfs</span> <span class=\"params\">(<span class=\"type\">char</span>[][] board,<span class=\"type\">char</span>[] word,<span class=\"type\">int</span> i,<span class=\"type\">int</span> j,<span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span> || j&lt;<span class=\"number\">0</span> || i&gt;=board.length || j&gt;=board[<span class=\"number\">0</span>].length || board[i][j] != word[k])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == word.length-<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        board[i][j] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> dfs(board,word,i,j+<span class=\"number\">1</span>,k+<span class=\"number\">1</span>) || dfs(board,word,i+<span class=\"number\">1</span>,j,k+<span class=\"number\">1</span>) || dfs(board,word,i,j-<span class=\"number\">1</span>,k+<span class=\"number\">1</span>) || dfs(board,word,i-<span class=\"number\">1</span>,j,k+<span class=\"number\">1</span>);</span><br><span class=\"line\">        board[i][j] = word[k];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：m = <span class=\"number\">2</span>, n = <span class=\"number\">3</span>, k = <span class=\"number\">1</span></span><br><span class=\"line\">输出：<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：m = <span class=\"number\">3</span>, n = <span class=\"number\">1</span>, k = <span class=\"number\">0</span></span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n,m &lt;= 100</code></li>\n<li><code>0 &lt;= k &lt;= 20</code></li>\n</ul>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>本题与 <a href=\"https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/\">矩阵中的路径</a> 类似，是典型的搜索 &amp; 回溯问题。在介绍回溯算法算法前，为提升计算效率，首先讲述前置工作： <strong>数位之和计算</strong> 。</p>\n<p><strong>数位之和计算：</strong></p>\n<p>设一数字 $x$ ，向下取整除法符号 $&#x2F;$ ，求余符号 $⊙$ ，则有：</p>\n<ul>\n<li>$x⊙10$ ：得到 $x$ 的个位数字；</li>\n<li>$x &#x2F; 10$ ： 令 $x$ 的十进制数向右移动一位，即删除个位数字。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">he</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum+=n%<span class=\"number\">10</span>;</span><br><span class=\"line\">            n/=<span class=\"number\">10</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>深度优先遍历 DFS</strong></p>\n<ul>\n<li><p><strong>深度优先搜索：</strong> 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>\n</li>\n<li><p><strong>剪枝：</strong> 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 <code>可行性剪枝</code> 。</p>\n</li>\n</ul>\n<h5 id=\"算法设计-1\"><a href=\"#算法设计-1\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h5><ul>\n<li><p><strong>递归参数：</strong> 当前元素在矩阵中的行列索引 <code>i</code> 和 <code>j</code> ，两者的数位和 <code>si</code>, <code>sj</code> 。</p>\n</li>\n<li><p><strong>终止条件：</strong> 当 $①$ 行列索引越界 <strong>或</strong> $②$ 数位和超出目标值 <code>k</code> <strong>或</strong> $③$ 当前元素已访问过 时，返回 $0$ ，代表不计入可达解。</p>\n</li>\n<li><p><strong>递推工作：</strong></p>\n<ul>\n<li><strong>标记当前单元格</strong> ：将索引 <code>(i, j)</code> 存入 Set <code>visited</code> 中，代表此单元格已被访问过。</li>\n<li><strong>搜索下一单元格：</strong> 计算当前元素的 <strong>下、右</strong> 两个方向元素的数位和，并开启下层递归 。</li>\n</ul>\n</li>\n<li><p><strong>回溯返回值：</strong> 返回 <code>1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</code>，代表从本单元格递归搜索的可达解总数。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> m, n, k;</span><br><span class=\"line\">    <span class=\"type\">boolean</span>[][] visited;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">movingCount</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.m = m; <span class=\"built_in\">this</span>.n = n; <span class=\"built_in\">this</span>.k = k;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.visited = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || i &gt;= m || j &lt; <span class=\"number\">0</span> || j &gt;= n || he(i) + he(j) &gt; k || visited[i][j])  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        visited[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + dfs(i + <span class=\"number\">1</span>, j) + dfs(i, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">he</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum+=n%<span class=\"number\">10</span>;</span><br><span class=\"line\">            n/=<span class=\"number\">10</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>广度优先遍历BFS也可，这里不做分析</strong></p>\n<hr>\n<h3 id=\"例题三\"><a href=\"#例题三\" class=\"headerlink\" title=\"例题三\"></a>例题三</h3><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/3.jpg\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"literal\">null</span>,<span class=\"number\">13</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">2</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>], targetSum = <span class=\"number\">22</span></span><br><span class=\"line\">输出：[[<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">11</span>,<span class=\"number\">2</span>],[<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/4.jpg\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], targetSum = <span class=\"number\">5</span></span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例3：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [<span class=\"number\">1</span>,<span class=\"number\">2</span>], targetSum = <span class=\"number\">0</span></span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n<h4 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p>\n<ul>\n<li><strong>先序遍历：</strong> 按照 “根、左、右” 的顺序，遍历树的所有节点。</li>\n<li><strong>路径记录：</strong> 在先序遍历中，记录从根节点到当前节点的路径。当路径为 $①$ 根节点到叶节点形成的路径 <strong>且</strong> $②$ 各节点值的和等于目标值 <code>sum</code> 时，将此路径加入结果列表。</li>\n</ul>\n<img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/5.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\">\n\n<h5 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h5><p><strong><code>pathSum(root, sum)</code> 函数：</strong></p>\n<ul>\n<li><strong>初始化：</strong> 结果列表 <code>res</code> ，路径列表 <code>path</code> 。</li>\n<li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li>\n</ul>\n<p><strong><code>resSum(root, tar) 函数：</code></strong></p>\n<ul>\n<li><p><strong>递推参数：</strong> 当前节点 <code>root</code> ，当前目标值 <code>tar</code> 。</p>\n</li>\n<li><p><strong>终止条件：</strong> 若节点 <code>root</code> 为空，则直接返回。</p>\n</li>\n<li><p><strong>递推工作：</strong></p>\n<ul>\n<li>路径更新： 将当前节点值 <code>root.val</code> 加入路径 <code>path</code> ；</li>\n<li>目标值更新： <code>tar = tar - root.val</code>（即目标值 <code>tar</code> 从 <code>sum</code> 减至 $0$ ）；</li>\n<li>路径记录： 当 ① <code>root</code> 为叶节点 <strong>且</strong> ② 路径和等于目标值 ，则将此路径 <code>path</code> 加入 <code>res</code> 。</li>\n<li>先序遍历： 递归左 &#x2F; 右子节点。</li>\n<li>路径恢复： 向上回溯前，需要将当前节点从路径 <code>path</code> 中删除，即执行 <code>path.pop()</code> 。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; push = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        resSum(root,target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">resSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> target)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        push.add(root.val);</span><br><span class=\"line\">        target -= root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span> &amp;&amp; root.right == <span class=\"literal\">null</span> &amp;&amp; root.left == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>(push));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resSum(root.left,target);</span><br><span class=\"line\">        resSum(root.right,target);</span><br><span class=\"line\">        push.removeLast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题四\"><a href=\"#例题四\" class=\"headerlink\" title=\"例题四\"></a>例题四</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>\n<p> 为了让您更好地理解问题，以下面的二叉搜索树为例：</p>\n<img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/6.png\" alt=\"img\" style=\"zoom: 80%;\">\n\n<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>\n<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>\n<img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/7.png\" alt=\"img\" style=\"zoom:80%;\">\n\n<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>\n<h4 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>本文解法基于性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p>\n<p>将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p>\n<ol>\n<li><strong>排序链表：</strong> 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点。</li>\n<li><strong>双向链表：</strong> 在构建相邻节点的引用关系时，设前驱节点 <code>pre</code> 和当前节点 <code>cur</code> ，不仅应构建 <code>pre.right = cur</code> ，也应构建 <code>cur.left = pre</code> 。</li>\n<li><strong>循环链表：</strong> 设链表头节点 <code>head</code> 和尾节点 <code>tail</code> ，则应构建 <code>head.left = tail</code> 和 <code>tail.right = head</code> 。</li>\n</ol>\n<img src=\"/2022/05/23/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%89/8.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\">\n\n<p><strong>中序遍历</strong> 为对二叉树作 “左、根、右” 顺序遍历，递归实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打印中序遍历</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(Node root)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    dfs(root.left); <span class=\"comment\">// 左</span></span><br><span class=\"line\">    System.out.println(root.val); <span class=\"comment\">// 根</span></span><br><span class=\"line\">    dfs(root.right); <span class=\"comment\">// 右</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据以上分析，考虑使用中序遍历访问树的各节点 <code>cur</code> ；并在访问每个节点时构建 <code>cur</code> 和前驱节点 <code>pre</code> 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p>\n<h5 id=\"算法设计-2\"><a href=\"#算法设计-2\" class=\"headerlink\" title=\"算法设计\"></a>算法设计</h5><p><strong><code>dfs(cur):</code> 递归法中序遍历；</strong></p>\n<ul>\n<li><strong>终止条件：</strong> 当节点 <code>cur</code> 为空，代表越过叶节点，直接返回；</li>\n<li>递归左子树，即 <code>dfs(cur.left)</code> ；</li>\n<li><strong>构建链表：</strong><ol>\n<li><strong>当 <code>pre</code> 为空时：</strong> 代表正在访问链表头节点，记为 <code>head</code> ；</li>\n<li><strong>当 <code>pre</code> 不为空时：</strong> 修改双向节点引用，即 <code>pre.right = cur</code> ， <code>cur.left = pre</code> ；</li>\n<li><strong>保存 <code>cur</code> ：</strong> 更新 <code>pre = cur</code> ，即节点 <code>cur</code> 是后继节点的 <code>pre</code> ；</li>\n</ol>\n</li>\n<li>递归右子树，即 <code>dfs(cur.right)</code> ；</li>\n</ul>\n<p><strong><code>treeToDoublyList(root)：</code></strong></p>\n<ol>\n<li><strong>特例处理：</strong> 若节点 <code>root</code> 为空，则直接返回；</li>\n<li><strong>初始化：</strong> 空节点 <code>pre</code> ；</li>\n<li><strong>转化为双向链表：</strong> 调用 <code>dfs(root)</code> ；</li>\n<li><strong>构建循环链表：</strong> 中序遍历完成后，<code>head</code> 指向头节点， <code>pre</code> 指向尾节点，因此修改 <code>head</code> 和 <code>pre</code> 的双向节点引用即可；</li>\n<li><strong>返回值：</strong> 返回链表的头节点 <code>head</code> 即可；</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">// Definition for a Node.</span></span><br><span class=\"line\"><span class=\"comment\">class Node &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    public int val;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node left;</span></span><br><span class=\"line\"><span class=\"comment\">    public Node right;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    public Node(int _val,Node _left,Node _right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        val = _val;</span></span><br><span class=\"line\"><span class=\"comment\">        left = _left;</span></span><br><span class=\"line\"><span class=\"comment\">        right = _right;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    Node head,pre;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node <span class=\"title function_\">treeToDoublyList</span><span class=\"params\">(Node root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        dfs(root);</span><br><span class=\"line\">        head.left = pre;</span><br><span class=\"line\">        pre.right = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(Node cur)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        dfs(cur.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            head = cur;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cur.left = pre;</span><br><span class=\"line\">            pre.right = cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        dfs(cur.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["LeetCode学习","搜索与回溯算法"],"tags":["算法","数组","数","深度优先搜索"]},{"title":"搜索与回溯算法二","url":"/2022/05/16/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%BA%8C/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>输入两棵二叉树<em>A</em>和<em>B</em>，判断<em>B</em>是不是<em>A</em>的子结构。(约定空树不是任意一个树的子结构)</p>\n<p><em>B</em>是<em>A</em>的子结构， 即 <em>A</em>中有出现和<em>B</em>相同的结构和节点值。</p>\n<p><strong>例如:</strong><br>给定的树 <em>A</em>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"number\">3</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">4</span>   <span class=\"number\">5</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">1</span>   <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>给定的树 <em>B</em>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">4</span> </span><br><span class=\"line\"> /</span><br><span class=\"line\"><span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>返回 <code>true</code>，因为 <em>B</em> 与 <em>A</em> 的一个子树拥有相同的结构和节点值。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：A = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], B = [<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：A = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>], B = [<span class=\"number\">4</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<p><code>0 &lt;= 节点个数 &lt;= 10000</code></p>\n<span id=\"more\"></span>\n\n\n\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路：\"><a href=\"#解题思路：\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h5><p>由题意可知，若树<em>B</em>是树<em>A</em>的子结构，则子结构的根节点可能是树<em>A</em>的任意一个节点。因此需要判断树<em>B</em>是不是树<em>A</em>的子结构，只需要判断树<em>B</em>是否为树<em>A</em>的子节点，通过以下两步完成工作：</p>\n<ol>\n<li>先序遍历树<em>A</em>中每个节点$n_A$;(对应函数<code>isSubStructure(A, B)</code>)</li>\n<li>判断树 <em>A</em>中 <strong>以 $n_A$为根节点的子树</strong> 是否包含树 <em>B</em> 。（对应函数 <code>recur(A, B)</code>）</li>\n</ol>\n<img src=\"/2022/05/16/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%BA%8C/1.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\">\n\n\n\n<h5 id=\"算法流程：\"><a href=\"#算法流程：\" class=\"headerlink\" title=\"算法流程：\"></a>算法流程：</h5><p><strong><code>recur(A, B)</code> 函数：</strong></p>\n<ol>\n<li><strong>终止条件：</strong><ul>\n<li>当节点 <em>B</em> 为空：说明树 <em>B</em> 已匹配完成（越过叶子节点），因此返回 <code>true</code> ；</li>\n<li>当节点 <em>A</em> 为空：说明已经越过树 <em>A</em> 叶子节点，即匹配失败，返回 <code>false</code> ；</li>\n<li>当节点 <em>A</em> 和 <em>B</em>  的值不同：说明匹配失败，返回 <code>false</code> ；</li>\n</ul>\n</li>\n<li><strong>返回值：</strong><ul>\n<li>判断 <em>A</em> 和 <em>B</em>  的左子节点是否相等，即 <code>recur(A.left, B.left)</code> ；</li>\n<li>判断 <em>A</em> 和 <em>B</em>  的右子节点是否相等，即 <code>recur(A.right, B.right)</code> ；</li>\n</ul>\n</li>\n</ol>\n<p><strong><code>isSubStructure(A, B)</code> 函数：</strong></p>\n<ol>\n<li><strong>特例处理：</strong> 当 树 <em>A</em> 为空 或 树 <em>B</em>为空 时，直接返回 <code>false</code> ；</li>\n<li><strong>返回值：</strong> 若树 <em>B</em>是树 <em>A</em>的子结构，则必满足以下三种情况之一，因此用或 <code>||</code> 连接；<ul>\n<li>以 节点 <em>A</em>为根节点的子树 包含树 <em>B</em>，对应 <code>recur(A, B)</code>；</li>\n<li>树 <em>B</em>是 树 <em>A</em>左子树 的子结构，对应 <code>isSubStructure(A.left, B)</code>；</li>\n<li>树 <em>B</em> 是 树 <em>A</em>右子树 的子结构，对应 <code>isSubStructure(A.right, B)</code>；</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSubStructure</span><span class=\"params\">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (A != <span class=\"literal\">null</span> &amp;&amp; B != <span class=\"literal\">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">recur</span><span class=\"params\">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(B == <span class=\"literal\">null</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A == <span class=\"literal\">null</span> || A.val != B.val) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  <span class=\"number\">2</span>   <span class=\"number\">2</span></span><br><span class=\"line\"> / \\ / \\</span><br><span class=\"line\"><span class=\"number\">3</span>  <span class=\"number\">4</span> <span class=\"number\">4</span>  <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">1</span></span><br><span class=\"line\"> / \\</span><br><span class=\"line\"><span class=\"number\">2</span>   <span class=\"number\">2</span></span><br><span class=\"line\"> \\   \\</span><br><span class=\"line\"> <span class=\"number\">3</span>    <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路：-1\"><a href=\"#解题思路：-1\" class=\"headerlink\" title=\"解题思路：\"></a>解题思路：</h5><ul>\n<li><strong>对称二叉树定义：</strong> 对于树中 <strong>任意两个对称节点</strong>  <em>L</em> 和 <em>R</em> ，一定有：<ul>\n<li><code>L.val = R.val</code>：即此两对称节点值相等。</li>\n<li><code>L.left.val = R.right.val</code>：即 <em>L</em>的 左子节点 和 <em>R</em>的 右子节点 对称；</li>\n<li><code>L.right.val = R.left.val</code>：即 <em>L</em>的 右子节点 和 <em>R</em>的 左子节点 对称。</li>\n</ul>\n</li>\n<li>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</li>\n</ul>\n<img src=\"/2022/05/16/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%BA%8C/2.png\" alt=\"Picture1.png\" style=\"zoom:50%;\">\n\n\n\n<h5 id=\"算法流程：-1\"><a href=\"#算法流程：-1\" class=\"headerlink\" title=\"算法流程：\"></a>算法流程：</h5><p><code>isSymmetric(root)</code>：</p>\n<ul>\n<li><strong>特例处理：</strong> 若根节点 <code>root</code> 为空，则直接返回 <code>true</code> 。</li>\n<li><strong>返回值：</strong> 即 <code>recur(root.left, root.right)</code> ;</li>\n</ul>\n<p><code>recur(L, R)</code>：</p>\n<ul>\n<li><strong>终止条件：</strong><ul>\n<li>当 <em>L</em>和 <em>R</em>同时越过叶节点： 此树从顶至底的节点都对称，因此返回<code>true</code> ；</li>\n<li>当 <em>L</em>或 <em>R</em>中只有一个越过叶节点： 此树不对称，因此返回<code>false</code> ；</li>\n<li>当节点 <em>L</em>值 $\\ne$ 节点 <em>R</em>值： 此树不对称，因此返回 <code>false</code>；</li>\n</ul>\n</li>\n<li><strong>递推工作：</strong><ul>\n<li>判断两节点 <code>L.left</code> 和 <code>R.right</code> 是否对称，即 <code>recur(L.left, R.right)</code>；</li>\n<li>判断两节点 <code>L.right</code> 和 <code>R.left</code> 是否对称，即 <code>recur(L.right, R.left)</code>；</li>\n</ul>\n</li>\n<li><strong>返回值：</strong> 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">return</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span>= <span class=\"literal\">null</span> ? <span class=\"literal\">true</span> : recur(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">recur</span><span class=\"params\">(TreeNode L, TreeNode R)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L == <span class=\"literal\">null</span> &amp;&amp; R == <span class=\"literal\">null</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L == <span class=\"literal\">null</span> || R == <span class=\"literal\">null</span> || L.val != R.val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：jyd</p>\n</blockquote>\n","categories":["LeetCode学习","搜索与回溯算法"],"tags":["算法","二叉树","深度优先搜索"]},{"title":"数据库","url":"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><p>数据库结构采用关系型数据库</p>\n<h3 id=\"什么是关系型数据库？\"><a href=\"#什么是关系型数据库？\" class=\"headerlink\" title=\"什么是关系型数据库？\"></a>什么是关系型数据库？</h3><p>​\t\t关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。</p>\n<h4 id=\"关系型数据库设计原则\"><a href=\"#关系型数据库设计原则\" class=\"headerlink\" title=\"关系型数据库设计原则\"></a>关系型数据库设计原则</h4><p>遵循ER模型和三范式</p>\n<p>ER模型：</p>\n<ul>\n<li>E    entity   代表实体的意思      对应到数据库当中的一张表          </li>\n<li>R    relationship 代表关系的意思</li>\n</ul>\n<p>三范式：</p>\n<ul>\n<li>1NF：第一范式。任何一张表都应该有主键，并且每一个字段原子性不可再分.主属性：是唯一属性</li>\n<li>2NF：第二范式。在第一范式之上，所有的非主属性都依赖主属性。（隐含信息，一物一表）</li>\n<li>3NF：第三范式。建立在第二范式的基础上，所有非主键字段直接依赖主键，不能产生传递依赖。</li>\n</ul>\n<span id=\"more\"></span>\n\n\n\n<h5 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h5><p>在SQL SERVER中，对于基本表的约束分为列约束和表约束。</p>\n<ul>\n<li>列约束是对某一个特定列的约束，包含在列定义中，直接跟在该列的其他定义之后，用空格分隔，不必指定列名；</li>\n<li>表约束与列定义相互独立，不包括在列定义中，通常用于对多个列一起进行约束，与列定义用’,’分隔，定义表约束时必须指出要约束的那些列的名称。完整性约束的基本语法格式为：</li>\n</ul>\n<p><strong>[ CONSTRAINT &lt;约束名&gt; ] &lt;约束类型&gt;</strong></p>\n<p><strong>约束类型：</strong></p>\n<ul>\n<li><p>NULL&#x2F;NOT NULL（是否非空）</p>\n</li>\n<li><p>UNIQUE约束（唯一）</p>\n</li>\n<li><p>PRIMARY KEY约束（主键）</p>\n</li>\n<li><p>FOREIGN KEY约束（外键）</p>\n</li>\n<li><p>CHECK约束（检查字段所允许范围）</p>\n</li>\n</ul>\n<p><strong>主键（主属性）</strong></p>\n<p>作用：可以保证数据的实体完整性，如果主属性不完整，实体不会入库。</p>\n<p><strong>外键（起关联作用）</strong></p>\n<p>作用：连接两个表的非主属性。保证参照完整性。</p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/3.png\" alt=\"image-20220706091941299\"></p>\n<h5 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h5><p><strong>索引的分类</strong></p>\n<ol>\n<li>按照索引记录的存放位置可分为聚集索引与非聚集索引</li>\n</ol>\n<ul>\n<li><strong>聚集索引</strong>：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。</li>\n<li><strong>非聚集索引</strong>：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。</li>\n</ul>\n<ol start=\"2\">\n<li>唯一索引的概念<ul>\n<li><strong>唯一索引</strong>表示表中每一个索引值只对应唯一的数据记录，</li>\n<li>这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。</li>\n<li>当表中有被设置为<strong>UNIQUE</strong>的字段时，SQL SERVER会自动建立一个<strong>非聚集的唯一性索引</strong>。</li>\n<li>而当表中有<strong>PRIMARY KEY</strong>的字段时，SQL SERVER会在PRIMARY KEY字段建立<strong>一个聚集索引</strong>。</li>\n</ul>\n</li>\n<li>复合索引的概念<ul>\n<li>复合索引是将两个字段或多个字段组合起来建立的索引，而单独的字段允许有重复的值。</li>\n</ul>\n</li>\n</ol>\n<p><strong>建立索引：</strong></p>\n<ul>\n<li>建立索引的语句是CREATE INDEX，其语法格式为：<br>    CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [次序] [{,&lt;列名&gt;}] [次序]…)</li>\n<li>改变表中的数据（如增加或删除记录）时，索引将自动更新。<br>索引建立后，在查询使用该列时，系统将自动使用索引进行查询。 </li>\n<li>索引数目无限制，但索引越多，更新数据的速度越慢。对于仅用于查询的表可多建索引，对于数据更新频繁的表则应少建索引。</li>\n</ul>\n<p><strong>删除索引：</strong></p>\n<ul>\n<li>建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。</li>\n<li>删除索引的语句是DROP INDEX，其语法格式为：<br>        DROP INDEX 数据表名.索引名</li>\n</ul>\n<p><strong>实体图</strong></p>\n<p>由矩形（实体）、学号（属性）、菱形（关联：使用1与m表示对应关系）</p>\n<p><strong>关键词</strong></p>\n<p>RDBMS：关系型数据库管理系统（如：mysql sqlserver oreacl)</p>\n<p>DBA:数据库管理者</p>\n<p>C&#x2F;S模式：可视化界面通过网络协议（通常为TCP协议）连接server</p>\n<p><strong>数据类型</strong></p>\n<img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/4.png\" alt=\"image-20220706093141235\" style=\"zoom:67%;\">\n\n<img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/5.png\" alt=\"image-20220706093203941\" style=\"zoom:67%;\">\n\n<img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/6.png\" alt=\"image-20220706093224759\" style=\"zoom:67%;\">\n\n<img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/7.png\" alt=\"image-20220706093243616\" style=\"zoom:67%;\">\n\n\n\n<h3 id=\"SQL语言\"><a href=\"#SQL语言\" class=\"headerlink\" title=\"SQL语言\"></a>SQL语言</h3><p>SQL语言支持数据库的三级模式结构。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。 </p>\n<img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/2.png\" alt=\"image-20220705205933811\" style=\"zoom:67%;\">\n\n\n\n<h4 id=\"简单的SQL示例\"><a href=\"#简单的SQL示例\" class=\"headerlink\" title=\"简单的SQL示例\"></a>简单的SQL示例</h4><p>查看数据库：<code>SHOW DATABASES;</code></p>\n<p>使用数据库：<code>USE &lt;数据库名&gt;</code></p>\n<p>创建表： <code>CREATE TABLE &lt;表名&gt;(&lt;列定义&gt;[&#123;，&lt;列定义&gt;|&lt;表约束&gt;&#125;])</code></p>\n<p>查看表结构：<code>DESC &lt;表名&gt;</code></p>\n<h5 id=\"SQL数据查询\"><a href=\"#SQL数据查询\" class=\"headerlink\" title=\"SQL数据查询\"></a>SQL数据查询</h5><p><strong>SELECT命令的格式与基本使用：</strong></p>\n<p><code>SELECT〈列名〉[&#123;，〈列名〉&#125;] FROM〈表名或视图名〉[&#123;，〈表名或视图名〉&#125;] [WHERE〈检索条件〉] [GROUP BY &lt;列名1&gt;[HAVING &lt;条件表达式&gt;]] [ORDER BY &lt;列名2&gt;[ASC|DESC]];</code></p>\n<p><strong>注意</strong></p>\n<ul>\n<li>查询的结果是仍是一个表。</li>\n<li>SELECT语句的执行过程是:<ul>\n<li>根据WHERE子句的检索条件，从FROM子句指定的基本表或视图中选取满足条件的元组，再按照SELECT子句中指定的列，投影得到结果表。</li>\n<li>如果有GROUP子句，则将查询结果按照&lt;列名1&gt;相同的值进行分组。</li>\n<li>如果GROUP子句后有HAVING短语，则只输出满足HAVING条件的元组。</li>\n<li>如果有ORDER子句，查询结果还要按照&lt;列名2&gt;的值进行排序。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h6><p>WHERE中较常用的运算符：</p>\n<img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/8.png\" alt=\"image-20220706095309061\" style=\"zoom:67%;\">\n\n<p>常用库函数：</p>\n<img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/9.png\" alt=\"image-20220706095613087\" style=\"zoom:67%;\">\n\n<h6 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h6><p>GROUP BY子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。</p>\n<p><strong>注意：</strong>当在一个SQL查询中同时使用WHERE子句，GROUP  BY 子句和HAVING子句时，其顺序是WHERE－GROUP  BY－ HAVING。</p>\n<h6 id=\"查询排序\"><a href=\"#查询排序\" class=\"headerlink\" title=\"查询排序\"></a>查询排序</h6><p>当需要对查询结果排序时，应该使用ORDER BY子句<br>ORDER BY子句必须出现在其他子句之后。排序方式可以指定，DESC为降序，ASC为升序，缺省时为升序</p>\n<h6 id=\"数据表链接及连接查询\"><a href=\"#数据表链接及连接查询\" class=\"headerlink\" title=\"数据表链接及连接查询\"></a>数据表链接及连接查询</h6><ul>\n<li>数据表之间的联系是通过表的字段值来体现的，这种字段称为连接字段。</li>\n<li>连接操作的目的就是通过加在连接字段的条件将多个表连接起来，以便从多个表中查询数据。</li>\n<li>前面的查询都是针对一个表进行的，当查询同时涉及两个以上的表时，称为连接查询。</li>\n<li>表的连接方法有两种：<ul>\n<li>方法1：表之间满足一定的条件的行进行连接，此时FROM子句中指明进行连接的表名，WHERE子句指明连接的列名及其连接条件。</li>\n<li>方法2：利用关键字JOIN进行连接。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/23.png\" alt=\"image-20220813105903008\"></p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/24.png\" alt=\"image-20220813105948380\"></p>\n<h6 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h6><ul>\n<li>在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询，包含子查询的语句称为父查询或外部查询。</li>\n<li>嵌套查询可以将一系列简单查询构成复杂查询，增强查询能力。</li>\n<li>子查询的嵌套层次最多可达到255层，以层层嵌套的方式构造查询充分体现了SQL“结构化”的特点。</li>\n<li>嵌套查询在执行时由里向外处理，每个子查询是在上一级外部查询处理之前完成，父查询要用到子查询的结果。</li>\n</ul>\n<h5 id=\"SQL数据更新\"><a href=\"#SQL数据更新\" class=\"headerlink\" title=\"SQL数据更新\"></a>SQL数据更新</h5><p><strong>插入记录：</strong></p>\n<p><code>INSERT INTO &lt;表名&gt;[(&lt;列名1&gt;[,&lt;列名2&gt;…])] VALUES(&lt;值&gt;)</code></p>\n<p><strong>修改记录：</strong></p>\n<p><code>UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;]… [WHERE &lt;条件&gt;]</code></p>\n<p><strong>删除记录：</strong><code>DELETE  FROM&lt;表名&gt; [WHERE &lt;条件&gt;]</code>**</p>\n<h3 id=\"MySQL数据库事务隔离级别\"><a href=\"#MySQL数据库事务隔离级别\" class=\"headerlink\" title=\"MySQL数据库事务隔离级别\"></a>MySQL数据库事务隔离级别</h3><h4 id=\"事务的基本要素（ACID）\"><a href=\"#事务的基本要素（ACID）\" class=\"headerlink\" title=\"事务的基本要素（ACID）\"></a>事务的基本要素（ACID）</h4><ol>\n<li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 </li>\n<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</li>\n<li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 、</li>\n<li>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li>\n</ol>\n<h4 id=\"事务的并发问题\"><a href=\"#事务的并发问题\" class=\"headerlink\" title=\"事务的并发问题\"></a>事务的并发问题</h4><ol>\n<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>\n<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ol>\n<h4 id=\"MySQL事务隔离级别\"><a href=\"#MySQL事务隔离级别\" class=\"headerlink\" title=\"MySQL事务隔离级别\"></a>MySQL事务隔离级别</h4><p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/10.png\" alt=\"image-20220812184716988\"></p>\n<p><strong>&#x3D;&#x3D;mysql默认的事务隔离级别为repeatable-read&#x3D;&#x3D;</strong></p>\n<ul>\n<li><p>事务隔离级别为读提交时，写数据只会锁住相应的行；</p>\n</li>\n<li><p>事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引） 的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会 锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的， 这样可以防止幻读；</p>\n</li>\n<li><p>事务隔离级别为串行化时，读写数据都会锁住整张表；</p>\n</li>\n<li><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的 </p>\n<p>影响也越大。</p>\n</li>\n</ul>\n<h4 id=\"存储过程与触发器\"><a href=\"#存储过程与触发器\" class=\"headerlink\" title=\"存储过程与触发器\"></a>存储过程与触发器</h4><h5 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h5><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。 </p>\n<p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/11.png\" alt=\"image-20220812193656133\"></p>\n<h5 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h5><ol>\n<li>触发器的概念：触发器既是一类由事件驱动的数据库对象，也是一种保证数据完整性的方法。</li>\n<li>触发器的调用：触发器无需用户调用，任何对表的修改操作均由数据库服务器自动激活相应的触发器。</li>\n<li>触发器的作用：实现主键和外键不能保证的参照关系性和数据一致性，从而保护表中数据。</li>\n<li>触发器和存储过程的区别：<ul>\n<li>触发器主要时通过事件进行触发而被执行的</li>\n<li>存储过程可以通过存储过程名字而被直接调用</li>\n</ul>\n</li>\n</ol>\n<p><strong>SQL的级联操作可以使用触发器</strong></p>\n<h4 id=\"MySQL锁机制\"><a href=\"#MySQL锁机制\" class=\"headerlink\" title=\"MySQL锁机制\"></a>MySQL锁机制</h4><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/12.png\" alt=\"image-20220812194255606\" style=\"zoom:150%;\">\n\n<p>其中：</p>\n<ul>\n<li>MyISAM和MEMORY存储引擎采用的是表级锁；</li>\n<li>BDB存储引擎采用的是页面锁，但也支持表级锁；</li>\n<li>InnoDB存储引擎既支持行级锁，也支持表级锁；</li>\n<li>但默认情况下采用行级锁。</li>\n</ul>\n<p>锁分类：</p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/13.png\" alt=\"image-20220812194851968\"></p>\n<h3 id=\"MySQL索引机制\"><a href=\"#MySQL索引机制\" class=\"headerlink\" title=\"MySQL索引机制\"></a>MySQL索引机制</h3><h4 id=\"索引的语法\"><a href=\"#索引的语法\" class=\"headerlink\" title=\"索引的语法\"></a>索引的语法</h4><h5 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h5><p>在创建表时添加索引</p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/14.png\" alt=\"image-20220812195517919\"></p>\n<p>在创建表以后添加索引</p>\n<p>其sql格式是 <code>CREATE INDEX IndexName ON TableName</code>(字段名(length)) 或者 <code>ALTER TABLE TableName ADD INDEX IndexName</code>(字段名(length))</p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/15.png\" alt=\"image-20220812195617155\"></p>\n<ul>\n<li><strong>建立索引需要占用&#x3D;&#x3D;磁盘空间&#x3D;&#x3D;，因此在创建索引时需要考虑磁盘空间是否足够。</strong></li>\n<li><strong>创建索引时需要&#x3D;&#x3D;对表加锁&#x3D;&#x3D;，因此在实际操作中需要在业务空闲期间进行。</strong></li>\n</ul>\n<h5 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h5><p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/16.png\" alt=\"image-20220812200400007\"></p>\n<h5 id=\"查看表中的索引\"><a href=\"#查看表中的索引\" class=\"headerlink\" title=\"查看表中的索引\"></a>查看表中的索引</h5><p><code>SHOW INDEX FROM tablename</code></p>\n<h4 id=\"索引的优缺点与分类\"><a href=\"#索引的优缺点与分类\" class=\"headerlink\" title=\"索引的优缺点与分类\"></a>索引的优缺点与分类</h4><h5 id=\"优缺点：\"><a href=\"#优缺点：\" class=\"headerlink\" title=\"优缺点：\"></a>优缺点：</h5><ul>\n<li>优势：可以快速检索，减少&#x2F;O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序：</li>\n<li>劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍：索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</li>\n</ul>\n<h5 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类;\"></a>分类;</h5><p>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引。</p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/17.png\" alt=\"image-20220812201654842\"></p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/18.png\" alt=\"image-20220812201733990\"></p>\n<h4 id=\"索引的实现原理\"><a href=\"#索引的实现原理\" class=\"headerlink\" title=\"索引的实现原理\"></a>索引的实现原理</h4><p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/19.png\" alt=\"image-20220812201905981\"></p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/20.png\" alt=\"image-20220812202733981\"></p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/21.png\" alt=\"image-20220812202759088\"></p>\n<p><img src=\"/2022/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93/22.png\" alt=\"image-20220812202815181\"></p>\n<h5 id=\"索引的失效\"><a href=\"#索引的失效\" class=\"headerlink\" title=\"索引的失效\"></a>索引的失效</h5><ul>\n<li>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了；</li>\n<li>LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是’aaa%’可以使用索引；</li>\n<li>在查询条件中使用不等于，包括&lt;符号、&gt;符号和！&#x3D;会导致索引失效。特别的是如果对主键索引使用！&#x3D;则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效；</li>\n<li>在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效；</li>\n<li>字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段mai是字符串类型的，使用WHERE emaila&#x3D;99999则会导致失败，应该改为VHERE email&#x3D;’99999’。</li>\n</ul>\n","categories":["Java学习","数据库"],"tags":["数据库","知识点"]},{"title":"查找算法","url":"/2022/05/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>在一个 <code>n * m</code> 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<p><strong>示例:</strong></p>\n<p>现有矩阵 <code>matrix</code> 如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">1</span>,   <span class=\"number\">4</span>,  <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,   <span class=\"number\">5</span>,  <span class=\"number\">8</span>, <span class=\"number\">12</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>,   <span class=\"number\">6</span>,  <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">  [<span class=\"number\">10</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">17</span>, <span class=\"number\">24</span>],</span><br><span class=\"line\">  [<span class=\"number\">18</span>, <span class=\"number\">21</span>, <span class=\"number\">23</span>, <span class=\"number\">26</span>, <span class=\"number\">30</span>]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n<p>给定 <code>target = 5</code>，返回 <code>true</code>。</p>\n<p>给定 <code>target = 20</code>，返回 <code>false</code>。</p>\n<p><strong>限制：</strong></p>\n<p><code>0 &lt;= n &lt;= 1000</code></p>\n<p><code>0 &lt;= m &lt;= 1000</code></p>\n<span id=\"more\"></span>\n\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路一：暴力\"><a href=\"#解题思路一：暴力\" class=\"headerlink\" title=\"解题思路一：暴力\"></a>解题思路一：暴力</h5><p>如果不考虑二维数组排好序的特点，则直接遍历整个二维数组的每一个元素，判断目标值是否在二维数组中存在。</p>\n<p>依次遍历二维数组的每一行和每一列。如果找到一个元素等于目标值，则返回 true。如果遍历完毕仍未找到等于目标值的元素，则返回 false。<strong>（不推荐）</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">findNumberIn2DArray</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"literal\">null</span> || matrix.length == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rows</span> <span class=\"operator\">=</span> matrix.length, columns = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; rows; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == target) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"解题思路二：二分查找\"><a href=\"#解题思路二：二分查找\" class=\"headerlink\" title=\"解题思路二：二分查找\"></a>解题思路二：二分查找</h5><p>由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>\n<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 <code>true</code>。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p>\n<p>可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。</p>\n<ul>\n<li><p>若数组为空，返回 <code>false</code></p>\n</li>\n<li><p>初始化行下标为 <code>0</code>，列下标为二维数组的列数减<code> 1</code></p>\n<ul>\n<li>重复下列步骤，直到行下标或列下标超出边界</li>\n<li>获得当前下标位置的元素 <code>num</code></li>\n<li>如果 <code>num</code> 和 <code>target </code>相等，返回 <code>true</code></li>\n<li>如果 <code>num</code> 大于 <code>target</code>，列下标减 <code>1</code></li>\n<li>如果 <code>num</code> 小于 <code>target</code>，行下标加 <code>1</code></li>\n</ul>\n</li>\n<li><p>循环体执行完毕仍未找到元素等于 <code>target</code> ，说明不存在这样的元素，返回 <code>false</code>。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">findNumberIn2DArray</span><span class=\"params\">(<span class=\"type\">int</span>[][] matrix, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"literal\">null</span> || matrix.length == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">long1</span> <span class=\"operator\">=</span> matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">high1</span> <span class=\"operator\">=</span> matrix.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">long2</span> <span class=\"operator\">=</span> long1 - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">high2</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(high2 &lt; high1 &amp;&amp; long2 &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[high2][long2] == target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(matrix[high2][long2] &lt; target)&#123;</span><br><span class=\"line\">                high2++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                long2--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>\n<p>给你一个可能存在 重复 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 <code>1</code>。  </p>\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：numbers = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">输出：<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：numbers = [<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">输出：<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == numbers.length</code></li>\n<li><code>1 &lt;= n &lt;= 5000</code></li>\n<li><code>-5000 &lt;= numbers[i] &lt;= 5000</code></li>\n<li><code>numbers</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路：二分查找\"><a href=\"#解题思路：二分查找\" class=\"headerlink\" title=\"解题思路：二分查找\"></a>解题思路：二分查找</h5><p>一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p>\n<img src=\"/2022/05/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.png\" alt=\"fig1\">\n\n<p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标。</p>\n<p>我们考虑数组中的最后一个元素 <code>x</code>：在最小值右侧的元素，它们的值一定都小于等于 <code>x</code>；而在最小值左侧的元素，它们的值一定都大于等于 <code>x</code>。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p>\n<p>在二分查找的每一步中，左边界为 <code>low</code>，右边界为 <code>high</code>，区间的中点为 <code>pivot</code>，最小值就在该区间内。我们将中轴元素 <code>numbers[pivot]</code> 与右边界元素 <code>numbers[high]</code> 进行比较，可能会有以下的三种情况：</p>\n<p>第一种情况是 <code>numbers[pivot]&lt;numbers[high]</code>。如下图所示，这说明 <code>numbers[pivot]</code> 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。</p>\n<img src=\"/2022/05/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.png\" alt=\"fig2\">\n\n<p>第二种情况是<code>numbers[pivot]&gt;numbers[high]</code>。如下图所示，这说明 <code>numbers[pivot]</code>是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。</p>\n<p><img src=\"/2022/05/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/3.png\" alt=\"fig3\"></p>\n<p>第三种情况是 <code>numbers[pivot]==numbers[high]</code>。如下图所示，由于重复元素的存在，我们并不能确定<code>numbers[pivot]</code> 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 <code>numbers[high]</code> 是不是最小值，都有一个它的「替代品」<code>numbers[pivot]</code>，因此我们可以忽略二分查找区间的右端点。</p>\n<p><img src=\"/2022/05/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/4.png\" alt=\"fig4\"></p>\n<p>当二分查找结束时，我们就得到了最小值所在的位置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minArray</span><span class=\"params\">(<span class=\"type\">int</span>[] numbers)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> numbers.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start &lt; end)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> start + (end - start) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(numbers[mid] &gt; numbers[end])&#123;</span><br><span class=\"line\">                start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[mid] &lt; numbers[end])&#123;</span><br><span class=\"line\">                end = mid;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                end--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[start];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：LeetCode-Solution</p>\n</blockquote>\n","categories":["LeetCode学习","查找算法"],"tags":["算法","数组","二分查找"]},{"title":"栈与队列","url":"/2022/05/04/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[<span class=\"string\">&quot;CQueue&quot;</span>,<span class=\"string\">&quot;appendTail&quot;</span>,<span class=\"string\">&quot;deleteHead&quot;</span>,<span class=\"string\">&quot;deleteHead&quot;</span>]</span><br><span class=\"line\">[[],[<span class=\"number\">3</span>],[],[]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>,-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[<span class=\"string\">&quot;CQueue&quot;</span>,<span class=\"string\">&quot;deleteHead&quot;</span>,<span class=\"string\">&quot;appendTail&quot;</span>,<span class=\"string\">&quot;appendTail&quot;</span>,<span class=\"string\">&quot;deleteHead&quot;</span>,<span class=\"string\">&quot;deleteHead&quot;</span>]</span><br><span class=\"line\">[[],[],[<span class=\"number\">5</span>],[<span class=\"number\">2</span>],[],[]]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[<span class=\"literal\">null</span>,-<span class=\"number\">1</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= values &lt;= 10000</code></li>\n<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>\n</ul>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><ul>\n<li><strong>栈无法实现队列功能:</strong>\t栈为先进后出，队列为先进先出</li>\n<li><strong>双栈可实现列表倒叙:</strong>    用栈B元素实现对栈A的倒叙</li>\n<li><strong>利用栈B删除队首元素</strong>    B出栈相当于删除栈A的栈底元素，及队列首元素</li>\n</ul>\n<h5 id=\"函数设计\"><a href=\"#函数设计\" class=\"headerlink\" title=\"函数设计\"></a>函数设计</h5><ul>\n<li><strong>加入队首<code>appendTail()</code>函数：</strong>将数字val加入栈<code>A</code>即可。</li>\n<li>**删除队尾<code>deleteHead()</code>:**分几种情况。<ol>\n<li><strong>当栈B不为空：</strong>B中仍有已完成倒叙的元素，因此只需要返回B中的栈顶元素即可。</li>\n<li><strong>否则，当A为空时：</strong>当两个栈都为空时，无元素，返回-1。</li>\n<li><strong>否则：</strong>将栈A所有元素转移到栈B中，实现元素倒叙，并返回栈B元素的栈顶元素。</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CQueue</span> &#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; in,out;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        in = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        out = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">appendTail</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        in.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">deleteHead</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当out栈不为空时，返回栈顶元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!out.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> out.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当in栈为空时，返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当out栈为空时，将in栈中元素转到out栈中</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!in.isEmpty())&#123;</span><br><span class=\"line\">            out.push(in.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MinStack</span> <span class=\"variable\">minStack</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MinStack</span>();</span><br><span class=\"line\">minStack.push(-<span class=\"number\">2</span>);</span><br><span class=\"line\">minStack.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">minStack.push(-<span class=\"number\">3</span>);</span><br><span class=\"line\">minStack.min();   --&gt; 返回 -<span class=\"number\">3.</span></span><br><span class=\"line\">minStack.pop();</span><br><span class=\"line\">minStack.top();      --&gt; 返回 <span class=\"number\">0.</span></span><br><span class=\"line\">minStack.min();   --&gt; 返回 -<span class=\"number\">2.</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>各函数的调用总次数不超过 20000 次</p>\n<h4 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>对于栈来说，如果一个元素 <code>a</code> 在入栈时，栈里有其它的元素 <code>b, c, d</code>，那么无论这个栈在之后经历了什么操作，只要 <code>a</code> 在栈中，<code>b, c, d</code> 就一定在栈中，因为在 <code>a</code> 被弹出之前，b, c, d 不会被弹出。</p>\n<p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 <code>a, b, c, d</code>。</p>\n<p>那么，我们可以在每个元素 <code>a</code> 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 <code>a</code>，我们就可以直接返回存储的最小值 <code>m</code>。</p>\n<h5 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h5><p>按照上面的思路，我们只需要设计一个数据结构，使得每个元素<code>a</code>与其相应的最小值 <code>m</code> 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p>\n<ul>\n<li><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p>\n</li>\n<li><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p>\n</li>\n<li><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p>\n</li>\n</ul>\n<h5 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MinStack</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Stack&lt;Integer&gt; A,B;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MinStack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        A = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        B = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        A.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(B.empty() || B.peek() &gt;= x)&#123;</span><br><span class=\"line\">            B.push(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A.pop().equals(B.peek()))&#123;</span><br><span class=\"line\">            B.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">top</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">min</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> B.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：LeetCode-Solution</p>\n</blockquote>\n","categories":["LeetCode学习","栈"],"tags":["算法","栈与队列"]},{"title":"类的学习","url":"/2022/06/26/%E7%B1%BB/","content":"<h3 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h3><p><strong>什么是面向过程</strong></p>\n<p>面向过程（Procedure-Oriented Programming，简称POP）是一种编程模型，由一系列要执行的计算步骤组成，通常采用自上而下、顺序执行的方式。</p>\n<p><strong>什么是面向对象</strong></p>\n<p>面向对象编程（Object-oriented programming，简写：OOP）是一种计算机编程模型，它围绕数据或对象而不是功能和逻辑来组织软件设计，更专注于对象与对象之间的交互，对象涉及的方法和属性都在对象内部。说的更底层一点就是面向对象是一种依赖于类和对象概念的编程方式。</p>\n<p><strong>面向对象和面向过程的区别</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>面向过程</th>\n<th>面向对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>侧重点</td>\n<td>功能的实现步骤和因果关系</td>\n<td>对象之间的组合关系</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td><strong>耦合度高、扩展力低</strong></td>\n<td><strong>耦合度低、扩展力高</strong></td>\n</tr>\n<tr>\n<td>优点</td>\n<td>快速开发</td>\n<td>需要对象提取和模型建立</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n\n\n<h4 id=\"面向对象的三大特性\"><a href=\"#面向对象的三大特性\" class=\"headerlink\" title=\"面向对象的三大特性\"></a>面向对象的三大特性</h4><p><strong>封装</strong></p>\n<p>封装是面向对象方法的核心思想之一。它有两个含义：</p>\n<ul>\n<li>一是指把对象的属性和行为看成为一个密不可分的整体，将这两者“<strong>封装</strong>”在一个不可分割的独立单位（即对象）中。</li>\n<li>另一层含义指“<strong>信息隐蔽</strong>”，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，而另一些属性或行为，则不允许外界知晓；或只允许使用对象的功能，而尽可能隐蔽对象的功能实现细节。</li>\n</ul>\n<p><strong>继承</strong></p>\n<p>子类可以继承父类的属性（数据）和功能（操作）。继承是面向对象方法中的重要概念，并且是提高软件开发效率的重要手段。</p>\n<p><strong>多态</strong></p>\n<ul>\n<li>多态:编译时是一种形态,运行时是另一种形态。</li>\n<li>多态是指父类型引用指向子类型对象，包括编译阶段和运行阶段。</li>\n<li>多态的作用:解耦合</li>\n<li>OCP原则:对扩展开放，对修改关闭</li>\n</ul>\n<p>程序中允许出现重名现象。 Java 语言中具有操作名称的多态和继承有关的多态。</p>\n<p><strong>类的四大特性：</strong>封装性，继承性，多态性，抽象性。</p>\n<h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><p>类是java程序设计的基本单位，java的源文件有若干个书写形式相互独立的类构成。</p>\n<p>类的两个基本成员：</p>\n<ul>\n<li>成员变量（属性）</li>\n<li>成员方法（函数功能）</li>\n</ul>\n<p><strong>类的声明</strong></p>\n<p><strong>修饰符 class 类名{</strong></p>\n<p>​\t\t<strong>类体的内容</strong></p>\n<p><strong>}</strong></p>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><p>抽象类的概述：抽象类是指一种将<strong>类与类之间的共同特征</strong>提取出来的类</p>\n<p>抽象类的实例化问题：</p>\n<ul>\n<li>抽象类无法实例化</li>\n<li>抽象类具有构造方法,子类通过关键字super调用父类构造方法用于初始化当前对象的父类特征</li>\n<li>非抽象子类继承抽象类,子类可以实例化</li>\n</ul>\n<p>抽象方法：</p>\n<ol>\n<li>抽象方法是指没有实现的方法,即没有方法体的方法</li>\n<li>抽象方法的作用[确保特定服务的提供]<ul>\n<li>所有类都期望提供某种特定服务,但是方法的实现方式会根据类的不同而不同。</li>\n<li>父类定义抽象方法强制所有子类实现,以此确保所有子类都能够提供特定服务。</li>\n</ul>\n</li>\n<li>语法机制<ul>\n<li>[修饰符列表] abstract [返回值类型] 方法名();</li>\n</ul>\n</li>\n<li>特点<ul>\n<li>抽象方法没有大括号,以分号结尾</li>\n<li>修饰符列表中有abstract关键字</li>\n<li>抽象类中不一定具有抽象方法</li>\n<li>抽象方法只会出现在抽象类或者接口中</li>\n<li>非抽象子类继承抽象类,子类必须实现抽象方法</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><p>接口的概述</p>\n<ul>\n<li>接口是指类与类之间的所有行为动作的抽象集合</li>\n<li>接口属于特殊的抽象类[抽象类是半抽象的,而接口是完全抽象的]</li>\n</ul>\n<p>接口的作用**[解耦合]**</p>\n<ul>\n<li><p>面向接口编程的优点:降低耦合度,提高扩展力</p>\n</li>\n<li><p>接口和多态机制联合使用可以达到降低程序耦合度的效果</p>\n</li>\n<li><p>接口可以将调用者和实现者解耦合</p>\n<ul>\n<li>调用者面向接口调用</li>\n<li>实现者面向接口实现</li>\n</ul>\n</li>\n<li><p>接口今典面试题</p>\n<ul>\n<li><p>接口与抽象类的区别？<br>（1）修饰符<br>抽象类是用abstract class声明的，接口使用interface 声明的<br>（2）成员不同<br>  抽象类可以拥有非常量的属性、构造器、非抽象的普通方法、代码块等<br> 接口中只能有常量，抽象方法，内部接口，JDK1.8之后增加静态方法和默认方法。<br>（3）使用不同<br>抽象类：用来被继承的，有单继承的限制<br>​    接口：用来被实现的，一个类可以同时实现多个接口，接口还可以继承多个接口。</p>\n</li>\n<li><p>接口与抽象类的相同点？<br>（1）不能实例化<br>（2）它俩都可以有抽象方法<br>（3）使用时都是与子类或实现类的对象之间构成多态引用</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h4><p>要访问内部类，可以通过创建外部类的对象，然后创建内部类的对象来实现。</p>\n<p>嵌套类有两种类型：</p>\n<ul>\n<li>非静态内部类</li>\n<li>静态内部类</li>\n</ul>\n<h5 id=\"非静态内部类\"><a href=\"#非静态内部类\" class=\"headerlink\" title=\"非静态内部类\"></a>非静态内部类</h5><p>非静态内部类是一个类中嵌套着另外一个类。 它有访问外部类成员的权限， 通常被称为内部类。</p>\n<p>由于内部类嵌套在外部类中，因此必须首先实例化外部类，然后创建内部类的对象来实现。</p>\n<p><strong>私有的内部类</strong></p>\n<p>内部类可以使用 private 或 protected 来修饰，如果你不希望内部类被外部类访问可以使用 private 修饰符：</p>\n<h5 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h5><p>静态内部类可以使用 static 关键字定义，静态内部类我们不需要创建外部类来访问，可以直接访问它</p>\n<h4 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h4><p>关键字：在Java中被赋予特定含义的单词。</p>\n<ul>\n<li><p>基本数据类型相关（8个）：byte、short、int、long、float、double、char、boolea</p>\n</li>\n<li><p>流程控制语句相关（10个）：if、else、for、while、do、switch、case、break、continue</p>\n</li>\n<li><p>判断某个对象是否是某个类型的实例对象运算符：instanceof</p>\n</li>\n<li><p>定义类：class</p>\n</li>\n<li><p>创建类的对象：new</p>\n</li>\n<li><p>包：package、import</p>\n</li>\n<li><p>权限修饰符：publick（最大权限）、protected（仅限暴以内使用）、private（仅限类以内使用）、（缺省）</p>\n</li>\n<li><p>继承类：extends</p>\n</li>\n<li><p>定义接口：interface</p>\n</li>\n<li><p>实现接口：implements</p>\n</li>\n<li><p>当前对象：this</p>\n</li>\n<li><p>父类引用：super</p>\n</li>\n<li><p>返回值类型：基础数据类型、void</p>\n</li>\n<li><p>结束方法：return</p>\n</li>\n<li><p>定义枚举：enum</p>\n</li>\n<li><p>定义其他修饰符：sbstract、static、final、native</p>\n</li>\n<li><p>异常处理：throws、throw、try、catch、finally</p>\n</li>\n<li><p>多线程同步安全：synchronized、volatile</p>\n</li>\n<li><p>IO序列化相关：transient</p>\n</li>\n<li><p>单元测试相关：assert</p>\n</li>\n<li><p>保留字：goto、const</p>\n</li>\n<li><p>特殊值：true、false、null</p>\n</li>\n<li><p>其他：strictdp（strictfp 关键字可应用于类、接口或方法。如果你想让你的浮点运算更加精确，严格遵守FP-strict的限制,符合IEEE-754规范，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.</p>\n<p>）</p>\n</li>\n</ul>\n<p><strong>final：常量修饰符</strong></p>\n<p>如果一个成员变量修饰为final，就是常量，常量的名字习惯用大写字母</p>\n<p><strong>可修饰的对象：</strong></p>\n<ul>\n<li>属性：修饰属性后，属性为常量，只能赋值一次</li>\n<li>方法：修饰方法后，方法不能被重写</li>\n<li>类：修饰类后，类不能被继承</li>\n</ul>\n<p><strong>static：静态修饰符</strong></p>\n<p>方法声明中用关键字static修饰的称作类方法或静态方法，不用static修饰的</p>\n<p>称作实例方法。</p>\n<p><strong>可修饰的对象</strong></p>\n<ul>\n<li>属性：修饰属性后，属性为静态变量（也叫类变量），可以用对象调用，也可以用类调用；</li>\n<li>方法：修饰方法后，方法为静态函数，只能调用静态变量，不能使用this调用；</li>\n<li>代码块：修饰代码块后，为静态代码块，在类加载的时候执行；</li>\n<li>内部类：修饰内部类，内部类为静态内部类，可以使用<ul>\n<li>静态内部类与普通内部类的区别在于，静态内部类的对象是不指向与某个具体的外部类对象，所以在创建对象时不需要创建外部类对象。并且在new的时候是通过 new Parent.Inner()方式，而不是Parent.new Inner()。不要和内部类的实例化搞混了。class的声明和内部类是一样的，都是Parent.Inner</li>\n</ul>\n</li>\n</ul>\n<p><strong>一个类中的方法可以互相调用：实例方法可以调用该类中实例方法或类方法；类方法只能调用该类的类方法，不能调用实例方法；</strong></p>\n<p>如：main函数为静态函数，只能调用静态函数。</p>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><ul>\n<li>基本数据类型<br>byte（1个字节、-128~127）、short（2个字节）、int（4个字节）、long（8个字节）、float（4个字节）、double（8个字节）、char（2个字节）、boolean（只有两个值：true、false）</li>\n<li>引用数据类型<br>类、接口、数组、枚举…<br>string属于类，引用数据类型</li>\n<li>数据类型转换<br>byte，short、char–&gt;int–&gt;long–&gt;float–&gt;double（自动转换）<br>double–&gt;float–&gt;long–&gt;int–&gt;char、short、byte（强制转换）</li>\n</ul>\n<h4 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h4><p>运算符的优先级（从高到低）</p>\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>描述</th>\n<th>运算符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>括号</td>\n<td>()  []</td>\n</tr>\n<tr>\n<td>2</td>\n<td>正负号</td>\n<td>+  -</td>\n</tr>\n<tr>\n<td>3</td>\n<td>自增自减</td>\n<td>++  –  ！</td>\n</tr>\n<tr>\n<td>4</td>\n<td>乘除，取余</td>\n<td>*  &#x2F;  %</td>\n</tr>\n<tr>\n<td>5</td>\n<td>加减</td>\n<td>+  -</td>\n</tr>\n<tr>\n<td>6</td>\n<td>位移运算</td>\n<td>&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;</td>\n</tr>\n<tr>\n<td>7</td>\n<td>大小关系</td>\n<td>&lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;</td>\n</tr>\n<tr>\n<td>8</td>\n<td>相等关系</td>\n<td>&#x3D;&#x3D;  !&#x3D;</td>\n</tr>\n<tr>\n<td>9</td>\n<td>按位与</td>\n<td>&amp;</td>\n</tr>\n<tr>\n<td>10</td>\n<td>按位异或</td>\n<td>^</td>\n</tr>\n<tr>\n<td>11</td>\n<td>按位或</td>\n<td>|</td>\n</tr>\n<tr>\n<td>12</td>\n<td>逻辑与</td>\n<td>&amp;&amp;</td>\n</tr>\n<tr>\n<td>13</td>\n<td>逻辑或</td>\n<td>||</td>\n</tr>\n<tr>\n<td>14</td>\n<td>条件运算</td>\n<td>?:</td>\n</tr>\n<tr>\n<td>15</td>\n<td>赋值运算</td>\n<td>&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D;</td>\n</tr>\n<tr>\n<td>16</td>\n<td>位赋值运算</td>\n<td>&amp;&#x3D;  |&#x3D;  &lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &gt;&gt;&gt;&#x3D;</td>\n</tr>\n</tbody></table>\n","categories":["Java学习","Java基础"],"tags":["类","面向对象"]},{"title":"类加载与反射","url":"/2022/07/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/","content":"<h1 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h1><p>​\t\t不管Java程序有多么复杂、该程序启动了多少个线程，它们都处于该Java虚拟机进程里。同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。当系统出现以下几种情况时，JVM进程将被终止：</p>\n<ul>\n<li><p>程序运行到最后正常结束。</p>\n</li>\n<li><p>程序运行到使用System.exit()或Runtime.getRuntime().exit()代码结束程</p>\n</li>\n</ul>\n<p>序。</p>\n<ul>\n<li><p>程序执行过程中遇到未捕获的异常或错误而结束。</p>\n</li>\n<li><p>程序所在平台强制结束了JVM进程。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"类的加载过程\"><a href=\"#类的加载过程\" class=\"headerlink\" title=\"类的加载过程\"></a>类的加载过程</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过<strong>加载、连接、初始化</strong>三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。</p>\n<h4 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h4><p>类的加载主要的职责为将.class文件的二进制字节流读入内存(JDK1.7及之前为JVM内存，JDK1.8及之后为本地内存)，并在堆内存中为之创建Class对象，作为.class进入内存后的数据的访问入口。在这里只是读入二进制字节流，后续的验证阶段就是要拿二进制字节流来验证.class文件，验证通过，才会将.class文件转为运行时数据结构</p>\n<img src=\"/2022/07/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/../../编程学习/博客内容/image/1.png\" alt=\"image-20220708204706434\" style=\"zoom: 80%;\">\n\n<p><strong>注解：</strong></p>\n<ul>\n<li>方法区：方法区用来存储被虚拟机类加载器加载的类的信息、常量、静态变量、编译后的字节码等数据。(JDK1.8取消方法区原因：方法区存储类的元数据信息，我们不清楚一个程序到底有多少类需要被加载，且方法区位于JVM内存，我们不清楚需要给方法区分配多大内存，太小容易PermGen OOM，太大，在触发Full GC时又极其影响性能，同时还存在一些内存泄露的问题)</li>\n</ul>\n<p>​\t\t\t                                            <img src=\"/2022/07/08/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/2.png\" alt=\"img\" style=\"zoom:80%;\"></p>\n<ul>\n<li>堆：堆主要是用来存放java对象的，栈主要是用来存放对象引用的。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。</li>\n<li>栈：存放的是基本数据类型和堆中对象的引用。</li>\n<li>PC寄存器：pc寄存器是用来存储指向下一条要执行指令的地址，即下一条要执行的代码，由执行引擎来读取下一条指令。（<strong>如果是native方法，不放入程序计数器</strong>）</li>\n<li>本地方法栈：本地方法栈英文全称 Native Method Stack 是存放本地方法的地方。(本地方法由native修饰，由c或c++编写)</li>\n</ul>\n<h4 id=\"类的连接\"><a href=\"#类的连接\" class=\"headerlink\" title=\"类的连接\"></a>类的连接</h4><p>​\t\t类的连接分为三个阶段：验证、准备、解析。：</p>\n<ul>\n<li>验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。</li>\n<li>准备：类准备阶段则负责为类的静态属性分配内存，并设置默认初始值。</li>\n<li>解析：将类的二进制数据中的符号引用替换成直接引用。</li>\n</ul>\n<p><strong>其中静态代码块在准备阶段执行，而不是类的初始化时执行。</strong></p>\n<h4 id=\"类的初始化\"><a href=\"#类的初始化\" class=\"headerlink\" title=\"类的初始化\"></a>类的初始化</h4><p>​\t\t在类的初始化阶段，虚拟机负责对类进行初始化；类初始化阶段是类加载过程的最后一步，是执行类构造器 <code>&lt;clinit&gt;() </code>方法的过程。</p>\n<ol>\n<li>类<strong>什么时候</strong>才被初始化 <ul>\n<li>创建类的实例，也就是new一个对象 </li>\n<li>访问某个类或接口的静态变量，或者对该静态变量赋值 </li>\n<li>调用类的静态方法 </li>\n<li>反射（Class.forName(“com.lyj.load”)） </li>\n<li>初始化一个类的子类（会首先初始化子类的父类） </li>\n<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>\n</ul>\n</li>\n<li>类的初始化顺序 <ul>\n<li>如果这个类还没有被加载和链接，那先进行加载和链接 </li>\n<li>假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） </li>\n<li>加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 </li>\n<li>总的来说，初始化顺序依次是：（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器</li>\n<li><strong>如果有父类，则顺序是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法</strong></li>\n</ul>\n</li>\n</ol>\n<p><strong>难点</strong></p>\n<p><strong>静态属性进行初始化</strong>。在Java类中对静态属性指定初始值有两种方式：</p>\n<ul>\n<li>声明静态属性时指定初始值；</li>\n<li>使用静态初始化块为静态属性指定初始值。</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<ul>\n<li>假如这个类还没有被加载和连接，程序先加载并连接该类。</li>\n<li>假如该类的直接父类还没有被初始化，则先初始化其直接父<br>类。</li>\n<li>假如类中有初始化语句，则系统依次执行这些初始化语句。</li>\n</ul>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><ul>\n<li><p>类加载器负责将.class文件（可能在磁盘上，也可能在网络上）加载到内存中，并为之生成对应的java.lang.Class对象。</p>\n</li>\n<li><p>当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构：</p>\n<ul>\n<li><p>Bootstrap ClassLoader：根类加载器：</p>\n<p>负责加载<code>$JAVA_HOME中jre/lib/rt.jar</code>里所有的class，加载System.getProperty(“sun.boot.class.path”)所指定的路径或jar。 </p>\n</li>\n<li><p>Extension ClassLoader：扩展类加载器：</p>\n<p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre&#x2F;lib&#x2F;*.jar或-Djava.ext.dirs指定目录下的jar包。载System.getProperty(“java.ext.dirs”)所指定的路径或jar。</p>\n</li>\n<li><p>System ClassLoader：系统类加载器：</p>\n<p>负责记载classpath中指定的jar包及目录中class </p>\n</li>\n<li><p>CustomClassLoader：自定义加载器</p>\n</li>\n</ul>\n</li>\n<li><p>类加载器的顺序 </p>\n<ul>\n<li>加载过程中会先检查类是否被已加载，<strong>检查顺序是自底向上</strong>，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而<strong>加载的顺序是自顶向下</strong>，也就是由上层来逐层尝试加载此类。 </li>\n<li>在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。</li>\n<li>Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null。</li>\n</ul>\n</li>\n<li><p>类的加载机制</p>\n<ul>\n<li>父类委托（类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载）</li>\n<li>全盘加载（这个类所有依赖均有该加载器加载）</li>\n<li>缓存（已加载的类存入缓存【方法区】，不用二次加载）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h1><p>​\t\t在 Java 运行时环境中，对于任意一个类，任意一个对象。可以通过反射机制，动态获取动态获取类的信息，以及动态调用对象的方法。</p>\n<h3 id=\"反射机制的概述\"><a href=\"#反射机制的概述\" class=\"headerlink\" title=\"反射机制的概述\"></a>反射机制的概述</h3><ol>\n<li><p>反射是指间接操作目标对象</p>\n</li>\n<li><p>反射机制的作用:通过反射机制操作(读&#x2F;写)字节码文件</p>\n</li>\n<li><p>反射机制的优缺点</p>\n<ul>\n<li>优点：反射机制可以增加程序的灵活性[在不改变程序的基础上在运行阶段实例化不同类型的对象]</li>\n<li>缺点：反射机制可以打破封装从而访问类的私有属性</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"通过反射获取Class对象\"><a href=\"#通过反射获取Class对象\" class=\"headerlink\" title=\"通过反射获取Class对象\"></a>通过反射获取Class对象</h3><ul>\n<li>使用Class类的forName()静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名（必须添加完整包名）。</li>\n<li>调用某个类的class属性来获取该类对应的Class对象。例Person.class将会返回Person类对应的Class对象。</li>\n<li>调用某个对象的getClass()方法，该方法是java.lang.Object类中的一个方法，所以所有Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。</li>\n<li>调用基本类型包装类的TYPE方法，该方法可以获得基本类型包装类的Class对象。</li>\n</ul>\n<h3 id=\"从Class中获取信息\"><a href=\"#从Class中获取信息\" class=\"headerlink\" title=\"从Class中获取信息\"></a>从Class中获取信息</h3><ul>\n<li><p>获取构造器 </p>\n</li>\n<li><p>访问Class对应的类所包含的方法</p>\n</li>\n<li><p>访问Class对应的类所包含的属性（Field）  访问Class对应的类上所包含的注释。</p>\n</li>\n<li><p>访问该Class对象对应类包含的内部类。</p>\n</li>\n<li><p>访问该Class对象对应类所在的外部类。</p>\n</li>\n<li><p>访问该Class对象所对应类所继承的父类、所实现的接口等。</p>\n</li>\n</ul>\n<p><strong>重点接口：</strong></p>\n<ol>\n<li>Member接口：该接口可以获取有关类成员（域或者方法）后者构造函数的信息。</li>\n<li>AccessibleObject类：该类是域(field)对象、方法(method)对象、构造函数(constructor)对象的基础类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。</li>\n<li>Array类：该类提供动态地生成和访问JAVA数组的方法。</li>\n<li>Constructor类：提供一个类的构造函数的信息以及访问类的构造函数的接口。</li>\n<li>Field类：提供一个类的域的信息以及访问类的域的接口。</li>\n<li>Method类：提供一个类的方法的信息以及访问类的方法的接口。</li>\n</ol>\n<h4 id=\"获取类的Fields\"><a href=\"#获取类的Fields\" class=\"headerlink\" title=\"获取类的Fields\"></a>获取类的Fields</h4><ul>\n<li><code>public Field getField (String name)</code>：返回一个Field对象，它反映此Class对象所表示类或接口的指定公共成员字段（public修饰的指定属性）。</li>\n<li><code>public Field[] getFields() </code>：返回一个包含某些 Field 对象的数组，这些对象反映此 Class对象所表示的类或接口的所有可访问公共字段（public修饰的所有属性）。</li>\n<li><code>public Field getDeclaredField(Stringname)</code>：返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段（无视修饰符）。</li>\n<li><code>public Field[] getDeclaredFields()</code>：返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段（无视修饰符）。</li>\n</ul>\n<h4 id=\"获取类的Method\"><a href=\"#获取类的Method\" class=\"headerlink\" title=\"获取类的Method\"></a>获取类的Method</h4><ul>\n<li><code>public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</code>：返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法</li>\n<li><code>public Method[] getMethods()</code>：返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</li>\n<li><code>public Method getDeclaredMethod(Stringname,Class&lt;?&gt;... parameterTypes)</code>：返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</li>\n<li><code>public Method[] getDeclaredMethods()</code>：返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法,包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li>\n</ul>\n<h4 id=\"获取类的Constructor\"><a href=\"#获取类的Constructor\" class=\"headerlink\" title=\"获取类的Constructor\"></a>获取类的Constructor</h4><ul>\n<li><code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>：返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。</li>\n<li><code>public Constructor&lt;?&gt;[] getConstructors() </code>：返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法。</li>\n<li><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>：返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。</li>\n<li><code>public Constructor&lt;?&gt;[] getDeclaredConstructors()</code>：返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法</li>\n</ul>\n<h4 id=\"新建类的实例\"><a href=\"#新建类的实例\" class=\"headerlink\" title=\"新建类的实例\"></a>新建类的实例</h4><p>调用无自变量ctor（无参）：</p>\n<ul>\n<li>调用类的Class对象的newInstance方法，该方法会调用对象的默认构造器，如果没有默认构造器，会调用失败.</li>\n<li>调用默认Constructor对象的newInstance方法。需先获取类的Constructor对象。</li>\n</ul>\n<p>调用带参数ctor（有参）：</p>\n<ul>\n<li>调用带参数Constructor对象的newInstance方法。需先获取类的Constructor对象。</li>\n</ul>\n","categories":["Java学习","Java基础"],"tags":["知识点","类加载","反射"]},{"title":"计算机网络","url":"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><p>计算机网络：一些相互连接的计算机的集合。</p>\n<p>互联网：一些相互连接的计算机网络的集合（称为网络的网络）。</p>\n<h5 id=\"OSI七层模型：\"><a href=\"#OSI七层模型：\" class=\"headerlink\" title=\"OSI七层模型：\"></a>OSI七层模型：</h5><ol>\n<li>物理层</li>\n<li>数据链路层</li>\n<li>网络层</li>\n<li>传输层</li>\n<li>会话层</li>\n<li>表示层</li>\n<li>应用层</li>\n</ol>\n<h5 id=\"各个层的中间设备：\"><a href=\"#各个层的中间设备：\" class=\"headerlink\" title=\"各个层的中间设备：\"></a>各个层的中间设备：</h5><ul>\n<li>物理层中继系统：转发器</li>\n<li>数据链路层中继系统：网桥或桥接器</li>\n<li>网络层中继系统：路由器</li>\n<li>网桥和路由器的混合物：桥路器</li>\n<li>网络层以上的中继系统：网关</li>\n</ul>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"计算机网络的带宽\"><a href=\"#计算机网络的带宽\" class=\"headerlink\" title=\"计算机网络的带宽\"></a>计算机网络的带宽</h2><p>​\t\t计算机网络的带宽是指网络可通过的最高数据率，即每秒多少比特。</p>\n<p><strong>什么是宽带？</strong></p>\n<p>宽带线路：可通过较高数据率的线路。<br>宽带是相对的概念，并没有绝对的标准。<br>在目前，对于用户接入到因特网的用户线来说，每秒传送几个兆比特就可以算是宽带速率。</p>\n<h3 id=\"什么是分组交换\"><a href=\"#什么是分组交换\" class=\"headerlink\" title=\"什么是分组交换\"></a>什么是分组交换</h3><ul>\n<li>在发送端把要发送的报文分隔为较短的数据块</li>\n<li>每个块增加带有控制信息的首部构成分组（包）</li>\n<li>依次把各分组发送到接收端</li>\n<li>接收端剥去首部，抽出数据部分，还原成报文</li>\n</ul>\n<p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.png\" alt=\"image-20220712144505982\"></p>\n<p><strong>分组交换的特点：</strong></p>\n<ul>\n<li>高效    动态分配传输带宽，对通信链路是逐段占用。 </li>\n<li>灵活    以分组为传送单位和查找路由。</li>\n<li>迅速    不必先建立连接就能向其他主机发送分组；充分使用链路的带宽。</li>\n<li>可靠    完善的网络协议；自适应的路由选择协议使网络有很好的生存性。</li>\n</ul>\n<h2 id=\"网络互连\"><a href=\"#网络互连\" class=\"headerlink\" title=\"网络互连\"></a>网络互连</h2><ul>\n<li>当主机 A 要向另一个主机 B 发送数据报时，先要检查目的主机 B 是否与源主机 A 连接在同一个网络上。如果是，就将数据报<strong>直接交付</strong>给目的主机 B 而不需要通过路由器。</li>\n<li>但如果目的主机与源主机 A 不是连接在同一个网络上，则应将数据报发送给本网络上的某个路由器，由该路由器按照转发表指出的路由将数据报转发给下一个路由器。这就叫作<strong>间接交付</strong>。</li>\n</ul>\n<h3 id=\"典型的路由器的结构\"><a href=\"#典型的路由器的结构\" class=\"headerlink\" title=\"典型的路由器的结构\"></a>典型的路由器的结构</h3><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/16.png\" alt=\"image-20220712150545698\" style=\"zoom:67%;\">\n\n\n\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>​\t\t在计算机网络中，协议(protocol)是通信双方必须严格遵守的规则。协议精确地规定在网络通信中使用的各种控制信息的格式、意义以及各种事件出现的先后顺序。协议在计算机网络中起着非常重要的作用。</p>\n<!--more-->\n\n<h4 id=\"分层次的网络体系结构\"><a href=\"#分层次的网络体系结构\" class=\"headerlink\" title=\"分层次的网络体系结构\"></a>分层次的网络体系结构</h4><p><strong>五层原理体系结构：</strong></p>\n<p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Blog\\source_posts\\计算机网络\\1.png\" alt=\"image-20220712141744242\"></p>\n<p><strong>TCP&#x2F;IP的体系结构</strong></p>\n<img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Blog\\source\\_posts\\计算机网络\\2.png\" alt=\"image-20220712141927892\" style=\"zoom:80%;\">\n\n<p><strong>数据传输流程：</strong></p>\n<p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Blog\\source_posts\\计算机网络\\3.png\" alt=\"image-20220712142038449\"></p>\n<h4 id=\"IP协议（Internet-Protocol网际协议）（网络层）\"><a href=\"#IP协议（Internet-Protocol网际协议）（网络层）\" class=\"headerlink\" title=\"IP协议（Internet Protocol网际协议）（网络层）\"></a>IP协议（Internet Protocol网际协议）（网络层）</h4><p><strong>IPv4有32个bit位；</strong></p>\n<p><strong>IPv6有128个bit位；</strong></p>\n<p>​\t\t因特网的 IP 协议最重要，它为分组在互连网中的发送、传输和接收制定了详尽的规则。与 IP 协议配套使用的还有四个协议：</p>\n<ul>\n<li><p>地址解析协议 ARP （是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。）</p>\n<p>   (Address Resolution Protocol)</p>\n</li>\n<li><p>逆地址解析协议 RARP<br>(Reverse Address Resolution Protocol)</p>\n</li>\n<li><p>因特网控制报文协议 ICMP<br>(Internet Control Message Protocol)</p>\n</li>\n<li><p>因特网组管理协议 IGMP<br>(Internet Group Management Protocol)</p>\n</li>\n</ul>\n<p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.png\" alt=\"image-20220712151329556\"></p>\n<p><strong>IP网络的重要特点</strong></p>\n<ul>\n<li>每一个分组独立选择路由。</li>\n<li>发往同一个目的地的分组，后发送的有可能先收到（即可能不按顺序接收）。</li>\n<li>当网络中的通信量过大时，路由器就来不及处理分组，于是要丢弃一些分组。</li>\n<li>因此， IP 网络不保证分组的可靠地交付。</li>\n<li>IP 网络提供的服务被称为：尽最大努力服务(best effort service)</li>\n<li>IP协议屏蔽了网络在底层协议和实现技术上的差异，通过IP协议网络层向传输层提供统一的IP分组。</li>\n</ul>\n<p>​\t\t计算机通信是在计算机上运行的程序之间的通信。因为通信必须是可靠的，所以实现可靠通信最终应当是让计算机程序之间的通信可靠。因特网认为，IP 协议没有必要提供可靠服务（这样做可以使网络简单、灵活性好、价格便宜）。在计算机中增加 TCP 协议就可以实现计算机程序之间的可靠通信。因此引出TCP协议。</p>\n<h5 id=\"IP-数据报的格式\"><a href=\"#IP-数据报的格式\" class=\"headerlink\" title=\"IP 数据报的格式\"></a>IP 数据报的格式</h5><p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.png\" alt=\"image-20220714193658752\"></p>\n<p><strong>不存在粘包现象，只要确定报文前20个字节就可以确定报文长度</strong></p>\n<h5 id=\"IP-地址的编址方法\"><a href=\"#IP-地址的编址方法\" class=\"headerlink\" title=\"IP 地址的编址方法\"></a>IP 地址的编址方法</h5><p>分类的 IP 地址。这是最基本的编址方法.</p>\n<p>​\t\t<img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8.png\" alt=\"image-20220712151944698\"></p>\n<p>保留地址（私有地址）：</p>\n<ul>\n<li>A类：10.0.0.0-10.255.255.255</li>\n<li>B类：172.16.0.0-172.31.255.255</li>\n<li>C类：192.168.0.0-192.168.255.255</li>\n</ul>\n<ol>\n<li>网络全0表示表示本网络。</li>\n<li>主机号为全0表示本网络地址，全1是当前子网的广播地址</li>\n<li>127.0.0.1表示本主机的环回地址，ping该地址可以验证本主机网络驱动是否安装。ping网关可以验证本主机是否已连接上网络。</li>\n</ol>\n<p>其中网络层及以上使用IP地址，链路层及以下使用硬件地址（及MAC地址）。IP地址可以屏蔽物理地址。</p>\n<ul>\n<li>子网的划分。这是对最基本的编址方法的改进，其标准[RFC 950]在 1985 年通过。</li>\n</ul>\n<p>$$<br>IP地址 &#x3D; {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}<br>$$<br>​\t<img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.png\" alt=\"image-20220714195408747\"></p>\n<p><strong>IP地址与子网掩码取&amp;(与)可以得到网络地址</strong></p>\n<p><strong>主机位全为0的时候，此IP地址表示网络号代表网络段本身，也就是本网段的代表，常用在路由器的路由表中</strong></p>\n<p><strong>主机位全为1的时候，此IP地址表示广播地址，代表的是整个网段中的所有主机，即可以向该网段中所有的主机发送数据包</strong></p>\n<ul>\n<li>构成超网。这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。</li>\n</ul>\n<h5 id=\"网络互联：\"><a href=\"#网络互联：\" class=\"headerlink\" title=\"网络互联：\"></a>网络互联：</h5><ul>\n<li>专用地址网络：A类1个，B类16个，C类256个。专用地址不能与因特网连接，需要代理IP。</li>\n<li>内联网与外联网通信遇到代理IP，及网络地址转换NAT。</li>\n</ul>\n<h4 id=\"TCP协议（应用层）\"><a href=\"#TCP协议（应用层）\" class=\"headerlink\" title=\"TCP协议（应用层）\"></a>TCP协议（应用层）</h4><p>​\t\tTCP 是 Transmission Control Protocol 的缩写，中文译名是传输控制协议。TCP 协议驻留在用户计算机中，它的作用是保证应用程序之间端到端的可靠通信。</p>\n<h5 id=\"端口的概念\"><a href=\"#端口的概念\" class=\"headerlink\" title=\"端口的概念\"></a>端口的概念</h5><ul>\n<li>端口就是运输层服务访问点 TSAP。</li>\n<li>端口的作用就是让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li>\n<li>从这个意义上讲，端口是用来标志应用层的进程。</li>\n</ul>\n<p>端口具有本地意义，其中1k以内为熟知端口（例如  web项目：80；mysql：3306；tomcat：8080等）</p>\n<h5 id=\"TCP协议的特点：\"><a href=\"#TCP协议的特点：\" class=\"headerlink\" title=\"TCP协议的特点：\"></a>TCP协议的特点：</h5><ul>\n<li>TCP是传输层协议。</li>\n<li>TCP是全双工协议（就像打电话一样，在接收端接收信息时也可以使用同一条连接向发送端发送数据，叫全双工）。</li>\n<li>是一种可靠传输（什么机制保证它可靠：超时重传、收到回复）。</li>\n<li>是端到端的、面向连接的通信（TCP通信前需要建立连接，之后的通信都通过这条连接，所以需要维持连接）。</li>\n<li>当网络通信量过大，TCP会让发送端放慢发送数据。叫流量控制（拥塞避免算法）。</li>\n<li>TCP的速度由接收端决定，而不是发送端决定。</li>\n</ul>\n<h5 id=\"TCP协议数据报格式\"><a href=\"#TCP协议数据报格式\" class=\"headerlink\" title=\"TCP协议数据报格式\"></a>TCP协议数据报格式</h5><p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.png\" alt=\"image-20220714204410504\"></p>\n<ul>\n<li><strong>序号seq：</strong>seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li>\n<li><strong>确认号ack：</strong>ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack&#x3D;seq+1。</li>\n<li><strong>紧急比特URG</strong>：当URG&#x3D;1，表明紧急字段有效，它表示该报文段有紧急数据，应尽快传送。</li>\n<li><strong>确认比特ACK：</strong>只有当ACK&#x3D;1时确认号字段才有效。当ACK&#x3D;0时，确认号无效。</li>\n<li><strong>推送比特PSH：</strong>接收TCP收到推送比特置1的报文段，就尽快交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>\n<li><strong>复位比特RST：</strong>当RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。</li>\n<li><strong>同步比特SYN：</strong>同步比特SYN置为1，就表示这是一个连接请求或连接接受报文。</li>\n<li><strong>终止比特FIN：</strong>用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>\n<li><strong>窗口：</strong>客户端限制服务器发送的数据量。</li>\n</ul>\n<p><strong>重点：</strong></p>\n<p><strong>&#x3D;&#x3D;TCP三次握手建立TCP连接：&#x3D;&#x3D;</strong></p>\n<p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/13.png\" alt=\"图片来自网络，侵权请告知，会及时删除\"></p>\n<p><strong>第一次握手：</strong>客户端向服务端发送一个SYN段（在 TCP 标头中 SYN 位字段为 <strong>1</strong> 的 TCP&#x2F;IP 数据包），该段中也包含客户端的初始序号seq(Sequence number &#x3D; x)。</p>\n<!--SYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接-->\n\n<p><strong>第二次握手：</strong>服务器返回客户端 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP&#x2F;IP 数据包)， 该段中包含服务器的初始序号seq(Sequence number &#x3D; y)；同时使 ack(Acknowledgment number &#x3D; x + 1)来表示确认已收到客户端的 SYN段(Sequence number &#x3D; x)。</p>\n<!--ACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包-->\n\n<p><strong>第三次握手：</strong>客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 <strong>1</strong> 的 TCP&#x2F;IP 数据包), 该段中包含服务器的初始序号seq(Sequence number &#x3D; x + 1)，同时使ack(Acknowledgment number &#x3D; y + 1)来表示确认已收到服务器的 SYN段序号seq(Sequence number &#x3D; y)。</p>\n<p><strong>&#x3D;&#x3D;TCP四次挥手释放TCP连接：&#x3D;&#x3D;</strong></p>\n<p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/14.png\" alt=\"图片来自网络，侵权请告知，会及时删除\"></p>\n<p><strong>第一次挥手：</strong>客户端发送一个FIN段（在 TCP 标头中 FIN位字段为 <strong>1</strong> 的 TCP&#x2F;IP 数据包），该段中也包含客户端的初始序号seq(Sequence number &#x3D; u)。用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态。</p>\n<!--FIN 是“终止”的缩写。 FIN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间释放连接-->\n\n<p><strong>第二次挥手</strong>：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器进入CLOSE_WAIT状态。</p>\n<p><strong>第三次挥手：</strong>服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。</p>\n<p><strong>第四次挥手：</strong>客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成四次挥手</p>\n<p><strong>TCP数据报文存在粘包现象，解决办法是在选项里添加报文总长度。</strong></p>\n<p><strong>TCP 协议的主要功能</strong></p>\n<ul>\n<li>TCP 给要传送的每一个字节的数据都进行编号。<ul>\n<li>接收端在收到数据后必须向发送端发送确认信息。</li>\n<li>若发送端在规定的时间内没有收到对方的确认，就重传这部分数据。</li>\n</ul>\n</li>\n<li>当网络中的通信量过大时，TCP 就告诉发送端要放慢发送数据。这叫做流量控制。<ul>\n<li>接收端窗口 rwnd     这是接收端根据其目前的接收缓存大小所许诺的最新的窗口值，是来自接收端的流量控制。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。</li>\n<li>拥塞窗口 cwnd (congestion window)    是发送端根据自己估计的网络拥塞程度而设置的窗口值，是来自发送端的流量控制。</li>\n</ul>\n</li>\n</ul>\n<p>​\t\tTCP&#x2F;IP是因特网的核心协议，分组在因特网中传送要使用 IP 协议。计算机数据传输的可靠性由 TCP 协议来保证。通常用 TCP&#x2F;IP 这样的记法表示以 TCP 和 IP 为核心的协议族。</p>\n<p>TCP可靠通信的原理：</p>\n<ul>\n<li>超时重传</li>\n<li>按字节累加传输</li>\n</ul>\n<h4 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h4><p>UDP是<strong>传输层</strong>的协议，功能即为在IP的数据报服务之上增加了最基本的服务：<strong>复用</strong>和<strong>分用</strong>以及<strong>差错检测</strong>。</p>\n<p>UDP提供<strong>不可靠</strong>服务，具有TCP所没有的<strong>优势</strong>：</p>\n<ul>\n<li>UDP<strong>无连接</strong>，时间上<strong>不存在建立连接需要的时延</strong>。空间上，TCP需要在端系统中<strong>维护连接</strong>状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。</li>\n<li><strong>分组首部开销小</strong>，TCP首部20字节，UDP首部8字节。</li>\n<li><strong>UDP没有拥塞控制</strong>，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，<strong>能容忍一些数据的丢失，但是不能允许有较大的时延</strong>（比如实时视频，直播等）</li>\n<li>UDP<strong>提供尽最大努力的交付</strong>，不保证可靠交付。所有维护传输可靠性的工作需要用户在<strong>应用层</strong>来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。</li>\n<li>UDP是<strong>面向报文</strong>的，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。</li>\n</ul>\n<h5 id=\"UDP数据报报文头部：\"><a href=\"#UDP数据报报文头部：\" class=\"headerlink\" title=\"UDP数据报报文头部：\"></a>UDP数据报报文头部：</h5><p><img src=\"/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/15.png\" alt=\"image-20220803190345301\"></p>\n<h4 id=\"打开一个网站需要经历哪些过程？\"><a href=\"#打开一个网站需要经历哪些过程？\" class=\"headerlink\" title=\"打开一个网站需要经历哪些过程？\"></a>打开一个网站需要经历哪些过程？</h4><h5 id=\"一、页面加载\"><a href=\"#一、页面加载\" class=\"headerlink\" title=\"一、页面加载\"></a>一、页面加载</h5><ol>\n<li>在浏览器输入地址回车之后，浏览器进行dns解析：浏览器自身缓存（Chrome浏览器通过输入：chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 打开DNS缓存页面）-&gt; 搜索hosts文件和操作系统缓存 -&gt; 域名解析服务器发送解析请求 -&gt; 域名解析服务器也没有该域名的记录，则开始递归+迭代解析(树形搜索的过程) -&gt; 获取域名对应的IP后，一步步返回给浏览器。</li>\n<li>通过握手协议建立起TCP连接并发送http请求：浏览器会选择一个大于1024的本机端口向目标IP地址的80端口发起TCP连接请求。经过标准的TCP握手流程，建立TCP连接 -&gt; 按照HTTP协议标准发送一个索要网页的请求。</li>\n</ol>\n<h5 id=\"二、静态资源加载（一般使用CDN）\"><a href=\"#二、静态资源加载（一般使用CDN）\" class=\"headerlink\" title=\"二、静态资源加载（一般使用CDN）\"></a>二、静态资源加载（一般使用CDN）</h5><p>在浏览器解析页面内容的时候，会发现页面引用了其他未加载的image、css文件、js文件等静态内容，浏览器根据url向提供静态资源的服务器请求加载该url下的图片内容等。本质上是浏览器重新开始第一部分的流程。</p>\n<p>域名解析-&gt;建立连接-&gt;获取请求-&gt;得到静态资源-&gt;边解析边请求-&gt;直到所有请求完成</p>\n","categories":["Java学习","计算机网络"],"tags":["知识点","计算机网络","协议"]},{"title":"链表","url":"/2022/05/09/%E9%93%BE%E8%A1%A8/","content":"<h3 id=\"例题一\"><a href=\"#例题一\" class=\"headerlink\" title=\"例题一\"></a>例题一</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>\n<p><strong>示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">4</span>-&gt;<span class=\"number\">5</span>-&gt;NULL</span><br><span class=\"line\">输出: <span class=\"number\">5</span>-&gt;<span class=\"number\">4</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>\n\n<p><strong>限制：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> &lt;= 节点个数 &lt;= <span class=\"number\">5000</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><h5 id=\"解题思路一：迭代\"><a href=\"#解题思路一：迭代\" class=\"headerlink\" title=\"解题思路一：迭代\"></a>解题思路一：迭代</h5><p>假设链表为 <code>1→2→3→∅</code>，我们想要把它改成<code>∅←1←2←3</code>。</p>\n<p>在遍历链表时，将当前节点的<code>next</code>指针改为指向前一个节点。由于该节点没有引用其前一个节点，因此需要事先准备一个空节点储存前一个节点，在更改引用之前还需要存储后一个节点。最后返回新的头节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">reverseList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;      <span class=\"comment\">//用来储存倒叙</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> head;      </span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;      </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            n = c.next;</span><br><span class=\"line\">            c.next = p;</span><br><span class=\"line\">            p = c;</span><br><span class=\"line\">            c = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"解题思路二：递归\"><a href=\"#解题思路二：递归\" class=\"headerlink\" title=\"解题思路二：递归\"></a>解题思路二：递归</h5><ul>\n<li>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 <code>newHead</code> .</li>\n<li>此后，每次函数在返回的过程中，让当前结点的下一个结点的 <code>next</code>指针指向当前节点。</li>\n<li>同时让当前结点的 <code>next</code> 指针指向 <code>null</code> ，从而实现从链表尾部开始的局部反转</li>\n<li>当递归函数全部出栈后，链表反转完成。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">reverseList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">newHead</span> <span class=\"operator\">=</span> reverseList(head.next);</span><br><span class=\"line\">        head.next.next = head;</span><br><span class=\"line\">        head.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>递归较难理解，用笔演算一遍会好一点。</strong></p>\n<hr>\n<h3 id=\"例题二\"><a href=\"#例题二\" class=\"headerlink\" title=\"例题二\"></a>例题二</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>\n<p><strong>示例1</strong></p>\n<p><img src=\"/2022/05/09/%E9%93%BE%E8%A1%A8/e1.png\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [[<span class=\"number\">7</span>,<span class=\"literal\">null</span>],[<span class=\"number\">13</span>,<span class=\"number\">0</span>],[<span class=\"number\">11</span>,<span class=\"number\">4</span>],[<span class=\"number\">10</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\">输出：[[<span class=\"number\">7</span>,<span class=\"literal\">null</span>],[<span class=\"number\">13</span>,<span class=\"number\">0</span>],[<span class=\"number\">11</span>,<span class=\"number\">4</span>],[<span class=\"number\">10</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例2</strong></p>\n<img src=\"/2022/05/09/%E9%93%BE%E8%A1%A8/e2.png\" alt=\"img\" style=\"zoom:67%;\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [[<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">2</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">输出：[[<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">2</span>,<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例3</strong></p>\n<img src=\"/2022/05/09/%E9%93%BE%E8%A1%A8/e3.png\" alt=\"img\" style=\"zoom:67%;\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [[<span class=\"number\">3</span>,<span class=\"literal\">null</span>],[<span class=\"number\">3</span>,<span class=\"number\">0</span>],[<span class=\"number\">3</span>,<span class=\"literal\">null</span>]]</span><br><span class=\"line\">输出：[[<span class=\"number\">3</span>,<span class=\"literal\">null</span>],[<span class=\"number\">3</span>,<span class=\"number\">0</span>],[<span class=\"number\">3</span>,<span class=\"literal\">null</span>]]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：给定的链表为空（空指针），因此返回 <span class=\"literal\">null</span>。</span><br></pre></td></tr></table></figure>\n\n<p> <strong>提示：</strong></p>\n<ul>\n<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>\n<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>\n<li>节点数目不超过 1000 。</li>\n</ul>\n<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><p><strong>回溯+哈希表</strong></p>\n<p>如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p>\n<p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p>\n<p>在实际代码中，我们需要特别判断给定节点为空节点的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    Map&lt;Node, Node&gt; cachedNode = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;Node, Node&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node <span class=\"title function_\">copyRandomList</span><span class=\"params\">(Node head)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cachedNode.containsKey(head)) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">headNew</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(head.val);</span><br><span class=\"line\">            cachedNode.put(head, headNew);</span><br><span class=\"line\">            headNew.next = copyRandomList(head.next);</span><br><span class=\"line\">            headNew.random = copyRandomList(head.random);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cachedNode.get(head);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>参考来源：力扣（LeetCode）</p>\n<p>作者：jyd</p>\n</blockquote>\n","categories":["LeetCode学习","链表"],"tags":["算法","链表","哈希表"]},{"title":"集合","url":"/2022/07/26/%E9%9B%86%E5%90%88/","content":"<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><ul>\n<li>为了保存数量不确定的数据，以及保存具有映射关系的数据（也被称为关联数组）。Java提供集合类，集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所有集合类 都位于java.util包下。 </li>\n<li>Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架 的根接口，这两个接口又包含了一些子接口或实现类。</li>\n</ul>\n<p><strong>Collection集合</strong></p>\n<p><img src=\"/2022/07/26/%E9%9B%86%E5%90%88/1.png\" alt=\"image-20220726092647305\"></p>\n<p><strong>Map集合</strong></p>\n<p><img src=\"/2022/07/26/%E9%9B%86%E5%90%88/2.png\" alt=\"image-20220726092816359\"></p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><ul>\n<li>Collection接口是List、set和Queur接口的父接口，该接口里定义的方法既可用于操作Set集合 ，也可用于操作List和Queue集合。 </li>\n<li>Collection提供了大量添加、删除、访问的方法来访问集合元素。（其中也包含Collection类之间的互相增删查改）</li>\n</ul>\n<h4 id=\"Iterator接口\"><a href=\"#Iterator接口\" class=\"headerlink\" title=\"Iterator接口\"></a>Iterator接口</h4><p>Iterator接口是java集合框架的成员，主要用于Collection集合的遍历，因此Iterator对象也被称为迭代器。主要有以下3个方法：</p>\n<ol>\n<li><strong>boolean hasNext()</strong> ：如果被迭代的集合还元素没有被遍历，则返回true。</li>\n<li><strong>Object next()</strong> ：返回集合里下一个元素。</li>\n<li><strong>void remove()</strong> ：删除集合里上一次next方法返回的元素</li>\n</ol>\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><h4 id=\"HashSet类\"><a href=\"#HashSet类\" class=\"headerlink\" title=\"HashSet类\"></a>HashSet类</h4><p>HashSet是Set接口的典型实现，大多数时候使用Set集合就是使用这个实现类。HashSet按 Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。</p>\n<p><strong>HashSet的比较机制：</strong>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象 的hashCode值，然后根据该HashCode做hash()运算（HashCode值取模）获得hash值，由hash来决定该对象在HashSet中存储位置。如果有两个元素通过equals方法比较返回true，但它们的hashCode()方法返回值不相等，HashSet将会把它们存储在不同位置，也就可以添加成功。</p>\n<p><strong>HashSet的特征：</strong></p>\n<ul>\n<li>不能保证元素的排列顺序，顺序可能与元素的添加顺序不同，元素的顺序可能变化。</li>\n<li>HashSet不是同步的，如果多个线程同时访问一个HashSet，如果有2条或者2条以上线程同时修改了HashSet集合时，必须通过代码来保证其同步。（ &#x3D;&#x3D;线程不安全的&#x3D;&#x3D; ）</li>\n<li>集合元素值可以是null。</li>\n</ul>\n<p><strong>HashSet的底层实现是HashMap对象</strong>：对HashMap&lt;k, v&gt;的value值取固定Object对象，利用key值不可重复的特点进行存储。底层实现为拉链法与红黑树（<strong>数据量小时使用拉链法，数据量大时使用红黑树</strong>）</p>\n<h4 id=\"LinkedHashSet类\"><a href=\"#LinkedHashSet类\" class=\"headerlink\" title=\"LinkedHashSet类\"></a>LinkedHashSet类</h4><p>LinkedHashSet集合也是根据元素hashCode值来决定元素存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里元素时，HashSet将会按元素的添加顺序来访问集合里的元素。</p>\n<p>LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能， 但在迭代访问Set里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p>\n<h4 id=\"TreeSet类\"><a href=\"#TreeSet类\" class=\"headerlink\" title=\"TreeSet类\"></a>TreeSet类</h4><p><strong>TreeSet是SortedSet接口的唯一实现</strong>，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态。与前面HashSet集合相比，TreeSet还提供了如下几个额外的方法：</p>\n<ul>\n<li>Object first()：返回集合中的第一个元素。</li>\n<li>Object last()：返回集合中的最末一个元素。</li>\n<li>Object lower(Object e)：返回集合中位于指定元素之前的元素（即小于指定元素的最 大元素，参考元素不需要是TreeSet的元素）。 </li>\n<li>Object higher(Object e)：返回集合中位于指定元素之后的元素（即大于指定元素的最 小元素，参考元素不需要是TreeSet的元素）。 </li>\n<li>SortedSet subSet(fromElement, toElement)：返回此Set的子集合，范围从 fromElement（包含）到toElement（不包含）。</li>\n<li>SortedSet headSet(toElement)：返回此Set的子集，由小于toElement的元素组成。</li>\n<li>SortedSet tailSet(fromElement)：返回此Set的子集，由大于或等于fromElement的元 素组成。</li>\n</ul>\n<p><strong>TreeSet的排序：</strong>TreeSet采用<strong>红黑树</strong>的数据结构对元素进行排序。TreeSet支持两种排序方法：自然排序和定制排序。</p>\n<p><strong>TreeSet的比较机制：</strong>实现Comparator接口或传入该对象（传入对象需要内部类重写comparaTo方法）。Comparator是一个比较器。</p>\n<p><strong>TreeSet的底层实现为treeMap（使用红黑树）</strong></p>\n<h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><ul>\n<li>List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。</li>\n<li>List作为Collection接口的子接口，当然可以使用Collection接口里全部方法。而且由于List是有序集合，因此List集合里包含了根据索引来操作集合元素的方法。</li>\n</ul>\n<h4 id=\"ArrayList与Vector\"><a href=\"#ArrayList与Vector\" class=\"headerlink\" title=\"ArrayList与Vector\"></a>ArrayList与Vector</h4><ul>\n<li>ArrayList和Vector类都是基于数组实现的List类，所以ArrayList和Vector类封装了一个动态再分配的<strong>Object[]数组</strong>。每个ArrayList或Vector对象有一个capacity属性，这个capacity表示它们所封装的Object[]数组的长度。当向ArrayList或Vector中添加元素时，它们的capacity会自动增加。</li>\n<li>ArrayList和Vector的显著区别是；<strong>ArrayList是 &#x3D;&#x3D;线程不安全&#x3D;&#x3D; 的</strong>，当多条线程访问同一个ArrayList集合时，如果有超过一条线程修改了ArrayList集合，则程序必须手动保证该集合的同步性。但<strong>Vector集合则是 &#x3D;&#x3D;线程安全&#x3D;&#x3D; 的</strong>，无需程序保证该集合的同步性。</li>\n</ul>\n<p><strong>ArrayList扩容：</strong></p>\n<ul>\n<li>当前长度为空或当前长度加二小于10时，扩容为10。</li>\n<li>（当前长度加二  - 当前长度）&gt; 当前长度的一半时，扩容为当前长度 + （当前长度加二 - 当前长度）</li>\n<li>（当前长度加二  - 当前长度）&lt; 当前长度的一半时，扩容为当前长度的1.5倍。</li>\n</ul>\n<p><strong>Vector扩容：</strong></p>\n<ul>\n<li>创建vector对象时不传入初始容量，则默认初始容量为10；</li>\n<li>创建vector对象时不传入增长容量，则默认增长容量为原长的两倍；</li>\n<li>创建vector对象时传入初始容量与增长容量，则扩容为原容量加增长容量；</li>\n</ul>\n<h3 id=\"Queue接口\"><a href=\"#Queue接口\" class=\"headerlink\" title=\"Queue接口\"></a>Queue接口</h3><p>Queue用于模拟了队列这种数据结构，队列通常是指“先进先出”（FIFO）的容器。队列的头部保存在队列中存放时间最长的元素。队列的尾部保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</p>\n<h4 id=\"LinkedList类\"><a href=\"#LinkedList类\" class=\"headerlink\" title=\"LinkedList类\"></a>LinkedList类</h4><p>它是List接口的实现类——这意味着它是一个List集合，可以根据索引来随机访问集合中的元素。除此之外，LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双端队列。</p>\n<p>LinkedList不仅可以当成双端队列使用，也可以当成“栈”使用，因为该类里还包含了pop（出栈）和push（入栈）两个方法。除此之外，LinkedList实现了List接口，所以还被当成List使用。（与ArrayList与Vector实现机制不同，使用链表来存储元素）</p>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"Hashtable\"><a href=\"#Hashtable\" class=\"headerlink\" title=\"Hashtable\"></a>Hashtable</h3><ul>\n<li><strong>Hashtable是一个 &#x3D;&#x3D;线程安全&#x3D;&#x3D; 的Map实现</strong>（线程安全会影响读取效率）</li>\n<li>底层由拉链法实现，key与value都不能为空（<strong>为空会抛空指针异常</strong>）。</li>\n<li>Hashtable中的映射不是有序的。底层实现与HashMap相同。</li>\n<li>Hashtable初始容量为11，加载因子为0.75</li>\n</ul>\n<h5 id=\"添加机制\"><a href=\"#添加机制\" class=\"headerlink\" title=\"添加机制\"></a>添加机制</h5><ol>\n<li>判断key是否为空，为空丢异常</li>\n<li>如key不为空，则对key进行散列值，也就是调用hashCode方法。</li>\n<li>经过对key的hash运算得出数组下标</li>\n<li>根据下标对获取Entry，如为空，直接添加，如不为空，则代表当前位置已有元素，会进行判断当前key的hash与位置已有元素key的hash值是否相同，如果不相同，走添加方法，如当前key的hash与位置已有元素key的hash相同并且equals也相同，则此时将key与value替代掉此位置原有元素 并返回原有key</li>\n<li>put方法为synchronized</li>\n</ol>\n<h5 id=\"比较机制（与HashMap相同）\"><a href=\"#比较机制（与HashMap相同）\" class=\"headerlink\" title=\"比较机制（与HashMap相同）\"></a>比较机制（与HashMap相同）</h5><h5 id=\"扩容机制\"><a href=\"#扩容机制\" class=\"headerlink\" title=\"扩容机制\"></a>扩容机制</h5><ul>\n<li>长度直接扩充到原有两倍加一 ，如果扩充完之后大于长度允许的最大值，则长度变为最大长度</li>\n<li>进行重新计算散列值添加</li>\n</ul>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><ul>\n<li><p><strong>HashMap是拉链法加红黑树结构，key可以为空，value可以为空</strong>（所以HashMap可以且最多有一个空key）</p>\n</li>\n<li><p><strong>HashMap是 &#x3D;&#x3D;线程是不安全的&#x3D;&#x3D; 的Map实现</strong>（效率高）</p>\n</li>\n<li><p>HashMap初始容量为16，加载因子为0.75</p>\n</li>\n</ul>\n<h5 id=\"添加机制-1\"><a href=\"#添加机制-1\" class=\"headerlink\" title=\"添加机制\"></a>添加机制</h5><p>当我们选择put一个key与value时，程序会首先对key进行hashCode，然后再对hashCode进行异或(^)变成hash，也就是经常说得扰乱，作用是减少hashCode相同产生的碰撞。</p>\n<p>当hash与桶的hash相同时进行qut,如有此桶里面有值，则将新值放到前一个值的next中，依次类推。但是桶下面的链表只能拥有最多8个元素，如超过8个元素将采用红黑树的方式进行表达元素顺序，采用红黑树的目的是为了防止链表太长，会影响获取key时间，当红黑树的长度小于8时，便将红黑树转换为链表，在元素8以下的时候，链表的效率高于红黑树。</p>\n<h5 id=\"比较机制\"><a href=\"#比较机制\" class=\"headerlink\" title=\"比较机制\"></a>比较机制</h5><p>首先是获取key的hash与map中的hash对比，如没有，返回null，如命中，则获取第一个元素，进行equlas，如不相同，判断元素中的next是否为空，如不为空继续判断，如不相同，继续判断，当有相同时进行返回，如无返回null。</p>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><ul>\n<li><p>与HashMap相比，TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。其中，可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序；</p>\n</li>\n<li><p>TreeMap底层实现为空黑树；</p>\n</li>\n<li><p>当未实现 Comparator 接口时，key 不可以为null，否则抛NullPointerException 异常；</p>\n<p>当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。</p>\n</li>\n<li><p>其余与HashMap相似。</p>\n</li>\n</ul>\n<p><strong>Collections.synchronizedList</strong>(可以让集合线程安全)</p>\n","categories":["Java学习","Java基础"],"tags":["知识点","集合","容器类"]}]