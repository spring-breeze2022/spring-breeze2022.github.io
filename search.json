[{"title":"搜索与回溯算法二","url":"/2022/05/16/搜索与回溯算法二/","content":"\n### 例题一\n\n输入两棵二叉树*A*和*B*，判断*B*是不是*A*的子结构。(约定空树不是任意一个树的子结构)\n\n*B*是*A*的子结构， 即 *A*中有出现和*B*相同的结构和节点值。\n\n**例如:**\n给定的树 *A*:\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n```\n\n给定的树 *B*：\n\n```java\n   4 \n  /\n 1\n```\n\n返回 `true`，因为 *B* 与 *A* 的一个子树拥有相同的结构和节点值。\n\n**示例 1：**\n\n```java\n输入：A = [1,2,3], B = [3,1]\n输出：false\n```\n\n**示例 2：**\n\n```java\n输入：A = [3,4,5,1,2], B = [4,1]\n输出：true\n```\n\n**限制：**\n\n`0 <= 节点个数 <= 10000`\n\n<!--more-->\n\n\n\n#### 题解\n\n##### 解题思路：\n\n由题意可知，若树*B*是树*A*的子结构，则子结构的根节点可能是树*A*的任意一个节点。因此需要判断树*B*是不是树*A*的子结构，只需要判断树*B*是否为树*A*的子节点，通过以下两步完成工作：\n\n1. 先序遍历树*A*中每个节点$n_A$;(对应函数`isSubStructure(A, B)`)\n2. 判断树 *A*中 **以 $n_A$为根节点的子树** 是否包含树 *B* 。（对应函数 `recur(A, B)`）\n\n<img src=\"搜索与回溯算法二/1.png\" alt=\"Picture1.png\" style=\"zoom:80%;\" />\n\n\n\n##### 算法流程：\n\n**`recur(A, B)` 函数：**\n\n1. **终止条件：**\n   - 当节点 *B* 为空：说明树 *B* 已匹配完成（越过叶子节点），因此返回 `true` ；\n   - 当节点 *A* 为空：说明已经越过树 *A* 叶子节点，即匹配失败，返回 `false` ；\n   - 当节点 *A* 和 *B*  的值不同：说明匹配失败，返回 `false` ；\n2. **返回值：**\n   - 判断 *A* 和 *B*  的左子节点是否相等，即 `recur(A.left, B.left)` ；\n   - 判断 *A* 和 *B*  的右子节点是否相等，即 `recur(A.right, B.right)` ；\n\n**`isSubStructure(A, B)` 函数：**\n\n1. **特例处理：** 当 树 *A* 为空 或 树 *B*为空 时，直接返回 `false` ；\n2. **返回值：** 若树 *B*是树 *A*的子结构，则必满足以下三种情况之一，因此用或 `||` 连接；\n   - 以 节点 *A*为根节点的子树 包含树 *B*，对应 `recur(A, B)`；\n   - 树 *B*是 树 *A*左子树 的子结构，对应 `isSubStructure(A.left, B)`；\n   - 树 *B* 是 树 *A*右子树 的子结构，对应 `isSubStructure(A.right, B)`；\n\n\n\n```java\nclass Solution {\n    public boolean isSubStructure(TreeNode A, TreeNode B) {\n        return (A != null && B != null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));\n    }\n    boolean recur(TreeNode A, TreeNode B) {\n        if(B == null) \n            return true;\n        if(A == null || A.val != B.val) \n            return false;\n        return recur(A.left, B.left) && recur(A.right, B.right);\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n```java\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n```java\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n**示例 1：**\n\n```java\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n```\n\n**示例 2：**\n\n```java\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n```\n\n**限制：**\n\n`0 <= 节点个数 <= 1000`\n\n\n\n#### 题解\n\n##### 解题思路：\n\n- **对称二叉树定义：** 对于树中 **任意两个对称节点**  *L* 和 *R* ，一定有：\n  - `L.val = R.val`：即此两对称节点值相等。\n  - `L.left.val = R.right.val`：即 *L*的 左子节点 和 *R*的 右子节点 对称；\n  - `L.right.val = R.left.val`：即 *L*的 右子节点 和 *R*的 左子节点 对称。\n- 根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。\n\n![Picture1.png](搜索与回溯算法二/2.png)\n\n\n\n##### 算法流程：\n\n`isSymmetric(root)`：\n\n- **特例处理：** 若根节点 `root` 为空，则直接返回 `true` 。\n- **返回值：** 即 `recur(root.left, root.right)` ;\n\n`recur(L, R)`：\n\n- **终止条件：**\n  - 当 *L*和 *R*同时越过叶节点： 此树从顶至底的节点都对称，因此返回`true` ；\n  - 当 *L*或 *R*中只有一个越过叶节点： 此树不对称，因此返回`false` ；\n  - 当节点 *L*值 $\\ne$ 节点 *R*值： 此树不对称，因此返回 `false`；\n- **递推工作：**\n  - 判断两节点 `L.left` 和 `R.right` 是否对称，即 `recur(L.left, R.right)`；\n  - 判断两节点 `L.right` 和 `R.left` 是否对称，即 `recur(L.right, R.left)`；\n- **返回值：** 两对节点都对称时，才是对称树，因此用与逻辑符 `&&` 连接。\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return root == null ? true : recur(root.left, root.right);\n    }\n    boolean recur(TreeNode L, TreeNode R) {\n        if(L == null && R == null) \n            return true;\n        if(L == null || R == null || L.val != R.val)\n            return false;\n        return recur(L.left, R.right) && recur(L.right, R.left);\n    }\n}\n```\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd\n\n","tags":["算法","二叉树","深度优先搜索"],"categories":["LeetCode学习","搜索与回溯算法"]},{"title":"搜索与回溯算法","url":"/2022/05/15/搜索与回溯算法/","content":"\n### 例题一\n\n从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\n\n \n\n**例如:**\n给定二叉树: `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n**返回：**\n\n```java\n[3,9,20,15,7]\n```\n\n**提示：**\n\n- 节点总数 <= 1000\n\n<!--more-->\n\n\n\n#### 题解\n\n##### 解题思路\n\n- 题目要求的二叉树的 **从上至下** 打印（即按层打印），又称为二叉树的 **广度优先搜索**（BFS）。\n- BFS 通常借助 **队列** 的先入先出特性来实现。\n\n<img src=\"搜索与回溯算法/1.png\" alt=\"Picture0.png\" style=\"zoom:80%;\" />\n\n\n\n##### 算法流程\n\n1. **特例处理：**当根节点为空时，直接返回空列表[]；\n2. **初始化：**打印结果列表`list`，队列`queue[]`将`root`根节点放入队列；\n3. **BFS循环：**当队列为空时退出循环\n   - **出队：**队首元素出队，记为`T`；\n   - **打印：**将`T.val`添加至列表`list`尾部；\n   - **添加子节点：**若`T`的左(右)节点不为空，则将左(右)节点加入队列`queue`；\n4. **返回值：**将打印列表转为数组`res`，返回数组`res`即可。\n\n```java\nclass Solution {\n    public int[] levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        List<Integer> list = new LinkedList<Integer>();   \n        if(root == null)\n            return new int[0];\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode T = queue.remove();\n            if(T.left != null){\n                queue.add(T.left);\n            }\n            if(T.right != null){\n                queue.add(T.right);\n            }\n            list.add(T.val);\n        }\n        int[] res = new int[list.size()];\n            for(int i = 0; i < list.size(); i++)\n                res[i] = list.get(i);\n            return res;\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n\n \n\n**例如:**\n给定二叉树: `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回其层次遍历结果：\n\n```java\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n```\n\n\n提示：\n\n- 节点总数 <= 1000\n\n\n\n#### 题解\n\n##### 解题思路：层序遍历 + 双端队列\n\n- 利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列)`tmp`，并规定：\n  - 奇数层 则添加至 `tmp` **尾部** ，\n  - 偶数层 则添加至 `tmp` **头部** 。\n\n<img src=\"搜索与回溯算法/2.png\" alt=\"Picture1.png\" style=\"zoom:80%;\" />\n\n\n\n##### 算法流程：\n\n1. **特例处理：** 当树的根节点为空，则直接返回空列表 `[]` ；\n2. **初始化：** 打印结果空列表 `res` ，包含根节点的双端队列 `deque` ；\n3. **BFS 循环：** 当 `deque` 为空时跳出；\n   - 新建列表 `tmp` ，用于临时存储当前层打印结果；\n   - **当前层打印循环：** 循环次数为当前层节点数（即 `deque` 长度）；\n     - **出队：** 队首元素出队，记为 `node`；\n     - **打印：** 若为奇数层，将 `node.val` 添加至 `tmp` 尾部；否则，添加至 `tmp`头部；\n     - **添加子节点：** 若 `node` 的左（右）子节点不为空，则加入 `deque` ；\n   - 将当前层结果 `tmp` 转化为 `list` 并添加入 `res` ；\n4. **返回值：** 返回打印结果列表 `res` 即可；\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        List<List<Integer>> res = new ArrayList<>();\n        if(root != null) \n            queue.add(root);\n        while(!queue.isEmpty()) {\n            LinkedList<Integer> tmp = new LinkedList<>();\n            for(int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                if(res.size() % 2 == 0)\n                    tmp.addLast(node.val); // 偶数层 -> 队列头部\n                else\n                    tmp.addFirst(node.val); // 奇数层 -> 队列尾部\n                if(node.left != null)\n                    queue.add(node.left);\n                if(node.right != null) \n                    queue.add(node.right);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n-----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd\n\n","tags":["算法","二叉树","广度优先搜索"],"categories":["LeetCode学习","搜索与回溯算法"]},{"title":"查找算法","url":"/2022/05/14/查找算法/","content":"\n### 例题一\n\n在一个 ``n * m`` 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n \n\n**示例:**\n\n现有矩阵 ``matrix`` 如下：\n\n````java\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n````\n\n\n给定 ``target = 5``，返回 ``true``。\n\n给定 ``target = 20``，返回 ``false``。\n\n \n\n**限制：**\n\n``0 <= n <= 1000``\n\n``0 <= m <= 1000``\n\n<!--more-->\n\n#### 题解\n\n##### 解题思路一：暴力\n\n如果不考虑二维数组排好序的特点，则直接遍历整个二维数组的每一个元素，判断目标值是否在二维数组中存在。\n\n依次遍历二维数组的每一行和每一列。如果找到一个元素等于目标值，则返回 true。如果遍历完毕仍未找到等于目标值的元素，则返回 false。**（不推荐）**\n\n```java\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int rows = matrix.length, columns = matrix[0].length;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n##### 解题思路二：二分查找\n\n由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。\n\n从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 `true`。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。\n\n可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。\n\n- 若数组为空，返回 `false`\n\n- 初始化行下标为 `0`，列下标为二维数组的列数减` 1`\n  - 重复下列步骤，直到行下标或列下标超出边界\n  - 获得当前下标位置的元素 `num`\n  - 如果 `num` 和 `target `相等，返回 `true`\n  - 如果 `num` 大于 `target`，列下标减 `1`\n  - 如果 `num` 小于 `target`，行下标加 `1`\n- 循环体执行完毕仍未找到元素等于 `target` ，说明不存在这样的元素，返回 `false`。\n\n```java\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int long1 = matrix[0].length;\n        int high1 = matrix.length;\n        int long2 = long1 - 1;\n        int high2 = 0;\n        while(high2 < high1 && long2 >= 0){\n            if(matrix[high2][long2] == target){\n                return true;\n            }else if(matrix[high2][long2] < target){\n                high2++;\n            }else{\n                long2--;\n            }\n        }\n        return false;\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n\n给你一个可能存在 重复 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为 `1`。  \n\n注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`。\n\n \n\n**示例 1：**\n\n```java\n输入：numbers = [3,4,5,1,2]\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：numbers = [2,2,2,0,1]\n输出：0\n```\n\n\n\n**提示：**\n\n- `n == numbers.length`\n- `1 <= n <= 5000`\n- `-5000 <= numbers[i] <= 5000`\n- `numbers` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转\n\n#### 题解\n\n##### 解题思路：二分查找\n\n一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：\n\n![fig1](查找算法/1.png)\n\n其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标。\n\n我们考虑数组中的最后一个元素 `x`：在最小值右侧的元素，它们的值一定都小于等于 `x`；而在最小值左侧的元素，它们的值一定都大于等于 `x`。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。\n\n在二分查找的每一步中，左边界为 `low`，右边界为 `high`，区间的中点为 `pivot`，最小值就在该区间内。我们将中轴元素 `numbers[pivot]` 与右边界元素 `numbers[high]` 进行比较，可能会有以下的三种情况：\n\n第一种情况是 `numbers[pivot]<numbers[high]`。如下图所示，这说明 `numbers[pivot]` 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。\n\n![fig2](查找算法/2.png)\n\n第二种情况是`numbers[pivot]>numbers[high]`。如下图所示，这说明 `numbers[pivot]`是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。\n\n![fig3](查找算法/3.png)\n\n第三种情况是 `numbers[pivot]==numbers[high]`。如下图所示，由于重复元素的存在，我们并不能确定`numbers[pivot]` 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 `numbers[high]` 是不是最小值，都有一个它的「替代品」`numbers[pivot]`，因此我们可以忽略二分查找区间的右端点。\n\n![fig4](查找算法/4.png)\n\n当二分查找结束时，我们就得到了最小值所在的位置。\n\n```java\nclass Solution {\n    public int minArray(int[] numbers) {\n        int start = 0;\n        int end = numbers.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(numbers[mid] > numbers[end]){\n                start = mid + 1;\n            }else if(numbers[mid] < numbers[end]){\n                end = mid;\n            }else{\n                end--;\n            }\n        }\n        return numbers[start];\n    }\n}\n```\n\n----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：LeetCode-Solution\n\n","tags":["算法","数组","二分查找"],"categories":["LeetCode学习","查找算法"]},{"title":"链表","url":"/2022/05/09/链表/","content":"\n### 例题一\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n**示例**\n\n```java\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n**限制：**\n\n```java\n0 <= 节点个数 <= 5000\n```\n\n<!--more-->\n\n#### 题解\n\n##### 解题思路一：迭代\n\n假设链表为 `1→2→3→∅`，我们想要把它改成`∅←1←2←3`。\n\n在遍历链表时，将当前节点的`next`指针改为指向前一个节点。由于该节点没有引用其前一个节点，因此需要事先准备一个空节点储存前一个节点，在更改引用之前还需要存储后一个节点。最后返回新的头节点。\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode p = null;      //用来储存倒叙\n        ListNode c = head;      \n        ListNode n = null;      \n        while(c != null){\n            n = c.next;\n            c.next = p;\n            p = c;\n            c = n;\n        }\n        return p;\n    }\n}\n```\n\n##### 解题思路二：递归\n\n- 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 `newHead` .\n- 此后，每次函数在返回的过程中，让当前结点的下一个结点的 `next`指针指向当前节点。\n- 同时让当前结点的 `next` 指针指向 `null` ，从而实现从链表尾部开始的局部反转\n- 当递归函数全部出栈后，链表反转完成。\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newHead;\n    }\n}\n```\n\n**递归较难理解，用笔演算一遍会好一点。**\n\n-----\n\n\n\n### 例题二\n\n请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。\n\n**示例1**\n\n![img](链表/e1.png)\n\n```java\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n```\n\n**示例2**\n\n![img](链表/e2.png)\n\n```java\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n```\n\n**示例3**\n\n![img](链表/e3.png)\n\n```java\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n```\n\n**示例 4：**\n\n```java\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n```\n\n **提示：**\n\n- `-10000 <= Node.val <= 10000`\n- `Node.random` 为空（null）或指向链表中的节点。\n- 节点数目不超过 1000 。\n\n#### 解题思路\n\n**回溯+哈希表**\n\n如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。\n\n具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。\n\n在实际代码中，我们需要特别判断给定节点为空节点的情况。\n\n```java\nclass Solution {\n    Map<Node, Node> cachedNode = new HashMap<Node, Node>();\n\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n        if (!cachedNode.containsKey(head)) {\n            Node headNew = new Node(head.val);\n            cachedNode.put(head, headNew);\n            headNew.next = copyRandomList(head.next);\n            headNew.random = copyRandomList(head.random);\n        }\n        return cachedNode.get(head);\n    }\n}\n```\n\n-----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd\n","tags":["算法","链表","哈希表"],"categories":["LeetCode学习","链表"]},{"title":"栈与队列","url":"/2022/05/04/栈与队列/","content":"\n### 例题一\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n**示例 1：**\n\n```java\n输入：\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[]]\n输出：\n[null,null,3,-1]\n```\n\n<!--more-->\n\n**示例 2：**\n\n```java\n输入：\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n输出：\n[null,-1,null,null,5,2]\n```\n\n**提示：**\n\n- `1 <= values <= 10000`\n- `最多会对 appendTail、deleteHead 进行 10000 次调用`\n\n#### 题解\n\n##### 解题思路\n\n- **栈无法实现队列功能:**\t栈为先进后出，队列为先进先出\n- **双栈可实现列表倒叙:**    用栈B元素实现对栈A的倒叙\n- **利用栈B删除队首元素**    B出栈相当于删除栈A的栈底元素，及队列首元素\n\n##### 函数设计\n\n- **加入队首`appendTail()`函数：**将数字val加入栈`A`即可。\n- **删除队尾`deleteHead()`:**分几种情况。\n  1. **当栈B不为空：**B中仍有已完成倒叙的元素，因此只需要返回B中的栈顶元素即可。\n  2. **否则，当A为空时：**当两个栈都为空时，无元素，返回-1。\n  3. **否则：**将栈A所有元素转移到栈B中，实现元素倒叙，并返回栈B元素的栈顶元素。\n\n##### 代码\n\n```java\nclass CQueue {\n    Stack<Integer> in,out;\n    public CQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void appendTail(int value) {\n        in.push(value);\n    }\n    \n    public int deleteHead() {\n        //当out栈不为空时，返回栈顶元素\n        if(!out.isEmpty()){\n            return out.pop();\n        }\n        //当in栈为空时，返回-1\n        if(in.isEmpty()){\n            return -1;\n        }\n        //当out栈为空时，将in栈中元素转到out栈中\n        while(!in.isEmpty()){\n            out.push(in.pop());\n        }\n        return out.pop();\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n \n\n**示例:**\n\n```java\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.min();   --> 返回 -2.\n```\n\n**提示：**\n\n各函数的调用总次数不超过 20000 次\n\n\n\n#### 题解\n\n##### 解题思路\n\n对于栈来说，如果一个元素 `a` 在入栈时，栈里有其它的元素 `b, c, d`，那么无论这个栈在之后经历了什么操作，只要 `a` 在栈中，`b, c, d` 就一定在栈中，因为在 `a` 被弹出之前，b, c, d 不会被弹出。\n\n因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 `a, b, c, d`。\n\n那么，我们可以在每个元素 `a` 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 `a`，我们就可以直接返回存储的最小值 `m`。\n\n##### 算法\n\n按照上面的思路，我们只需要设计一个数据结构，使得每个元素`a`与其相应的最小值 `m` 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。\n\n- 当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；\n\n\n- 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；\n- 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。\n\n##### 代码\n\n```java\nclass MinStack {\n    /** initialize your data structure here. */\n\n    Stack<Integer> A,B;\n    public MinStack() {\n        A = new Stack<>();\n        B = new Stack<>();\n    }\n    \n    public void push(int x) {\n        A.push(x);\n        if(B.empty() || B.peek() >= x){\n            B.push(x);\n        }\n    }\n    \n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n    \n    public int top() {\n        return A.peek();\n    }\n    \n    public int min() {\n        return B.peek();\n    }\n}\n\n```\n\n----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：LeetCode-Solution\n\n","tags":["算法","栈与队列"],"categories":["LeetCode学习","栈"]},{"title":"Hello World","url":"/2022/05/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n   <!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]