[{"title":"io流","url":"/2022/08/11/io流/","content":"\n# io流\n\n在整个io包中，唯一表示与文件本身有关的类就是File类。使用File类可以进行创建或删除文件等常用操作。\n\n![image-20220811101142677](io流/1.png)\n\n![image-20220811101258373](io流/2.png)\n\n**file的操作存在延迟：在每次程序执行完成后，文件不会立即创建修改或删除，存在一些延迟，是因为所有的操作都需要经过JVM完成。**\n\n\n\n### io流的分类\n\n![image-20220811101623083](io流/3.png)\n","tags":["io流","知识点"],"categories":["JAVA学习","java基础"]},{"title":"异常","url":"/2022/08/03/异常/","content":"\n# 异常\n\n### 一、异常的概述\n\n1. 异常是指程序执行过程中可能出现的非正常情况\n2. JAVA的异常机制提高程序健壮性和容错性\n3. 异常在JAVA中以类和对象的形式存在\n\n\n\n### 二、异常的分类\n\n<img src=\"异常/1.png\" alt=\"image-20220803191349152\" style=\"zoom:80%;\" />\n\n| **编译时异常** | Exception的直接子类    |\n| -------------- | ---------------------- |\n| **运行时异常** | **RuntimeException**   |\n| **受检异常**   | **CheckException**     |\n| **非受检异常** | **UnCheckedException** |\n\n**异常的区别：**\n\n1. Error是指不可处理的错误,直接退出JVM虚拟机；\n2. Exception是指可以处理的异常；\n3. 编译时异常是指在编写程序阶段,必须预先处理异常否则编译不通过；\n4. 运行时异常是指在编写程序阶段,即使不预先处理异常也可以编译通过。\n\n**==常见的异常类：==**\n\n- **NullPointerException：**当应用程序试图访问空对象时，则抛出该异常。\n- **SQLException**：提供关于数据库访问错误或其他错误信息的异常。\n- **IndexOutOfBoundsException**：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\n- **NumberFormatException**：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\n- **FileNotFoundException**：当试图打开指定路径名表示的文件失败时，抛出此异常。\n- **IOException**：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。\n- **ClassCastException**：当试图将对象强制转换为不是实例的子类时，抛出该异常。\n- **ArrayStoreException**：试图将错误类型的对象存储到一个对象数组时抛出的异常。\n- **IllegalArgumentException**：抛出的异常表明向方法传递了一个不合法或不正确的参数。\n- **ArithmeticException**：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。\n- **NegativeArraySizeException**：如果应用程序试图创建大小为负的数组，则抛出该异常。\n- **NoSuchMethodException**：无法找到某一特定方法时，抛出该异常。\n- **SecurityException**：由安全管理器抛出的异常，指示存在安全侵犯。\n- **UnsupportedOperationException**：当不支持请求的操作时，抛出该异常。\n- **RuntimeException**：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。\n\n\n\n### 三、异常的处理机制\n\n1. **异常上抛机制**\n   - 异常上抛机制是指发生异常时创建异常对象并将其上抛给其调用者；\n   - 异常上抛机制需要在方法声明位置上使用throws关键字。\n2. **异常捕获机制**\n   - 异常捕捉机制是指发生异常时创建异常对象并将其捕捉而不进行上抛；\n   - 异常捕捉机制需要使用try/catch语句块进行捕捉异常。\n3. **==注意事项==**\n   - 如果异常一直上抛到JVM虚拟机,那么JVM会终止程序执行[main方法中不建议使用异常上抛]；\n   -  异常上抛不允许后续代码执行,而异常捕捉允许后续代码执行\n\n\n\n### 四、异常对象的常用方法及异常机制的关键字\n\n#### 常用方法\n\n- exception.getMessage()：获取异常简单的描述信息；\n\n- exception.printStackTrace()：打印异常追踪的堆栈信息。\n\n#### 关键字\n\n##### 异常上抛机制：throw,throws\n\n1. throw表示在方法中手动抛出一个异常对象；\n2. throws在方法上声明,表示此方法在调用时必须处理异常。\n\n##### 异常捕获机制：try,catch,finally\n\n1. 关于try的注意事项\n   - try语句块不能单独出现；\n   - try语句块需要和catch语句块或者finally语句块联合使用。\n2. 关于catch的注意事项\n   - ；catch语句块的类型既可以是确切类型,也可以是其父类\n   - catch语句块可以写多个[遵循异常类型从小到大的顺序编写catch语句块]；\n   - 建议编写catch语句块时，精确到一个异常对应一个catch语句块[利于程序调试]。\n3. 关于finally的注意事项\n   - finally语句块中的代码必定执行；\n   - finally语句块通常用于释放或者关闭资源。\n\n\n\n### 五、自定义异常\n\n1. 类继承Exception或者RuntimeException\n2.  类提供无参构造器和带参构造器[形参为String类型]\n\n\n\n**==注意==**\n\n1. **final属于关键字** \n   - final修饰的变量不能重新赋值\n   - final修饰的类无法继承\n   - final修饰的方法无法覆盖\n2. finally属于关键字\n   -  finally和try联合使用在异常捕捉机制中\n   - finally语句块中的代码必定执行\n3. finalize属于标识符 \n   - finalize()属于Object类中的一个方法\n   - finalize()在执行对象被销毁之前由GC[垃圾回收器]调用\n   - finalize()主要用于清理本地对象或者确保释放某些非内存资源的补充","tags":["知识点","异常"],"categories":["JAVA学习","java基础"]},{"title":"多线程","url":"/2022/08/02/多线程/","content":"\n# 多线程\n\n### 什么是线程？\n\n#### 程序、进程和线程之间的区别？\n\n- 程序是静态的，进程是被执行的程序，进程就是动态的。\n- 进程是能分配资源和独立运行的，线程不能独立运行。\n- 一个进程能有多个线程，但至少有一个线程。\n- 进程无法共享内存，但线程可以：因为每个线程都分配独立的栈空间，但堆空间共享。\n\n#### 为什么说Java本身支持多线程？\n\n​\t\t因为java的线程由jvm管理，它如何映射到操作系统的线程由jvm实现决定。jvm采用一种轻量级线程，对内核线程做一层封装提供给用户线程调用，实现用户线程与操作系统线程形成一比一映射关系。\n\n#### 进程的三个特征\n\n1. **独立性：**进程是系统独立存在的实体，它可以拥有自己独立的资源。\n2. **动态性：**进程是正在系统活动中的指令集合。\n3. **并发性：**多个进程可以在单处理器上执行。\n\n\n\n### Java中创建线程的四种方法以及它们的区别\n\n1. **继承`Thread`类重写`run()`方法：**继承`Thread`类比较冗余，而且不支持多线程对同一全局变量进行访问。\n\n2. **实现`Runnable`接口，重写`run()`方法：**通过`Thread`含参构造函数创建对象。实现类也可以继承或实现其他类/接口，提高代码的灵活性，也方便多线程对同一全局变量进行访问。\n\n3. **实现`Callable`接口，重写`call()`方法：**需要使用`FutureTask`类包装，因为`FutureTask`类实现了`Runnable`接口。实现`Callable`方法可以抛出异常，而且可以有返回值以及带参数。继承`Thread`和实现`Runnable`接口不能。\n\n4. **当然也可以通过创建线程池来创建线程**\n\n   - 在经常创建和销毁、使用量特别大的资源，比如并发情况下的线程\n     对性能影响很大。\n\n   - JDK5.0提供了**ExecutorService接口**和**Executors工具类**\n\n     ![image-20220802193905003](多线程/1.png)\n\n\n\n### 线程状态\n\n1. **新建状态**\n\n   当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。\n\n2. **就绪状态**\n\n   一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的**`start()`方法**。当线程对象调用`start()`方法即启动了线程，`start()`方法创建线程运行的系统资源，并调度线程运行`run()`方法。当`start()`方法返回后，线程就处于就绪状态。\n\n   处于就绪状态的线程并不一定立即运行`run()`方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。\n\n3. **运行状态（running）**\n\n   当线程获得CPU时间后，它才进入运行状态，真正开始执行`run()`方法。\n\n4. **阻塞状态（blocked）**\n\n   所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。线程被堵塞可能是由下述五方面的原因造成的：\n\n   (1) 调用`sleep`(毫秒数)，使线程进入\"睡眠\"状态。在规定的时间内，这个线程是不会运行的。\n\n   (2) 用`suspend()`暂停了线程的执行。除非线程收到`resume()`消息，否则不会返回\"可运行\"状态。\n\n   (3) 用`wait()`暂停了线程的执行。除非线程收到`nofify()`或者`notifyAll()`消息，否则不会变成\"可运行\"（是的，这看起来同原因2非常相象，但有一个明显的区别是我们马上要揭示的）。\n\n   (4) 线程正在等候一些`IO`（输入输出）操作完成。\n\n   (5) 线程试图调用另一个对象的\"同步\"方法，但那个对象处于锁定状态，暂时无法使用。\n\n5. **死亡状态（dead）**\n\n   有三个原因会导致线程死亡：\n\n   - `run`方法正常退出而自然死亡；\n   - 一个未捕获的异常终止了run方法而使线程猝死；\n   - `stop()`方法。\n\n   为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用`isAlive`方法，如果是可运行或被阻塞，这个方法返回`true`；如果线程仍旧是`new`状态且不是可运行的，或者线程死亡了，则返回`false`。\n\n\n\n### 线程的生命周期\n\n​\t![image-20220802194148223](多线程/2.png)\n\n### 线程同步和线程互斥\n\n- **线程互斥：**多个线程之间共享同一资源时会发生线程互斥。\n- **线程同步：**某个线程需要另一线程完成工作才能正常运行，称为线程同步。\n\n**由线程同步互斥问题引出线程的安全问题**\n\n\n\n### 线程安全\n\n当多条线程访问同一共享资源时容易引发线程安全问题。\n\n1. 同步代码块：用`synchronized`关键字括起来的是同步代码块，在线程执行这块代码时，需要获得同步监视器的锁定，而若已被锁定，则只能等待。从而阻止两条线程对同一共享资源的并发访问。\n\n2. 同步方法：用`synchronized`关键字修饰的方法。原理与上相同。\n\n3. 同步锁（`Lock`）：`Lock`是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对`Lock`对象加锁，线程开始访问共享资源对象之前应先获得`Lock`对象。从而实现显式的加锁解锁。\n\n   `Java`提供了一种可重用锁`ReentranLock`，该锁对象会维持一个计数器来追踪`lock`方法的调用，从而可以对已经加锁的共享资源再次加锁。线程每次调用`lock`方法加锁后，必须显示调用`unlock`方法释放锁。\n\n#### 死锁\n\n当两个线程互相需要对方线程锁住的资源才能继续运行时会发生死锁，因为两个线程都在等待对方释放同步监视器。一旦出现死锁，整个程序既不会发生异常，也不会有任何提示，而是所有线程处于阻塞状态无法继续。\n\n\n\n### 守护线程/后台线程\n\n- **代表：**垃圾回收线程；\n- **特点：**守护线程内部是一个死循环守护线程随着所有用户线程的结束而结束；\n- **作用：**数据自动备份,垃圾回收……\n\n\n\n### 定时器机制\n\n- **特点：**间隔特定时间执行特定程序；\n- **定时器的实现 ：**\n  - Thread.sleep()方法\n  - java.util.Timer类\n  - SpringTask框架\n- **作用：**定时器和守护线程的联合使用实现数据自动备份\n\n\n\n### 线程协调运行（线程的通信）\n\n`Object`类提供`wait()`、`notify()`、`notifyAll()`三个方法来实现线程协调，这三个方法必须同步监视器对象调用。\n\n1. `wait()`：导致当前线程等待，直到其他线程调用`notify()`或`notifyAll()`来唤醒该线程。`Wait()`会释放对同步监视器的锁定。\n2. `notify()`：唤醒在等待的单个线程。如果等待的线程有复数个，则只是随机选择其中一个唤醒。\n   `notifyAll()`：唤醒所有在等待中的线程。\n\n使用Condition类控制线程通信\n\n- 当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。\n- Condition将同步监视器方法(wait(),notify()和notifyAll())分解成截然不同的对象，以便通过讲这些对象与Lock对象组合使用，为每个对象提供多个等待集(wait-set)。在这种情况下，Lock替代了同步方法或同步代码块，Condition替代了同步监视器的功能。\n- await():类似于隐式同步监视器上的wait()方法，导致当前线程等待，知道其他线程调用Condition的signal()方法或signalAll()方法来唤醒该线程。该await()方法有更多变体，如long awaitNanos(long nanosTimeout)、void awaitUninterruptible()、awaitUnitl(Date deadline)等，可以完成更丰富的等待操作。\n- signal():唤醒在此Lock对象上等待的单个线程，如果所有线程都在该Lock对象上等待，则会选择唤醒其中一个线程。选择是任意性的，只有当前线程放弃对该Lock对象的锁定后(使用await()方法),才可以执行被唤醒的线程。\n- signalAll():唤醒在此Lock对象上等待的所有线程。只有当前线程房钱对该Lock对象的锁定后，才可以执行被唤醒的线程。\n\n\n\n### ThreadLock\n\nThreadLock叫做**==线程变量==**，该变量是当前线程独有的变量。ThreadLock为每个线程创造一个副本，每个线程可以访问自己内部的副本变量。\n\n![image-20220811092913797](多线程/3.png)\n\n\n\n### JUC的三个辅助类\n\n#### CountDownLatch：减少计数\n\nCountDownLatch是JUC包中线程提同步器的一种实现，又称为倒计数器，通过让一个或多个线程等待其他线程结束后再继续自己的操作，类似加强版`join()`；\n\n- countDown：执行一次，计数器的数值-1。\n- await：等待计数器的值为0，才进行后面的操作。\n\n\n\n#### CyclicBarrier：循环栅栏\n\nCyclicBarrier允许一组线程相互等待，直到达到某个**公共屏障点**，等待线程才继续执行。而且这个Barrier（栅栏）在释放等待线程后可以复用，所以被称为循环栅栏。\n\n![image-20220811095018033](多线程/4.png)\n\n![image-20220811095058528](多线程/5.png)\n\n![image-20220811095117263](多线程/6.png)\n\n\n\n#### Semaphore：信号灯\n\n![image-20220811095220875](多线程/7.png)\n\n![image-20220811095258504](多线程/8.png)\n\n\n\n### 悲观锁与乐观锁\n\n**悲观锁：**\n\n悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;\n\n特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;\n\n**乐观锁：**\n\n乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);\n\n特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。\n\n\n\n### 读写锁\n\n读锁和写锁都会出现死锁的情况\n\n![image-20220811100240242](多线程/9.png)\n\n\n\n### 阻塞队列(BlockingQueue)控制线程通信\n\nJava5提供了一个BlockingQueue接口，虽然BlockingQueue也是Queue的子接口，但它的主要用途并不是作为容器，而是作为线程同步的工具。BlockingQueue具有一个特性：当生产者线程试图想BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。程序的两个线程通过交替想BlockingQueue中放入元素、取出元素，既可很好地控制线程的通信。\n\n![image-20220811100442724](多线程/10.png)\n\n","tags":["知识点","多线程"],"categories":["JAVA学习","java基础"]},{"title":"集合","url":"/2022/07/26/集合/","content":"\n# 集合\n\n- 为了保存数量不确定的数据，以及保存具有映射关系的数据（也被称为关联数组）。Java提供集合类，集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所有集合类 都位于java.util包下。 \n- Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架 的根接口，这两个接口又包含了一些子接口或实现类。\n\n**Collection集合**\n\n![image-20220726092647305](集合/1.png)\n\n**Map集合**\n\n![image-20220726092816359](集合/2.png)\n\n<!--more-->\n\n\n\n## Collection接口\n\n- Collection接口是List、set和Queur接口的父接口，该接口里定义的方法既可用于操作Set集合 ，也可用于操作List和Queue集合。 \n- Collection提供了大量添加、删除、访问的方法来访问集合元素。（其中也包含Collection类之间的互相增删查改）\n\n#### Iterator接口\n\nIterator接口是java集合框架的成员，主要用于Collection集合的遍历，因此Iterator对象也被称为迭代器。主要有以下3个方法：\n\n1. **boolean hasNext()**：如果被迭代的集合还元素没有被遍历，则返回true。\n2. **Object next()**：返回集合里下一个元素。\n3. **void remove()** ：删除集合里上一次next方法返回的元素\n\n\n\n### Set接口\n\n#### HashSet类\n\nHashSet是Set接口的典型实现，大多数时候使用Set集合就是使用这个实现类。HashSet按 Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。\n\n**HashSet的比较机制：**当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象 的hashCode值，然后根据该HashCode值取异或（^）获得hash值，由hash来决定该对象在HashSet中存储位置。如果有两个元素通过equals方法比较返回true，但它们的hashCode()方法返回值不相等，HashSet将会把它们存储在不同位置，也就可以添加成功。\n\n**HashSet的特征：**\n\n- 不能保证元素的排列顺序，顺序可能与元素的添加顺序不同，元素的顺序可能变化。\n- HashSet不是同步的，如果多个线程同时访问一个HashSet，如果有2条或者2条以上线程同时修改了HashSet集合时，必须通过代码来保证其同步。（**==线程不安全的==**）\n- 集合元素值可以是null。\n\n**HashSet的底层实现是HashMap对象**：对HashMap<k, v>的value值取固定Object对象，利用key值不可重复的特点进行存储。底层实现为拉链法与红黑树（**数据量小时使用拉链法，数据量大时使用红黑树**）\n\n\n\n#### LinkedHashSet类\n\nLinkedHashSet集合也是根据元素hashCode值来决定元素存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里元素时，HashSet将会按元素的添加顺序来访问集合里的元素。\n\nLinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能， 但在迭代访问Set里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。\n\n\n\n#### TreeSet类\n\n**TreeSet是SortedSet接口的唯一实现**，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态。与前面HashSet集合相比，TreeSet还提供了如下几个额外的方法：\n\n- Object first()：返回集合中的第一个元素。\n- Object last()：返回集合中的最末一个元素。\n- Object lower(Object e)：返回集合中位于指定元素之前的元素（即小于指定元素的最 大元素，参考元素不需要是TreeSet的元素）。 \n- Object higher(Object e)：返回集合中位于指定元素之后的元素（即大于指定元素的最 小元素，参考元素不需要是TreeSet的元素）。 \n- SortedSet subSet(fromElement, toElement)：返回此Set的子集合，范围从 fromElement（包含）到toElement（不包含）。\n- SortedSet headSet(toElement)：返回此Set的子集，由小于toElement的元素组成。\n- SortedSet tailSet(fromElement)：返回此Set的子集，由大于或等于fromElement的元 素组成。\n\n**TreeSet的排序：**TreeSet采用**红黑树**的数据结构对元素进行排序。TreeSet支持两种排序方法：自然排序和定制排序。\n\n**TreeSet的比较机制：**实现Comparator接口或传入该对象（传入对象需要内部类重写comparaTo方法）。Comparator是一个比较器。\n\n**TreeSet的底层实现为treeMap（使用红黑树）**\n\n\n\n### List接口\n\n- List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。\n- List作为Collection接口的子接口，当然可以使用Collection接口里全部方法。而且由于List是有序集合，因此List集合里包含了根据索引来操作集合元素的方法。\n\n#### ArrayList与Vector\n\n- ArrayList和Vector类都是基于数组实现的List类，所以ArrayList和Vector类封装了一个动态再分配的**Object[]数组**。每个ArrayList或Vector对象有一个capacity属性，这个capacity表示它们所封装的Object[]数组的长度。当向ArrayList或Vector中添加元素时，它们的capacity会自动增加。\n- ArrayList和Vector的显著区别是；**ArrayList是==线程不安全==的**，当多条线程访问同一个ArrayList集合时，如果有超过一条线程修改了ArrayList集合，则程序必须手动保证该集合的同步性。但**Vector集合则是==线程安全==的**，无需程序保证该集合的同步性。\n\n**ArrayList扩容：**\n\n- 当前长度为空或当前长度加二小于10时，扩容为10。\n- （当前长度加二  - 当前长度）> 当前长度的一半时，扩容为当前长度 + （当前长度加二 - 当前长度）\n- （当前长度加二  - 当前长度）< 当前长度的一半时，扩容为当前长度的1.5倍。\n\n**Vector扩容：**\n\n- 创建vector对象时不传入初始容量，则默认初始容量为10；\n- 创建vector对象时不传入增长容量，则默认增长容量为原长的两倍；\n- 创建vector对象时传入初始容量与增长容量，则扩容为原容量加增长容量；\n\n\n\n### Queue接口\n\nQueue用于模拟了队列这种数据结构，队列通常是指“先进先出”（FIFO）的容器。队列的头部保存在队列中存放时间最长的元素。队列的尾部保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。\n\n#### LinkedList类\n\n它是List接口的实现类——这意味着它是一个List集合，可以根据索引来随机访问集合中的元素。除此之外，LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双端队列。\n\nLinkedList不仅可以当成双端队列使用，也可以当成“栈”使用，因为该类里还包含了pop（出栈）和push（入栈）两个方法。除此之外，LinkedList实现了List接口，所以还被当成List使用。（与ArrayList与Vector实现机制不同，使用链表来存储元素）\n\n\n\n## Map接口\n\n\n\n### Hashtable\n\n- **Hashtable是一个==线程安全==的Map实现**（线程安全会影响读取效率）\n- 底层由拉链法实现，key与value都不能为空（**为空会抛空指针异常**）。\n- Hashtable中的映射不是有序的。底层实现与HashMap相同。\n- Hashtable初始容量为11，加载因子为0.75\n\n##### 添加机制\n\n1. 判断key是否为空，为空丢异常\n2. 如key不为空，则对key进行散列值，也就是调用hashCode方法。\n3. 经过对key的hash运算得出数组下标\n4. 根据下标对获取Entry，如为空，直接添加，如不为空，则代表当前位置已有元素，会进行判断当前key的hash与位置已有元素key的hash值是否相同，如果不相同，走添加方法，如当前key的hash与位置已有元素key的hash相同并且equals也相同，则此时将key与value替代掉此位置原有元素 并返回原有key\n5. put方法为synchronized\n\n##### 比较机制（与HashMap相同）\n\n##### 扩容机制\n\n- 长度直接扩充到原有两倍加一 ，如果扩充完之后大于长度允许的最大值，则长度变为最大长度\n- 进行重新计算散列值添加\n\n\n\n### HashMap\n\n- **HashMap是拉链法加红黑树结构，**key可以为空，但value不能为空**（所以HashMap可以且最多有一个空key）\n\n- **HashMap是==线程是不安全的==的Map实现**（效率高）\n- HashMap初始容量为16，加载因子为0.75\n\n##### 添加机制\n\n当我们选择put一个key与value时，程序会首先对key进行hashCode，然后再对hashCode进行异或(^)变成hash，也就是经常说得扰乱，作用是减少hashCode相同产生的碰撞。\n\n当hash与桶的hash相同时进行qut,如有此桶里面有值，则将新值放到前一个值的next中，依次类推。但是桶下面的链表只能拥有最多8个元素，如超过8个元素将采用红黑树的方式进行表达元素顺序，采用红黑树的目的是为了防止链表太长，会影响获取key时间，当红黑树的长度小于8时，便将红黑树转换为链表，在元素8以下的时候，链表的效率高于红黑树。\n\n##### 比较机制\n\n首先是获取key的hash与map中的hash对比，如没有，返回null，如命中，则获取第一个元素，进行equlas，如不相同，判断元素中的next是否为空，如不为空继续判断，如不相同，继续判断，当有相同时进行返回，如无返回null。\n\n\n\n### TreeMap\n\n- 与HashMap相比，TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。其中，可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序；\n\n- TreeMap底层实现为空黑树；\n\n- 当未实现 Comparator 接口时，key 不可以为null，否则抛NullPointerException 异常；\n\n  当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。\n\n- 其余与HashMap相似。\n\n\n\n**Collections.synchronizedList**(可以让集合线程安全)\n\n","tags":["知识点","集合","容器类"],"categories":["JAVA学习","java基础"]},{"title":"计算机网络","url":"/2022/07/12/计算机网络/","content":"\n# 计算机网络\n\n计算机网络：一些相互连接的计算机的集合。\n\n互联网：一些相互连接的计算机网络的集合（称为网络的网络）。\n\n#####  OSI七层模型：\n\n1. 物理层\n2. 数据链路层\n3. 网络层\n4. 传输层\n5. 会话层\n6. 表示层\n7. 应用层\n\n#####  各个层的中间设备：\n\n- 物理层中继系统：转发器\n- 数据链路层中继系统：网桥或桥接器\n- 网络层中继系统：路由器\n- 网桥和路由器的混合物：桥路器\n- 网络层以上的中继系统：网关\n\n\n\n## 计算机网络的带宽\n\n​\t\t计算机网络的带宽是指网络可通过的最高数据率，即每秒多少比特。\n\n**什么是宽带？**\n\n宽带线路：可通过较高数据率的线路。\n宽带是相对的概念，并没有绝对的标准。\n在目前，对于用户接入到因特网的用户线来说，每秒传送几个兆比特就可以算是宽带速率。\n\n\n\n### 什么是分组交换\n\n- 在发送端把要发送的报文分隔为较短的数据块\n-  每个块增加带有控制信息的首部构成分组（包）\n-  依次把各分组发送到接收端\n-  接收端剥去首部，抽出数据部分，还原成报文\n\n![image-20220712144505982](计算机网络/4.png)\n\n**分组交换的特点：**\n\n- 高效    动态分配传输带宽，对通信链路是逐段占用。 \n- 灵活    以分组为传送单位和查找路由。\n- 迅速    不必先建立连接就能向其他主机发送分组；充分使用链路的带宽。\n- 可靠    完善的网络协议；自适应的路由选择协议使网络有很好的生存性。  \n\n \n\n\n\n## 网络互连\n\n- 当主机 A 要向另一个主机 B 发送数据报时，先要检查目的主机 B 是否与源主机 A 连接在同一个网络上。如果是，就将数据报**直接交付**给目的主机 B 而不需要通过路由器。\n- 但如果目的主机与源主机 A 不是连接在同一个网络上，则应将数据报发送给本网络上的某个路由器，由该路由器按照转发表指出的路由将数据报转发给下一个路由器。这就叫作**间接交付**。\n\n\n\n### 典型的路由器的结构\n\n<img src=\"../../../编程学习/博客内容/image/image-20220712150545698.png\" alt=\"image-20220712150545698\" style=\"zoom:67%;\" />\n\n\n\n### 协议\n\n​\t\t在计算机网络中，协议(protocol)是通信双方必须严格遵守的规则。协议精确地规定在网络通信中使用的各种控制信息的格式、意义以及各种事件出现的先后顺序。协议在计算机网络中起着非常重要的作用。\n\n<!--more-->\n\n#### 分层次的网络体系结构\n\n**五层原理体系结构：**\n\n![image-20220712141744242](D:\\Blog\\source\\_posts\\计算机网络\\1.png)\n\n**TCP/IP的体系结构**\n\n<img src=\"D:\\Blog\\source\\_posts\\计算机网络\\2.png\" alt=\"image-20220712141927892\" style=\"zoom:80%;\" />\n\n**数据传输流程：**\n\n![image-20220712142038449](D:\\Blog\\source\\_posts\\计算机网络\\3.png)\n\n\n\n\n\n#### IP协议（Internet Protocol网际协议）（网络层）\n\n**IPv4有32个bit位；**\n\n**IPv6有128个bit位；**\n\n​\t\t因特网的 IP 协议最重要，它为分组在互连网中的发送、传输和接收制定了详尽的规则。与 IP 协议配套使用的还有四个协议：\n\n- 地址解析协议 ARP \n     (Address Resolution Protocol)\n- 逆地址解析协议 RARP\n      (Reverse Address Resolution Protocol)\n- 因特网控制报文协议 ICMP\n      (Internet Control Message Protocol)\n- 因特网组管理协议 IGMP\n      (Internet Group Management Protocol) \n\n![image-20220712151329556](计算机网络/7.png)\n\n**IP网络的重要特点**\n\n- 每一个分组独立选择路由。\n- 发往同一个目的地的分组，后发送的有可能先收到（即可能不按顺序接收）。\n- 当网络中的通信量过大时，路由器就来不及处理分组，于是要丢弃一些分组。\n- 因此， IP 网络不保证分组的可靠地交付。\n- IP 网络提供的服务被称为：尽最大努力服务(best effort service)\n\n​\t\t计算机通信是在计算机上运行的程序之间的通信。因为通信必须是可靠的，所以实现可靠通信最终应当是让计算机程序之间的通信可靠。因特网认为，IP 协议没有必要提供可靠服务（这样做可以使网络简单、灵活性好、价格便宜）。在计算机中增加 TCP 协议就可以实现计算机程序之间的可靠通信。因此引出TCP协议。\n\n\n\n##### IP 数据报的格式\n\n![image-20220714193658752](计算机网络/9.png)\n\n**不存在粘包现象，只要确定报文前20个字节就可以确定报文长度**\n\n\n\n##### IP 地址的编址方法\n\n分类的 IP 地址。这是最基本的编址方法.\n\n​\t\t![image-20220712151944698](计算机网络/8.png)\n\n保留地址（私有地址）：\n\n- A类：10.0.0.0-10.255.255.255\n- B类：172.16.0.0-172.31.255.255\n- C类：192.168.0.0-192.168.255.255\n\n1. 网络全0表示表示本网络。\n2. 主机号为全0表示本网络地址，全1是当前子网的广播地址\n3. 127.0.0.1表示本主机的环回地址，ping该地址可以验证本主机网络驱动是否安装。ping网关可以验证本主机是否已连接上网络。\n\n其中网络层及以上使用IP地址，链路层及以下使用硬件地址（及MAC地址）。IP地址可以屏蔽物理地址。\n\n- 子网的划分。这是对最基本的编址方法的改进，其标准[RFC 950]在 1985 年通过。\n\n$$\nIP地址 = {<网络号>, <子网号>, <主机号>}\n$$\n​\t![image-20220714195408747](计算机网络/10.png)\n\n**IP地址与子网掩码取&(与)可以得到网络地址**\n\n**主机位全为0的时候，此IP地址表示网络号代表网络段本身，也就是本网段的代表，常用在路由器的路由表中**\n\n**主机位全为1的时候，此IP地址表示广播地址，代表的是整个网段中的所有主机，即可以向该网段中所有的主机发送数据包**\n\n\n\n- 构成超网。这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。\n\n\n\n##### 网络互联：\n\n- 专用地址网络：A类1个，B类16个，C类256个。专用地址不能与因特网连接，需要代理IP。\n- 内联网与外联网通信遇到代理IP，及网络地址转换NAT。\n\n\n\n#### TCP协议（应用层）\n\n​\t\tTCP 是 Transmission Control Protocol 的缩写，中文译名是传输控制协议。TCP 协议驻留在用户计算机中，它的作用是保证应用程序之间端到端的可靠通信。\n\n##### 端口的概念\n\n- 端口就是运输层服务访问点 TSAP。\n- 端口的作用就是让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。\n- 从这个意义上讲，端口是用来标志应用层的进程。\n\n端口具有本地意义，其中1k以内为熟知端口（例如  web项目：80；mysql：3306；tomcat：8080等）\n\n\n\n##### TCP协议的特点：\n\n- TCP是传输层协议。\n- TCP是全双工协议（就像打电话一样，在接收端接收信息时也可以使用同一条连接向发送端发送数据，叫全双工）。\n- 是一种可靠传输（什么机制保证它可靠：超时重传、收到回复）。\n- 是端到端的、面向连接的通信（TCP通信前需要建立连接，之后的通信都通过这条连接，所以需要维持连接）。\n- 当网络通信量过大，TCP会让发送端放慢发送数据。叫流量控制（拥塞避免算法）。\n- TCP的速度由接收端决定，而不是发送端决定。\n\n\n\n##### TCP协议数据报格式\n\n![image-20220714204410504](计算机网络/11.png)\n\n- **序号seq：**seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。\n- **确认号ack：**ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。\n- **紧急比特URG**：当URG=1，表明紧急字段有效，它表示该报文段有紧急数据，应尽快传送。\n- **确认比特ACK：**只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。\n- **推送比特PSH：**接收TCP收到推送比特置1的报文段，就尽快交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。\n- **复位比特RST：**当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。\n- **同步比特SYN：**同步比特SYN置为1，就表示这是一个连接请求或连接接受报文。\n- **终止比特FIN：**用来释放一个连接。当FIN=1时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。\n- **窗口：**客户端限制服务器发送的数据量。\n\n**重点：**\n\n**==TCP三次握手建立TCP连接：==**\n\n![图片来自网络，侵权请告知，会及时删除](计算机网络/13.png)\n\n**第一次握手：**客户端向服务端发送一个SYN段（在 TCP 标头中 SYN 位字段为 **1** 的 TCP/IP 数据包），该段中也包含客户端的初始序号seq(Sequence number = x)。\n\n<!--SYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接-->\n\n**第二次握手：**服务器返回客户端 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP/IP 数据包)， 该段中包含服务器的初始序号seq(Sequence number = y)；同时使 ack(Acknowledgment number = x + 1)来表示确认已收到客户端的 SYN段(Sequence number = x)。\n\n<!--ACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包-->\n\n**第三次握手：**客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 **1** 的 TCP/IP 数据包), 该段中包含服务器的初始序号seq(Sequence number = x + 1)，同时使ack(Acknowledgment number = y + 1)来表示确认已收到服务器的 SYN段序号seq(Sequence number = y)。\n\n**==TCP四次挥手释放TCP连接：==**\n\n![图片来自网络，侵权请告知，会及时删除](计算机网络/14.png)\n\n**第一次挥手：**客户端发送一个FIN段（在 TCP 标头中 FIN位字段为 **1** 的 TCP/IP 数据包），该段中也包含客户端的初始序号seq(Sequence number = u)。用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态。\n\n<!--FIN 是“终止”的缩写。 FIN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间释放连接-->\n\n**第二次挥手**：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器进入CLOSE_WAIT状态。\n\n**第三次挥手：**服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。\n\n**第四次挥手：**客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成四次挥手\n\n\n\n**TCP数据报文存在粘包现象，解决办法是在选项里添加报文总长度。**\n\n**TCP 协议的主要功能**\n\n- TCP 给要传送的每一个字节的数据都进行编号。\n  - 接收端在收到数据后必须向发送端发送确认信息。\n  - 若发送端在规定的时间内没有收到对方的确认，就重传这部分数据。\n- 当网络中的通信量过大时，TCP 就告诉发送端要放慢发送数据。这叫做流量控制。\n  - 接收端窗口 rwnd     这是接收端根据其目前的接收缓存大小所许诺的最新的窗口值，是来自接收端的流量控制。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。\n  - 拥塞窗口 cwnd (congestion window)    是发送端根据自己估计的网络拥塞程度而设置的窗口值，是来自发送端的流量控制。\n\n\n​\t\tTCP/IP是因特网的核心协议，分组在因特网中传送要使用 IP 协议。计算机数据传输的可靠性由 TCP 协议来保证。通常用 TCP/IP 这样的记法表示以 TCP 和 IP 为核心的协议族。\n\nTCP可靠通信的原理：\n\n- 超时重传\n- 按字节累加传输\n\n\n\n#### UDP协议\n\nUDP是**传输层**的协议，功能即为在IP的数据报服务之上增加了最基本的服务：**复用**和**分用**以及**差错检测**。\n\nUDP提供**不可靠**服务，具有TCP所没有的**优势**：\n\n- UDP**无连接**，时间上**不存在建立连接需要的时延**。空间上，TCP需要在端系统中**维护连接**状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。\n- **分组首部开销小**，TCP首部20字节，UDP首部8字节。\n- **UDP没有拥塞控制**，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，**能容忍一些数据的丢失，但是不能允许有较大的时延**（比如实时视频，直播等）\n- UDP**提供尽最大努力的交付**，不保证可靠交付。所有维护传输可靠性的工作需要用户在**应用层**来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。\n- UDP是**面向报文**的，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。\n\n##### UDP数据报报文头部：\n\n![image-20220803190345301](计算机网络/15.png)\n\n\n\n#### 打开一个网站需要经历哪些过程？\n\n##### 一、页面加载\n\n1.  在浏览器输入地址回车之后，浏览器进行dns解析：浏览器自身缓存（Chrome浏览器通过输入：chrome://net-internals/#dns 打开DNS缓存页面）-> 搜索hosts文件和操作系统缓存 -> 域名解析服务器发送解析请求 -> 域名解析服务器也没有该域名的记录，则开始递归+迭代解析(树形搜索的过程) -> 获取域名对应的IP后，一步步返回给浏览器。\n2. 通过握手协议建立起TCP连接并发送http请求：浏览器会选择一个大于1024的本机端口向目标IP地址的80端口发起TCP连接请求。经过标准的TCP握手流程，建立TCP连接 -> 按照HTTP协议标准发送一个索要网页的请求。\n\n##### 二、静态资源加载（一般使用CDN）\n\n在浏览器解析页面内容的时候，会发现页面引用了其他未加载的image、css文件、js文件等静态内容，浏览器根据url向提供静态资源的服务器请求加载该url下的图片内容等。本质上是浏览器重新开始第一部分的流程。\n","tags":["知识点","计算机网络","协议"],"categories":["JAVA学习","计算机网络"]},{"title":"类加载与反射","url":"/2022/07/08/类加载与反射/","content":"\n# 类加载\n\n​\t\t不管Java程序有多么复杂、该程序启动了多少个线程，它们都处于该Java虚拟机进程里。同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。当系统出现以下几种情况时，JVM进程将被终止：\n\n-  程序运行到最后正常结束。\n\n- 程序运行到使用System.exit()或Runtime.getRuntime().exit()代码结束程\n\n序。\n\n- 程序执行过程中遇到未捕获的异常或错误而结束。\n\n- 程序所在平台强制结束了JVM进程。\n\n<!--more-->\n\n\n\n### 类加载\n\n- 当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过**加载、连接、初始化**三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。\n- 类加载指的是将类的class文件读入内存，并为之创建一java.lang.Class对象，也就是说当程序使用任何类时，系统都会为之建立一个java.lang.Class对象。\n\n\n\n<img src=\"../../../编程学习/博客内容/image/image-20220708204706434.png\" alt=\"image-20220708204706434\" style=\"zoom: 80%;\" />\n\n注解：\n\n- 方法区：方法区用来存储被虚拟机类加载器加载的类的信息、常量、静态变量、编译后的字节码等数据。\n\n​\t\t\t                                            <img src=\"../../../编程学习/博客内容/image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjZHhzaGVuZ3Blbmc=,size_16,color_FFFFFF,t_70.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n- 堆：堆主要是用来存放java对象的，栈主要是用来存放对象引用的。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。\n- 栈：存放的是基本数据类型和堆中对象的引用。\n- PC寄存器：pc寄存器是用来存储指向下一条要执行指令的地址，即下一条要执行的代码，由执行引擎来读取下一条指令。\n- 本地方法栈：本地方法栈英文全称 Native Method Stack 是存放本地方法的地方。(本地方法由native修饰，由c或c++编写)\n\n### 类的连接\n\n​\t\t当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段将会负责把类的二进制数据合并到JRE中。类连接又可分为如下三个阶段：\n\n- 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。\n- 准备：类准备阶段则负责为类的静态属性分配内存，并设置默认初始值。\n- 解析：将类的二进制数据中的符号引用替换成直接引用。\n\n**其中静态代码块在准备阶段执行，而不是类的初始化时执行。**\n\n### 类的初始化\n\n​\t\t在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对静态属性进行初始化。在Java类中对静态属性指定初始值有两种方式：\n\n- 声明静态属性时指定初始值；\n- 使用静态初始化块为静态属性指定初始值。\n\n步骤：\n\n- 假如这个类还没有被加载和连接，程序先加载并连接该类。\n- 假如该类的直接父类还没有被初始化，则先初始化其直接父\n  类。\n- 假如类中有初始化语句，则系统依次执行这些初始化语句。\n\n### 类加载器\n\n- 类加载器负责将.class文件（可能在磁盘上，也可能在网络上）加载到内存中，并为之生成对应的java.lang.Class对象。\n\n- 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构：\n\n  - Bootstrap ClassLoader：根类加载器。\n\n  - Extension ClassLoader：扩展类加载器。\n\n  - System ClassLoader：系统类加载器\n\n\n\n# 反射\n\n​\t\t在 Java 运行时环境中，对于任意一个类，任意一个对象。可以通过反射机制，动态获取动态获取类的信息，以及动态调用对象的方法。\n\n### 通过反射获取Class对象\n\n- 使用Class类的forName()静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名（必须添加完整包名）。\n- 调用某个类的class属性来获取该类对应的Class对象。例Person.class将会返回Person类对应的Class对象。\n- 调用某个对象的getClass()方法，该方法是java.lang.Object类中的一个方法，所以所有Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。\n- 调用基本类型包装类的TYPE方法，该方法可以获得基本类型包装类的Class对象。\n\n### 从Class中获取信息\n\n- 获取构造器 \n\n\n- 访问Class对应的类所包含的方法\n\n- 访问Class对应的类所包含的属性（Field）  访问Class对应的类上所包含的注释。\n- 访问该Class对象对应类包含的内部类。\n- 访问该Class对象对应类所在的外部类。\n- 访问该Class对象所对应类所继承的父类、所实现的接口等。\n\n**重点接口：**\n\n1. Member接口：该接口可以获取有关类成员（域或者方法）后者构造函数的信息。\n2. AccessibleObject类：该类是域(field)对象、方法(method)对象、构造函数(constructor)对象的基础类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。\n3. Array类：该类提供动态地生成和访问JAVA数组的方法。\n4. Constructor类：提供一个类的构造函数的信息以及访问类的构造函数的接口。\n5. Field类：提供一个类的域的信息以及访问类的域的接口。\n6. Method类：提供一个类的方法的信息以及访问类的方法的接口。\n\n#### 获取类的Fields\n\n- `public Field getField (String name)`：返回一个Field对象，它反映此Class对象所表示类或接口的指定公共成员字段（public修饰的指定属性）。\n- `public Field[] getFields() `：返回一个包含某些 Field 对象的数组，这些对象反映此 Class对象所表示的类或接口的所有可访问公共字段（public修饰的所有属性）。\n- `public Field getDeclaredField(Stringname)`：返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段（无视修饰符）。\n- `public Field[] getDeclaredFields()`：返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段（无视修饰符）。\n\n#### 获取类的Method\n\n- `public Method getMethod(String name,Class<?>... parameterTypes)`：返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法\n- `public Method[] getMethods()`：返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。\n- `public Method getDeclaredMethod(Stringname,Class<?>... parameterTypes)`：返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。\n- `public Method[] getDeclaredMethods()`：返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法,包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\n\n#### 获取类的Constructor\n\n- `public Constructor<T> getConstructor(Class<?>... parameterTypes)`：返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。\n- `public Constructor<?>[] getConstructors() `：返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法。\n- `public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)`：返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。\n- `public Constructor<?>[] getDeclaredConstructors()`：返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法\n\n#### 新建类的实例\n\n调用无自变量ctor（无参）：\n\n- 调用类的Class对象的newInstance方法，该方法会调用对象的默认构造器，如果没有默认构造器，会调用失败.\n- 调用默认Constructor对象的newInstance方法。需先获取类的Constructor对象。\n\n调用带参数ctor（有参）：\n\n- 调用带参数Constructor对象的newInstance方法。需先获取类的Constructor对象。","tags":["知识点","类加载","反射"],"categories":["JAVA学习","java基础"]},{"title":"数据库","url":"/2022/07/05/数据库/","content":"\n# 数据库\n\n数据库结构采用关系型数据库\n\n### 什么是关系型数据库？\n\n​\t\t关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。\n\n#### 关系型数据库设计原则\n\n遵循ER模型和三范式\n\nER模型：\n\n* E    entity   代表实体的意思      对应到数据库当中的一张表          \n* R    relationship 代表关系的意思 \n\n三范式：\n\n- 1NF：第一范式。要求每一属性列不可再分。主属性：是唯一属性\n- 2NF：第二范式。在第一范式之上，所有的非主属性都依赖主属性。（隐含信息，一物一表）\n- 3NF：第三范式。在第二范式基础上，不存在传递依赖。\n\n<!--more-->\n\n\n\n##### 约束\n\n在SQL SERVER中，对于基本表的约束分为列约束和表约束。\n\n- 列约束是对某一个特定列的约束，包含在列定义中，直接跟在该列的其他定义之后，用空格分隔，不必指定列名；\n- 表约束与列定义相互独立，不包括在列定义中，通常用于对多个列一起进行约束，与列定义用’,’分隔，定义表约束时必须指出要约束的那些列的名称。完整性约束的基本语法格式为：\n\n**[ CONSTRAINT <约束名> ] <约束类型>**\n\n**约束类型：**\n\n- NULL/NOT NULL（是否非空）\n\n- UNIQUE约束（唯一）\n\n- PRIMARY KEY约束（主键）\n\n- FOREIGN KEY约束（外键）\n\n- CHECK约束（检查字段所允许范围）\n\n  \n\n**主键（主属性）**\n\n作用：可以保证数据的实体完整性，如果主属性不完整，实体不会入库。\n\n**外键（起关联作用）**\n\n作用：连接两个表的非主属性。保证参照完整性。\n\n![image-20220706091941299](数据库/3.png)\n\n##### 索引\n\n**索引的分类**\n\n1.  按照索引记录的存放位置可分为聚集索引与非聚集索引\n   - **聚集索引**：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。\n   - **非聚集索引**：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。\n2. 唯一索引的概念\n   - **唯一索引**表示表中每一个索引值只对应唯一的数据记录，\n   - 这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。\n   - 当表中有被设置为**UNIQUE**的字段时，SQL SERVER会自动建立一个**非聚集的唯一性索引**。\n   - 而当表中有**PRIMARY KEY**的字段时，SQL SERVER会在PRIMARY KEY字段建立**一个聚集索引**。\n3. 复合索引的概念\n   - 复合索引是将两个字段或多个字段组合起来建立的索引，而单独的字段允许有重复的值。\n\n**建立索引：**\n\n- 建立索引的语句是CREATE INDEX，其语法格式为：\n  \t\tCREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名> (<列名> [次序] [{,<列名>}] [次序]…)\n- 改变表中的数据（如增加或删除记录）时，索引将自动更新。\n  索引建立后，在查询使用该列时，系统将自动使用索引进行查询。 \n-  索引数目无限制，但索引越多，更新数据的速度越慢。对于仅用于查询的表可多建索引，对于数据更新频繁的表则应少建索引。\n\n**删除索引：**\n\n- 建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。\n- 删除索引的语句是DROP INDEX，其语法格式为：\n  \t\t\tDROP INDEX 数据表名.索引名\n\n\n\n**实体图**\n\n由矩形（实体）、学号（属性）、菱形（关联：使用1与m表示对应关系）\n\n\n\n**关键词**\n\nRDBMS：关系型数据库管理系统（如：mysql sqlserver oreacl)\n\nDBA:数据库管理者\n\nC/S模式：可视化界面通过网络协议（通常为TCP协议）连接server\n\n\n\n**数据类型**\n\n<img src=\"数据库/4.png\" alt=\"image-20220706093141235\" style=\"zoom:67%;\" />\n\n<img src=\"数据库/5.png\" alt=\"image-20220706093203941\" style=\"zoom:67%;\" />\n\n<img src=\"数据库/6.png\" alt=\"image-20220706093224759\" style=\"zoom:67%;\" />\n\n<img src=\"数据库/7.png\" alt=\"image-20220706093243616\" style=\"zoom:67%;\" />\n\n\n\n### SQL语言\n\nSQL语言支持数据库的三级模式结构。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。 \n\n<img src=\"数据库/2.png\" alt=\"image-20220705205933811\" style=\"zoom:67%;\" />\n\n\n\n#### 简单的SQL示例\n\n查看数据库：`SHOW DATABASES;`\n\n使用数据库：`USE <数据库名>`\n\n创建表： `CREATE TABLE <表名>(<列定义>[{，<列定义>|<表约束>}])`\n\n查看表结构：`DESC <表名>`\n\n\n\n##### SQL数据查询\n\n**SELECT命令的格式与基本使用：**\n\n`SELECT〈列名〉[{，〈列名〉}]\nFROM〈表名或视图名〉[{，〈表名或视图名〉}]\n[WHERE〈检索条件〉]\n[GROUP BY <列名1>[HAVING <条件表达式>]]\n[ORDER BY <列名2>[ASC|DESC]];`\n\n**注意**\n\n- 查询的结果是仍是一个表。\n- SELECT语句的执行过程是:\n  - 根据WHERE子句的检索条件，从FROM子句指定的基本表或视图中选取满足条件的元组，再按照SELECT子句中指定的列，投影得到结果表。\n  - 如果有GROUP子句，则将查询结果按照<列名1>相同的值进行分组。\n  - 如果GROUP子句后有HAVING短语，则只输出满足HAVING条件的元组。\n  - 如果有ORDER子句，查询结果还要按照<列名2>的值进行排序。\n\n###### 条件查询\n\nWHERE中较常用的运算符：\n\n<img src=\"数据库/8.png\" alt=\"image-20220706095309061\" style=\"zoom:67%;\" />\n\n常用库函数：\n\n<img src=\"数据库/9.png\" alt=\"image-20220706095613087\" style=\"zoom:67%;\" />\n\n###### 分组查询\n\nGROUP BY子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。\n\n**注意：**当在一个SQL查询中同时使用WHERE子句，GROUP  BY 子句和HAVING子句时，其顺序是WHERE－GROUP  BY－ HAVING。\n\n###### 查询排序\n\n当需要对查询结果排序时，应该使用ORDER BY子句\nORDER BY子句必须出现在其他子句之后。排序方式可以指定，DESC为降序，ASC为升序，缺省时为升序\n\n###### 数据表链接及连接查询\n\n- 数据表之间的联系是通过表的字段值来体现的，这种字段称为连接字段。\n- 连接操作的目的就是通过加在连接字段的条件将多个表连接起来，以便从多个表中查询数据。\n- 前面的查询都是针对一个表进行的，当查询同时涉及两个以上的表时，称为连接查询。\n- 表的连接方法有两种：\n  - 方法1：表之间满足一定的条件的行进行连接，此时FROM子句中指明进行连接的表名，WHERE子句指明连接的列名及其连接条件。\n  - 方法2：利用关键字JOIN进行连接。\n\n###### 子查询\n\n- 在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询，包含子查询的语句称为父查询或外部查询。\n- 嵌套查询可以将一系列简单查询构成复杂查询，增强查询能力。\n- 子查询的嵌套层次最多可达到255层，以层层嵌套的方式构造查询充分体现了SQL“结构化”的特点。\n- 嵌套查询在执行时由里向外处理，每个子查询是在上一级外部查询处理之前完成，父查询要用到子查询的结果。\n\n\n\n##### SQL数据更新\n\n**插入记录：**\n\n`INSERT INTO <表名>[(<列名1>[,<列名2>…])] VALUES(<值>)`\n\n\n\n**修改记录：**\n\n`UPDATE <表名>\nSET <列名>=<表达式> [,<列名>=<表达式>]…\n[WHERE <条件>]`\n\n\n\n**删除记录：**`DELETE \nFROM<表名>\n[WHERE <条件>]`**\n\n","tags":["知识点","数据库"],"categories":["JAVA学习","数据库"]},{"title":"类的学习","url":"/2022/06/26/类/","content":"\n### 面向对象编程\n\n**什么是面向过程**\n\n面向过程（Procedure-Oriented Programming，简称POP）是一种编程模型，由一系列要执行的计算步骤组成，通常采用自上而下、顺序执行的方式。\n\n**什么是面向对象**\n\n面向对象编程（Object-oriented programming，简写：OOP）是一种计算机编程模型，它围绕数据或对象而不是功能和逻辑来组织软件设计，更专注于对象与对象之间的交互，对象涉及的方法和属性都在对象内部。说的更底层一点就是面向对象是一种依赖于类和对象概念的编程方式。\n\n**面向对象和面向过程的区别**\n\n|        | 面向过程                 | 面向对象               |\n| ------ | ------------------------ | ---------------------- |\n| 侧重点 | 功能的实现步骤和因果关系 | 对象之间的组合关系     |\n| 缺点   | **耦合度高、扩展力低**   | **耦合度低、扩展力高** |\n| 优点   | 快速开发                 | 需要对象提取和模型建立 |\n\n\n\n<!--more-->\n\n\n\n#### 面向对象的三大特性\n\n**封装**\n\n封装是面向对象方法的核心思想之一。它有两个含义：\n\n- 一是指把对象的属性和行为看成为一个密不可分的整体，将这两者“**封装**”在一个不可分割的独立单位（即对象）中。\n- 另一层含义指“**信息隐蔽**”，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，而另一些属性或行为，则不允许外界知晓；或只允许使用对象的功能，而尽可能隐蔽对象的功能实现细节。\n\n**继承**\n\n子类可以继承父类的属性（数据）和功能（操作）。继承是面向对象方法中的重要概念，并且是提高软件开发效率的重要手段。\n\n**多态**\n\n- 多态:编译时是一种形态,运行时是另一种形态。\n- 多态是指父类型引用指向子类型对象，包括编译阶段和运行阶段。\n- 多态的作用:解耦合\n- OCP原则:对扩展开放，对修改关闭\n\n程序中允许出现重名现象。 Java 语言中具有操作名称的多态和继承有关的多态。\n\n**类的四大特性：**封装性，继承性，多态性，抽象性。\n\n\n\n#### 类\n\n类是java程序设计的基本单位，java的源文件有若干个书写形式相互独立的类构成。\n\n类的两个基本成员：\n\n- 成员变量（属性）\n- 成员方法（函数功能）\n\n**类的声明**\n\n**修饰符 class 类名{**\n\n​\t\t**类体的内容**\n\n**}**\n\n\n\n#### 抽象类\n\n抽象类的概述：抽象类是指一种将**类与类之间的共同特征**提取出来的类\n\n抽象类的实例化问题：\n\n-  抽象类无法实例化\n- 抽象类具有构造方法,子类通过关键字super调用父类构造方法用于初始化当前对象的父类特征\n- 非抽象子类继承抽象类,子类可以实例化\n\n抽象方法：\n\n1. 抽象方法是指没有实现的方法,即没有方法体的方法\n2. 抽象方法的作用[确保特定服务的提供]\n   - 所有类都期望提供某种特定服务,但是方法的实现方式会根据类的不同而不同。\n   - 父类定义抽象方法强制所有子类实现,以此确保所有子类都能够提供特定服务。\n3. 语法机制\n   - [修饰符列表] abstract [返回值类型] 方法名(); \n4. 特点\n   - 抽象方法没有大括号,以分号结尾\n   - 修饰符列表中有abstract关键字\n   - 抽象类中不一定具有抽象方法\n   - 抽象方法只会出现在抽象类或者接口中\n   - 非抽象子类继承抽象类,子类必须实现抽象方法\n\n\n\n#### 接口\n\n接口的概述\n\n- 接口是指类与类之间的所有行为动作的抽象集合\n- 接口属于特殊的抽象类[抽象类是半抽象的,而接口是完全抽象的]\n\n接口的作用**[解耦合]**\n\n- 面向接口编程的优点:降低耦合度,提高扩展力\n\n-  接口和多态机制联合使用可以达到降低程序耦合度的效果\n\n- 接口可以将调用者和实现者解耦合\n\n  -  调用者面向接口调用\n  -  实现者面向接口实现\n\n  \n\n\n\n#### 关键字\n\n**final：常量修饰符**\n\n如果一个成员变量修饰为final，就是常量，常量的名字习惯用大写字母\n\n**可修饰的对象：**\n\n- 属性：修饰属性后，属性为常量，只能赋值一次\n- 方法：修饰方法后，方法不能被重写\n- 类：修饰类后，类不能被继承\n\n\n\n**static：静态修饰符**\n\n方法声明中用关键字static修饰的称作类方法或静态方法，不用static修饰的\n\n称作实例方法。\n\n**可修饰的对象**\n\n- 属性：修饰属性后，属性为静态变量（也叫类变量），可以用对象调用，也可以用类调用\n- 方法：修饰方法后，方法为静态函数，只能调用静态变量，不能使用this调用\n\n**一个类中的方法可以互相调用：实例方法可以调用该类中实例方法或类方法；类方法只能调用该类的类方法，不能调用实例方法；**\n\n如：main函数为静态函数，只能调用静态函数。","tags":["类","面向对象"],"categories":["JAVA学习","java基础"]},{"title":"搜索与回溯算法三","url":"/2022/05/23/搜索与回溯算法三/","content":"\n### 例题一\n\n给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n例如，在下面的 3×4 的矩阵中包含单词 \"ABCCED\"（单词中的字母已标出）。\n\n![img](搜索与回溯算法三/1.jpg)\n\n\n\n**示例 1：**\n\n```java\n输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n输出：true\n```\n\n**示例 2：**\n\n```java\n输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n输出：false\n```\n\n**提示：**\n\n- `1 <= board.length <= 200`\n- `1 <= board[i].length <= 200`\n- `board` 和 `word` 仅由大小写英文字母组成\n\n <!--more-->\n\n\n\n#### 题解\n\n##### 解题思路\n\n本问题是典型的矩阵搜索问题，可使用 **深度优先搜索（DFS）+ 剪枝** 解决。\n\n- **深度优先搜索：** 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。\n\n- **剪枝：** 在搜索中，遇到 `这条路不可能和目标字符串匹配成功` 的情况（*例如：此矩阵元素和目标字符不同、此元素已被访问）*，则应立即返回，称之为 `可行性剪枝` 。\n\n<img src=\"搜索与回溯算法三/2.png\" style=\"zoom: 50%;\" />\n\n\n\n##### 算法设计\n\n**DFS解析：**\n\n- **递归参数：** 当前元素在矩阵 `board` 中的行列索引 `i` 和 `j` ，当前目标字符在 `word` 中的索引 `k` 。\n\n- **终止条件：**\n  1. 返回 $false$：(1) 行或列索引越界 **或** (2) 当前矩阵元素与目标字符不同 **或** (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。\n  2. 返回 $true$ ： `k = len(word) - 1` ，即字符串 `word` 已全部匹配。\n\n- **递推工作：**\n  1. 标记当前矩阵元素： 将 `board[i][j]` 修改为 **空字符** `'\\0'` ，代表此元素已访问过，防止之后搜索时重复访问。\n  2. 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 `||` 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 `res` 。\n  3. 还原当前矩阵元素： 将 `board[i][j]` 元素还原至初始值，即 `word[k]` 。\n\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board[0].length; j++){\n                if(dfs(board, words, i, j, 0)){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    boolean dfs (char[][] board,char[] word,int i,int j,int k){\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j] != word[k])\n            return false;\n        if(k == word.length-1)\n            return true;\n        board[i][j] = '\\0';\n        boolean res = dfs(board,word,i,j+1,k+1) || dfs(board,word,i+1,j,k+1) || dfs(board,word,i,j-1,k+1) || dfs(board,word,i-1,j,k+1);\n        board[i][j] = word[k];\n        return res;\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n地上有一个m行n列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标 `[0, 0] `的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n**示例 1：**\n\n```java\n输入：m = 2, n = 3, k = 1\n输出：3\n```\n\n**示例 2：**\n\n```java\n输入：m = 3, n = 1, k = 0\n输出：1\n```\n\n**提示：**\n\n- `1 <= n,m <= 100`\n- `0 <= k <= 20`\n\n#### 题解\n\n##### 解题思路\n\n本题与 [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/) 类似，是典型的搜索 & 回溯问题。在介绍回溯算法算法前，为提升计算效率，首先讲述前置工作： **数位之和计算** 。\n\n**数位之和计算：**\n\n设一数字 $x$ ，向下取整除法符号 $/$ ，求余符号 $⊙$ ，则有：\n\n- $x⊙10$ ：得到 $x$ 的个位数字；\n- $x / 10$ ： 令 $x$ 的十进制数向右移动一位，即删除个位数字。\n\n```java\nint he(int n){\n        int sum = 0;\n        while(n!=0){\n            sum+=n%10;\n            n/=10; \n        }\n        return sum;\n    }\n```\n\n**深度优先遍历 DFS**\n\n- **深度优先搜索：** 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。\n\n- **剪枝：** 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 `可行性剪枝` 。\n\n##### 算法设计\n\n- **递归参数：** 当前元素在矩阵中的行列索引 `i` 和 `j` ，两者的数位和 `si`, `sj` 。\n\n- **终止条件：** 当 $①$ 行列索引越界 **或** $②$ 数位和超出目标值 `k` **或** $③$ 当前元素已访问过 时，返回 $0$ ，代表不计入可达解。\n\n- **递推工作：**\n  - **标记当前单元格** ：将索引 `(i, j)` 存入 Set `visited` 中，代表此单元格已被访问过。\n  - **搜索下一单元格：** 计算当前元素的 **下、右** 两个方向元素的数位和，并开启下层递归 。\n- **回溯返回值：** 返回 `1 + 右方搜索的可达解总数 + 下方搜索的可达解总数`，代表从本单元格递归搜索的可达解总数。\n\n```java\nclass Solution {\n\n    int m, n, k;\n    boolean[][] visited;\n\n    public int movingCount(int m, int n, int k) {\n        this.m = m; this.n = n; this.k = k;\n        this.visited = new boolean[m][n];\n        return dfs(0, 0);\n    }\n\n    int dfs(int i, int j){\n        if(i < 0 || i >= m || j < 0 || j >= n || he(i) + he(j) > k || visited[i][j])  return 0;\n        visited[i][j] = true;\n        return 1 + dfs(i + 1, j) + dfs(i, j + 1);\n    }\n    \n    int he(int n){\n        int sum = 0;\n        while(n!=0){\n            sum+=n%10;\n            n/=10; \n        }\n        return sum;\n    }\n}\n```\n\n\n\n**广度优先遍历BFS也可，这里不做分析**\n\n-----\n\n\n\n### 例题三\n\n给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。\n\n**叶子节点** 是指没有子节点的节点。\n\n \n\n**示例 1：**\n\n![img](搜索与回溯算法三/3.jpg)\n\n```java\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n输出：[[5,4,11,2],[5,8,4,5]]\n```\n\n**示例 2：**\n\n![img](搜索与回溯算法三/4.jpg)\n\n```java\n输入：root = [1,2,3], targetSum = 5\n输出：[]\n```\n\n**示例3：**\n\n```java\n输入：root = [1,2], targetSum = 0\n输出：[]\n```\n\n**提示：**\n\n- 树中节点总数在范围 `[0, 5000]` 内\n- `-1000 <= Node.val <= 1000`\n- `-1000 <= targetSum <= 1000`\n\n#### 题解\n\n##### 解题思路\n\n本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 **先序遍历 + 路径记录** 两部分。\n\n- **先序遍历：** 按照 “根、左、右” 的顺序，遍历树的所有节点。\n- **路径记录：** 在先序遍历中，记录从根节点到当前节点的路径。当路径为 $①$ 根节点到叶节点形成的路径 **且** $②$ 各节点值的和等于目标值 `sum` 时，将此路径加入结果列表。\n\n<img src=\"搜索与回溯算法三/5.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\" />\n\n##### 算法流程\n\n**`pathSum(root, sum)` 函数：**\n\n- **初始化：** 结果列表 `res` ，路径列表 `path` 。\n- **返回值：** 返回 `res` 即可。\n\n**`resSum(root, tar) 函数：`**\n\n- **递推参数：** 当前节点 `root` ，当前目标值 `tar` 。\n\n- **终止条件：** 若节点 `root` 为空，则直接返回。\n- **递推工作：**\n  - 路径更新： 将当前节点值 `root.val` 加入路径 `path` ；\n  - 目标值更新： `tar = tar - root.val`（即目标值 `tar` 从 `sum` 减至 $0$ ）；\n  - 路径记录： 当 ① `root` 为叶节点 **且** ② 路径和等于目标值 ，则将此路径 `path` 加入 `res` 。\n  - 先序遍历： 递归左 / 右子节点。\n  - 路径恢复： 向上回溯前，需要将当前节点从路径 `path` 中删除，即执行 `path.pop()` 。\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    LinkedList<List<Integer>> res = new LinkedList<>();\n    LinkedList<Integer> push = new LinkedList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int target) {\n        resSum(root,target);\n        return res;\n    }\n\n    void resSum(TreeNode root, int target){\n        if(root == null) return;\n        push.add(root.val);\n        target -= root.val;\n        if(target == 0 && root.right == null && root.left == null){\n            res.add(new LinkedList(push));\n        }\n        resSum(root.left,target);\n        resSum(root.right,target);\n        push.removeLast();\n    }\n}\n```\n\n----\n\n\n\n### 例题四\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n\n 为了让您更好地理解问题，以下面的二叉搜索树为例：\n\n<img src=\"搜索与回溯算法三/6.png\" alt=\"img\" style=\"zoom: 80%;\" />\n\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n\n<img src=\"搜索与回溯算法三/7.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n\n#### 题解\n\n##### 解题思路\n\n本文解法基于性质：二叉搜索树的中序遍历为 **递增序列** 。\n\n将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：\n\n1. **排序链表：** 节点应从小到大排序，因此应使用 **中序遍历** “从小到大”访问树的节点。\n2. **双向链表：** 在构建相邻节点的引用关系时，设前驱节点 `pre` 和当前节点 `cur` ，不仅应构建 `pre.right = cur` ，也应构建 `cur.left = pre` 。\n3. **循环链表：** 设链表头节点 `head` 和尾节点 `tail` ，则应构建 `head.left = tail` 和 `tail.right = head` 。\n\n<img src=\"搜索与回溯算法三/8.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\" />\n\n**中序遍历** 为对二叉树作 “左、根、右” 顺序遍历，递归实现如下：\n\n```java\n// 打印中序遍历\nvoid dfs(Node root) {\n    if(root == null) return;\n    dfs(root.left); // 左\n    System.out.println(root.val); // 根\n    dfs(root.right); // 右\n}\n```\n\n根据以上分析，考虑使用中序遍历访问树的各节点 `cur` ；并在访问每个节点时构建 `cur` 和前驱节点 `pre` 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。\n\n##### 算法设计\n\n**`dfs(cur):` 递归法中序遍历；**\n\n- **终止条件：** 当节点 `cur` 为空，代表越过叶节点，直接返回；\n- 递归左子树，即 `dfs(cur.left)` ；\n- **构建链表：**\n  1. **当 `pre` 为空时：** 代表正在访问链表头节点，记为 `head` ；\n  2. **当 `pre` 不为空时：** 修改双向节点引用，即 `pre.right = cur` ， `cur.left = pre` ；\n  3. **保存 `cur` ：** 更新 `pre = cur` ，即节点 `cur` 是后继节点的 `pre` ；\n- 递归右子树，即 `dfs(cur.right)` ；\n\n**`treeToDoublyList(root)：`**\n\n1. **特例处理：** 若节点 `root` 为空，则直接返回；\n2. **初始化：** 空节点 `pre` ；\n3. **转化为双向链表：** 调用 `dfs(root)` ；\n4. **构建循环链表：** 中序遍历完成后，`head` 指向头节点， `pre` 指向尾节点，因此修改 `head` 和 `pre` 的双向节点引用即可；\n5. **返回值：** 返回链表的头节点 `head` 即可；\n\n```java\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val,Node _left,Node _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\nclass Solution {\n    Node head,pre;\n    public Node treeToDoublyList(Node root) {\n        if(root == null) return null;\n        dfs(root);\n        head.left = pre;\n        pre.right = head;\n        return head;\n    }\n\n    void dfs(Node cur){\n        if(cur == null) return;\n        dfs(cur.left);\n        if(pre == null){\n            head = cur;\n        }else{\n            cur.left = pre;\n            pre.right = cur;\n        }\n        pre = cur;\n        dfs(cur.right);\n    }\n}\n```\n\n----\n\n\n\n","tags":["算法","数组","数","深度优先搜索"],"categories":["LeetCode学习","搜索与回溯算法"]},{"title":"双指针","url":"/2022/05/22/双指针/","content":"\n\n\n### 例题一\n\n输入两个链表，找出它们的第一个公共节点。\n\n如下面的两个链表：\n\n​\t\t\t\t\t\t\t\t\t\t<img src=\"双指针/1.png\" alt=\"img\"  />\n\n在节点 c1 开始相交。\n\n\n\n**示例 1：**\n\n​\t\t\t\t\t\t\t\t\t\t <img src=\"双指针/2.png\" alt=\"img\"  />\n\n```java\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n\n\n**示例 2：**\n\n<img src=\"双指针/3.png\" alt=\"img\"  />\n\n```java\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n<!--more-->\n\n**示例 3：**\n\n![img](双指针/4.png)\n\n```java\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n```\n\n**注意：**\n\n- 如果两个链表没有交点，返回 `null`.\n- 在返回结果后，两个链表仍须保持原有的结构。\n- 可假定整个链表结构中没有循环。\n- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n#### 题解\n\n##### 解题思路\n\n设「第一个公共节点」为 `node` ，「链表 `headA`」的节点数量为 $a$ ，「链表 `headB`」的节点数量为 $b$ ，「两链表的公共尾部」的节点数量为 $c$ ，则有：\n\n头节点 `headA` 到 `node` 前，共有 $a - c$ 个节点；\n头节点 `headB` 到 `node` 前，共有 $b - c$ 个节点；\n\n<img src=\"双指针/5.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\" />\n\n考虑构建两个节点指针 `A` , `B` 分别指向两链表头节点 `headA` , `headB`\n\n当头节点`nodeA`与头节点`nodeB`分别循环一遍自己的节点，并走一遍对方的公共节点前的节点，指针步长相同。即：\n\n- 指针 `A` 先遍历完链表 `headA` ，再开始遍历链表 `headB` ，当走到 `node` 时，共走步数为：\n\n$$\na + (b - c)\n$$\n\n- 指针 `B` 先遍历完链表 `headB` ，再开始遍历链表 `headA` ，当走到 `node` 时，共走步数为：\n\n$$\nb+(a−c)\n$$\n\n如下式所示，此时指针 `A` , `B` 重合，并有两种情况：\n$$\na + (b - c) = b + (a - c)\n$$\n\n1. 若两链表 **有** 公共尾部 (即 c > 0*c*>0 ) ：指针 `A` , `B` 同时指向「第一个公共节点」`node` 。\n2. 若两链表 **无** 公共尾部 (即 c = 0*c*=0 ) ：指针 `A` , `B` 同时指向 $null$ 。\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA, B = headB;\n        while (A != B) {\n            A = A != null ? A.next : headB;\n            B = B != null ? B.next : headA;\n        }\n        return A;\n    }\n}\n\n```\n\n----\n\n\n\n### 例题二\n\n输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\"I am a student. \"，则输出\".student a am I\"。\n\n**示例 1：**\n\n```java\n输入: \"the sky is blue\"\n输出: \"blue is sky the\"\n```\n\n**示例 2：**\n\n```java\n输入: \"  hello world!  \"\n输出: \"world! hello\"\n解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n```\n\n**示例 3：**\n\n```java\n输入: \"a good   example\"\n输出: \"example good a\"\n解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n```\n\n**说明：**\n\n- 无空格字符构成一个单词。\n- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n#### 题解\n\n##### 解题思路\n\n##### 算法解析：\n\n- 倒序遍历字符串 $s$，记录单词左右索引边界 $i$ , $j$；\n- 每确定一个单词的边界，则将其添加至单词列表 $res$；\n- 最终，将单词列表拼接为字符串，并返回即可。\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        s = s.trim(); // 删除首尾空格\n        int j = s.length() - 1, i = j;\n        StringBuilder res = new StringBuilder();\n        while(i >= 0) {\n            while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格\n            res.append(s.substring(i + 1, j + 1) + \" \"); // 添加单词\n            while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格\n            j = i; // j 指向下个单词的尾字符\n        }\n        return res.toString().trim(); // 转化为字符串并返回\n    }\n}\n\n```\n\n----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd\n\n","tags":["算法","数组","双指针","链表"],"categories":["LeetCode学习","双指针"]},{"title":"动态规划二","url":"/2022/05/20/动态规划二/","content":"\n### 例题一\n\n给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n\n \n\n**示例 1:**\n\n```java\n输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\"\n```\n\n\n\n**提示：**\n\n`0 <= num < 231`\n\n<!--more-->\n\n\n\n#### 题解\n\n##### 解题思路\n\n本题使用动态规划，及通过前一步状态推导下一步状态，由题意可推导转移方程，流程如下图。\n\n<img src=\"动态规划二/1.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\" />\n\n\n\n##### 算法流程\n\n- **状态定义：**设动态规划列表 $dp$ ，$dp[i]$ 代表以 $x_i$ 为结尾的数字的翻译方案数量。\n\n- **转移方程：**若 $x_i$和 $x_{i-1}$组成的两位数字可以被翻译，则$dp[i] = dp[i - 1] + dp[i - 2]$；否则 $dp[i] = dp[i - 1]$。\n\n  可被翻译的两位数区间：当 $x_{i-1} = 0$时，组成的两位数是无法被翻译的（例如 $00, 01, 02, \\cdots$），因此区间为 $[10, 25]$。\n  $dp[i] = \\begin{cases} dp[i - 1] + dp[i - 2] & {, 10 x_{i-1} + x_i \\in [10,25]} \\\\ dp[i - 1] & {, 10 x_{i-1} + x_i \\in [0, 10) \\cup (25, 99]} \\end{cases}$\n\n- **返回值：**$dp[n]$，及此数字的翻译方案数量。\n\n- **初始状态：**$dp[0]=dp[1]=1$，即 “无数字” 和 “第 1 位数字” 的翻译方法数量均为 1 。\n\n- **空间优化：**$dp[i],dp[i - 1]$，所以可使用两个变量 p,q 分别记录 $dp[i], dp[i - 1]$，两变量交替前进即可。此方法可省去 $dp$ 列表使用的 $O(N)$ 的额外空间。\n\n\n\n```java\nclass Solution {\n    public int translateNum(int num) {\n        String s = String.valueOf(num);\n        int p = 1,q = 1;\n        for(int i = 2;i <= s.length();i++){\n            String nums = s.substring(i-2, i);\n            int c = nums.compareTo(\"10\") >= 0 && nums.compareTo(\"25\") <=0 ? p + q : q;\n            p = q;\n            q = c;\n        }\n        return q;\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n\n \n\n**示例 1:**\n\n```java\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```java\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```java\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n**提示：**\n\n`s.length <= 40000`\n\n#### 题解\n\n##### 解题思路一：动态规划 + 哈希表\n\n使用动态规划记录每增加一个字符的“最长不重复子字符串” 的长度是多少。\n\n**动态规划解析：**\n\n- **状态定义：** 设动态规划列表 $dp$ ，$dp[j]$代表以字符 $s[j]$ 为结尾的 “最长不重复子字符串” 的长度。\n- **转移方程：** 固定右边界 $j$ ，设字符 $s[j]$ 左边距离最近的相同字符为 $s[i]$ ，即 $s[i] = s[j]$ 。\n  - 当 $i < 0$，即 $s[j]$ 左边无相同字符，则 $dp[j] = dp[j-1] + 1$；\n  - 当 $dp[j - 1] < j - i$，说明字符 $s[i]$ 在子字符串 $dp[j-1]$ **区间之外** ，则 $dp[j] = dp[j - 1] + 1$ ；\n  - 当 $dp[j - 1] \\geq j - i$，说明字符 $s[i]$ 在子字符串 $dp[j-1]$ **区间之中** ，则 $dp[j]$的左边界由 $s[i]$ 决定，即 $dp[j] = j - i$；\n  - 当 $i < 0$ 时，由于 $dp[j - 1] \\leq j$ 恒成立，因而 $dp[j - 1] < j - i$ 恒成立，因此分支 `1.` 和 `2.` 可被合并。\n\n$$\ndp[j] = \\begin{cases} dp[j - 1] + 1 & , dp[j-1] < j - i \\\\ j - i & , dp[j-1] \\geq j - i \\end{cases}\n$$\n\n- **返回值：** $\\max(dp)$，即全局的 “最长不重复子字符串” 的长度。\n\n<img src=\"动态规划二/2.png\" alt=\"Picture1.png\" style=\"zoom: 67%;\" />\n\n**优化空间复杂度**\n\n- 由于返回值是取 $dp$ 列表最大值，因此可借助变量 $tmp$ 存储 $dp[j]$ ，变量 $res$ 每轮更新最大值即可。\n- 此优化可节省 $dp$ 列表使用的 $O(N)$ 大小的额外空间。\n\n**哈希表**\n\n- 哈希表统计： 遍历字符串 $s$ 时，使用哈希表（记为 $dic$ ）统计 各字符最后一次出现的索引位置 。\n- 左边界 $i$ 获取方式： 遍历到 $s[j]$ 时，可通过访问哈希表 $dic[s[j]]$ 获取最近的相同字符的索引 $i$ 。\n\n\n\n```java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> dic = new HashMap<>();\n        int res = 0, tmp = 0;\n        for(int j = 0; j < s.length(); j++) {\n            int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i\n            dic.put(s.charAt(j), j); // 更新哈希表\n            tmp = tmp < j - i ? tmp + 1 : j - i; // dp[j - 1] -> dp[j]\n            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])\n        }\n        return res;\n    }\n}\n\n```\n\n\n\n##### 解题思路二：滑动窗口\n\n找出**从每一个字符开始的，不包含重复字符的最长子串**，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：\n\n- 使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着「枚举子串的起始位置」，而右指针即为最长子串结束位置的 $r_k$；\n\n- 在每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。记录下这个子串的长度；\n- 在枚举结束后，找到的最长的子串的长度即为答案。\n\n**判断重复字符**\n\n在上面的流程中，还需要使用一种数据结构来判断 **是否有重复的字符**，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符。\n\n\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // 哈希集合，记录每个字符是否出现过\n        Set<Character> occ = new HashSet<Character>();\n        int n = s.length();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        int rk = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.remove(s.charAt(i - 1));\n            }\n            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {\n                // 不断地移动右指针\n                occ.add(s.charAt(rk + 1));\n                ++rk;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = Math.max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n}\n```\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd、LeetCode-Solution\n\n","tags":["算法","动态规划","字符串"],"categories":["LeetCode学习","动态规划"]},{"title":"动态规划","url":"/2022/05/19/动态规划/","content":"\n\n\n### 例题一\n\n写一个函数，输入`n`，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：\n\n```java\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n```\n\n\n斐波那契数列由 `0` 和 `1` 开始，之后的斐波那契数就是由之前的两数相加而得出。\n\n答案需要取模 `1e9+7(1000000007)`，如计算初始结果为：`1000000008`，请返回 `1`。\n\n \n\n**示例 1：**\n\n```java\n输入：n = 2\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：n = 5\n输出：5\n```\n\n**提示：**\n\n- `0 <= n <= 100`\n\n<!--more-->\n\n#### 题解\n\n##### 解题思路\n\n斐波那契数列的定义是 *f*(*n*+1)=*f*(*n*)+*f*(*n*−1) ，生成第 *n* 项的做法有以下几种：\n\n1. **递归法：**\n   - 把*f*(*n*+1)拆分为*f*(*n*)和*f*(*n*−1)两个式子计算，递归计算，直到*f*(0)和*f*(1)为终止条件。\n   - **缺点：** 需要进行大量递归计算，时间复杂度为$O(2^n)$;\n2. **动态规划：**\n   - **原理：** 以斐波那契数列性质 f*(*n*+1)=*f*(*n*)+*f*(*n*−1) 为转移方程。\n\n\n\n##### 算法流程\n\n**动态规划解析：**\n\n- **状态定义：** 设 *dp* 为一维数组，其中 *dp[i]* 的值代表 斐波那契数列第 *i* 个数字 。\n\n- **转移方程：** *dp[i+1]=dp[i]+dp[i−1]* ，即对应数列定义 *f(n+1)=f(n)+f(n−1)* ；\n\n- **初始状态：** *dp[0]=0*,*dp[1]=1* ，即初始化前两个数字；\n\n- **返回值：** *dp[n]* ，即斐波那契数列的第 *n* 个数字。\n\n  **需要对结果循环求余：**防止因*n*的增大，*f(n)*会超过`Int32`甚至`Int64`的取值范围，导致结果错误。\n\n\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        int a = 0, b = 1;\n        for(int i = 2; i <= n; i++){\n            int sum = (a + b)%1000000007;\n            a = b;\n            b = sum;\n        }\n        return b;\n    }\n}\n```\n\n----\n\n\n\n### 例题二\n\n假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n\n \n\n**示例 1:**\n\n```java\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n```\n\n**示例 2:**\n\n```java\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n**限制：**\n\n`0 <= 数组长度 <= 10^5`\n\n\n\n#### 题解\n\n##### 解题思路\n\n在题目中，我们只要用一个变量记录一个历史最低价格 `minprice`，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 `prices[i] - minprice`。\n\n因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。\n\n##### 算法步骤\n\n- **初始化：**定义最低价为一个最大整型数`minprice = Integer.MAX_VALUE`,定义盈利`maxprofit = 0`;\n- **遍历：**求出当前时间段的最低价与最大盈利；\n- **返回值：**返回最大盈利值。\n\n```java\npublic class Solution {\n    public int maxProfit(int prices[]) {\n        int minprice = Integer.MAX_VALUE;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minprice) {\n                minprice = prices[i];\n            } else if (prices[i] - minprice > maxprofit) {\n                maxprofit = prices[i] - minprice;\n            }\n        }\n        return maxprofit;\n    }\n}\n```\n\n----\n\n\n\n### 例题三\n\n在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n\n \n\n**示例 1:**\n\n```java\n输入: \n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 12\n解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\n```\n\n**提示：**\n\n- `0 < grid.length <= 200`\n- `0 < grid[0].length <= 200`\n\n\n\n#### 题解\n\n##### 解题思路\n\n题目说明：从棋盘的左上角开始拿格子里的礼物，并每次 **向右** 或者 **向下** 移动一格、直到到达棋盘的右下角。\n根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。\n\n设 $f(i,j)$ 为从棋盘左上角走至单元格 (i ,j)(i,j) 的礼物最大累计价值，易得到以下递推关系：$f(i,j)$ 等于 $f(i,j-1)$ 和 $f(i-1,j)$ 中的较大值加上当前单元格礼物价值 $grid(i,j)$ 。\n\n​        $f(i,j) = \\max[f(i,j-1), f(i-1,j)] + grid(i,j)$\n\n因此，可用动态规划解决此问题，以上公式便为转移方程。\n\n<img src=\"动态规划/1.png\" alt=\"Picture1.png\" style=\"zoom: 67%;\" />\n\n\n\n##### 算法步骤\n\n- **状态定义：** 设动态规划矩阵 dpdp ，dp(i,j)dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j)(i,j) 时能拿到礼物的最大累计价值。\n\n- **转移方程：**\n\n  - 当 $i = 0$ 且 $j = 0$ 时，为起始元素；\n\n  - 当 $i = 0$ 且 $j \\ne 0$ 时，为矩阵第一行元素，只可从左边到达；\n\n  - 当 $i \\ne 0$ 且 $j = 0$ 时，为矩阵第一列元素，只可从上边到达；\n\n  - 当 $i \\ne 0$ 且 $j \\ne 0$ 时，可从左边或上边到达；\n    $$\n    dp(i,j)= \\begin{cases} grid(i,j) & {,i=0, j=0}\\\\ grid(i,j) + dp(i,j-1) & {,i=0, j \\ne 0}\\\\ grid(i,j) + dp(i-1,j) & {,i \\ne 0, j=0}\\\\ grid(i,j) + \\max[dp(i-1,j),dp(i,j-1)]& ,{i \\ne 0, j \\ne 0} \\end{cases}\n    $$\n    \n\n- **初始状态：** $dp[0][0] = grid[0][0]$，即到达单元格 $(0,0)$ 时能拿到礼物的最大累计价值为 $grid[0][0]$ ；\n- **返回值：** $dp[m-1][n-1]$，$m, n$ 分别为矩阵的行高和列宽，即返回 $dp$ 矩阵右下角元素。\n\n**可直接在原矩阵中进行修改，省去$dp$矩阵使用的额外空间，空间复杂度从$O(MN)$降低位$O(1)$**\n\n\n\n```java\nclass Solution {\n    public int maxValue(int[][] grid) {\n        int n = grid[0].length;\n        int m = grid.length;\n        for(int i = 0; i< m;i++){\n           for(int j = 0;j < n;j++){\n               if(i == 0 && j == 0){\n                    continue;\n               }\n                if(i == 0){\n                    grid[i][j] += grid[i][j - 1] ;\n                }else if(j == 0){\n                    grid[i][j] += grid[i - 1][j];\n                }else{\n                    grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);\n                } \n           }\n        }\n        return grid[m-1][n-1];\n    }\n}\n```\n\n---\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd、LeetCode-Solution\n\n","tags":["算法","数组","动态规划"],"categories":["LeetCode学习","动态规划"]},{"title":"搜索与回溯算法二","url":"/2022/05/16/搜索与回溯算法二/","content":"\n### 例题一\n\n输入两棵二叉树*A*和*B*，判断*B*是不是*A*的子结构。(约定空树不是任意一个树的子结构)\n\n*B*是*A*的子结构， 即 *A*中有出现和*B*相同的结构和节点值。\n\n**例如:**\n给定的树 *A*:\n\n```java\n     3\n    / \\\n   4   5\n  / \\\n 1   2\n```\n\n给定的树 *B*：\n\n```java\n   4 \n  /\n 1\n```\n\n返回 `true`，因为 *B* 与 *A* 的一个子树拥有相同的结构和节点值。\n\n**示例 1：**\n\n```java\n输入：A = [1,2,3], B = [3,1]\n输出：false\n```\n\n**示例 2：**\n\n```java\n输入：A = [3,4,5,1,2], B = [4,1]\n输出：true\n```\n\n**限制：**\n\n`0 <= 节点个数 <= 10000`\n\n<!--more-->\n\n\n\n#### 题解\n\n##### 解题思路：\n\n由题意可知，若树*B*是树*A*的子结构，则子结构的根节点可能是树*A*的任意一个节点。因此需要判断树*B*是不是树*A*的子结构，只需要判断树*B*是否为树*A*的子节点，通过以下两步完成工作：\n\n1. 先序遍历树*A*中每个节点$n_A$;(对应函数`isSubStructure(A, B)`)\n2. 判断树 *A*中 **以 $n_A$为根节点的子树** 是否包含树 *B* 。（对应函数 `recur(A, B)`）\n\n<img src=\"搜索与回溯算法二/1.png\" alt=\"Picture1.png\" style=\"zoom: 50%;\" />\n\n\n\n##### 算法流程：\n\n**`recur(A, B)` 函数：**\n\n1. **终止条件：**\n   - 当节点 *B* 为空：说明树 *B* 已匹配完成（越过叶子节点），因此返回 `true` ；\n   - 当节点 *A* 为空：说明已经越过树 *A* 叶子节点，即匹配失败，返回 `false` ；\n   - 当节点 *A* 和 *B*  的值不同：说明匹配失败，返回 `false` ；\n2. **返回值：**\n   - 判断 *A* 和 *B*  的左子节点是否相等，即 `recur(A.left, B.left)` ；\n   - 判断 *A* 和 *B*  的右子节点是否相等，即 `recur(A.right, B.right)` ；\n\n**`isSubStructure(A, B)` 函数：**\n\n1. **特例处理：** 当 树 *A* 为空 或 树 *B*为空 时，直接返回 `false` ；\n2. **返回值：** 若树 *B*是树 *A*的子结构，则必满足以下三种情况之一，因此用或 `||` 连接；\n   - 以 节点 *A*为根节点的子树 包含树 *B*，对应 `recur(A, B)`；\n   - 树 *B*是 树 *A*左子树 的子结构，对应 `isSubStructure(A.left, B)`；\n   - 树 *B* 是 树 *A*右子树 的子结构，对应 `isSubStructure(A.right, B)`；\n\n\n\n```java\nclass Solution {\n    public boolean isSubStructure(TreeNode A, TreeNode B) {\n        return (A != null && B != null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));\n    }\n    boolean recur(TreeNode A, TreeNode B) {\n        if(B == null) \n            return true;\n        if(A == null || A.val != B.val) \n            return false;\n        return recur(A.left, B.left) && recur(A.right, B.right);\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n```java\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n```java\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n**示例 1：**\n\n```java\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n```\n\n**示例 2：**\n\n```java\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n```\n\n**限制：**\n\n`0 <= 节点个数 <= 1000`\n\n\n\n#### 题解\n\n##### 解题思路：\n\n- **对称二叉树定义：** 对于树中 **任意两个对称节点**  *L* 和 *R* ，一定有：\n  - `L.val = R.val`：即此两对称节点值相等。\n  - `L.left.val = R.right.val`：即 *L*的 左子节点 和 *R*的 右子节点 对称；\n  - `L.right.val = R.left.val`：即 *L*的 右子节点 和 *R*的 左子节点 对称。\n- 根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。\n\n<img src=\"搜索与回溯算法二/2.png\" alt=\"Picture1.png\" style=\"zoom:50%;\" />\n\n\n\n##### 算法流程：\n\n`isSymmetric(root)`：\n\n- **特例处理：** 若根节点 `root` 为空，则直接返回 `true` 。\n- **返回值：** 即 `recur(root.left, root.right)` ;\n\n`recur(L, R)`：\n\n- **终止条件：**\n  - 当 *L*和 *R*同时越过叶节点： 此树从顶至底的节点都对称，因此返回`true` ；\n  - 当 *L*或 *R*中只有一个越过叶节点： 此树不对称，因此返回`false` ；\n  - 当节点 *L*值 $\\ne$ 节点 *R*值： 此树不对称，因此返回 `false`；\n- **递推工作：**\n  - 判断两节点 `L.left` 和 `R.right` 是否对称，即 `recur(L.left, R.right)`；\n  - 判断两节点 `L.right` 和 `R.left` 是否对称，即 `recur(L.right, R.left)`；\n- **返回值：** 两对节点都对称时，才是对称树，因此用与逻辑符 `&&` 连接。\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return root == null ? true : recur(root.left, root.right);\n    }\n    boolean recur(TreeNode L, TreeNode R) {\n        if(L == null && R == null) \n            return true;\n        if(L == null || R == null || L.val != R.val)\n            return false;\n        return recur(L.left, R.right) && recur(L.right, R.left);\n    }\n}\n```\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd\n\n","tags":["算法","二叉树","深度优先搜索"],"categories":["LeetCode学习","搜索与回溯算法"]},{"title":"搜索与回溯算法","url":"/2022/05/15/搜索与回溯算法/","content":"\n### 例题一\n\n从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\n\n \n\n**例如:**\n给定二叉树: `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n**返回：**\n\n```java\n[3,9,20,15,7]\n```\n\n**提示：**\n\n- 节点总数 <= 1000\n\n<!--more-->\n\n\n\n#### 题解\n\n##### 解题思路\n\n- 题目要求的二叉树的 **从上至下** 打印（即按层打印），又称为二叉树的 **广度优先搜索**（BFS）。\n- BFS 通常借助 **队列** 的先入先出特性来实现。\n\n<img src=\"搜索与回溯算法/1.png\" alt=\"Picture0.png\" style=\"zoom: 67%;\" />\n\n\n\n##### 算法流程\n\n1. **特例处理：**当根节点为空时，直接返回空列表[]；\n2. **初始化：**打印结果列表`list`，队列`queue[]`将`root`根节点放入队列；\n3. **BFS循环：**当队列为空时退出循环\n   - **出队：**队首元素出队，记为`T`；\n   - **打印：**将`T.val`添加至列表`list`尾部；\n   - **添加子节点：**若`T`的左(右)节点不为空，则将左(右)节点加入队列`queue`；\n4. **返回值：**将打印列表转为数组`res`，返回数组`res`即可。\n\n```java\nclass Solution {\n    public int[] levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        List<Integer> list = new LinkedList<Integer>();   \n        if(root == null)\n            return new int[0];\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode T = queue.remove();\n            if(T.left != null){\n                queue.add(T.left);\n            }\n            if(T.right != null){\n                queue.add(T.right);\n            }\n            list.add(T.val);\n        }\n        int[] res = new int[list.size()];\n            for(int i = 0; i < list.size(); i++)\n                res[i] = list.get(i);\n            return res;\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\n\n \n\n**例如:**\n给定二叉树: `[3,9,20,null,null,15,7]`,\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回其层次遍历结果：\n\n```java\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n```\n\n\n提示：\n\n- 节点总数 <= 1000\n\n\n\n#### 题解\n\n##### 解题思路：层序遍历 + 双端队列\n\n- 利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列)`tmp`，并规定：\n  - 奇数层 则添加至 `tmp` **尾部** ，\n  - 偶数层 则添加至 `tmp` **头部** 。\n\n<img src=\"搜索与回溯算法/2.png\" alt=\"Picture1.png\" style=\"zoom: 67%;\" />\n\n\n\n##### 算法流程：\n\n1. **特例处理：** 当树的根节点为空，则直接返回空列表 `[]` ；\n2. **初始化：** 打印结果空列表 `res` ，包含根节点的双端队列 `deque` ；\n3. **BFS 循环：** 当 `deque` 为空时跳出；\n   - 新建列表 `tmp` ，用于临时存储当前层打印结果；\n   - **当前层打印循环：** 循环次数为当前层节点数（即 `deque` 长度）；\n     - **出队：** 队首元素出队，记为 `node`；\n     - **打印：** 若为奇数层，将 `node.val` 添加至 `tmp` 尾部；否则，添加至 `tmp`头部；\n     - **添加子节点：** 若 `node` 的左（右）子节点不为空，则加入 `deque` ；\n   - 将当前层结果 `tmp` 转化为 `list` 并添加入 `res` ；\n4. **返回值：** 返回打印结果列表 `res` 即可；\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        List<List<Integer>> res = new ArrayList<>();\n        if(root != null) \n            queue.add(root);\n        while(!queue.isEmpty()) {\n            LinkedList<Integer> tmp = new LinkedList<>();\n            for(int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                if(res.size() % 2 == 0)\n                    tmp.addLast(node.val); // 偶数层 -> 队列头部\n                else\n                    tmp.addFirst(node.val); // 奇数层 -> 队列尾部\n                if(node.left != null)\n                    queue.add(node.left);\n                if(node.right != null) \n                    queue.add(node.right);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n-----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd\n\n","tags":["算法","二叉树","广度优先搜索"],"categories":["LeetCode学习","搜索与回溯算法"]},{"title":"查找算法","url":"/2022/05/14/查找算法/","content":"\n### 例题一\n\n在一个 ``n * m`` 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n \n\n**示例:**\n\n现有矩阵 ``matrix`` 如下：\n\n````java\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n````\n\n\n给定 ``target = 5``，返回 ``true``。\n\n给定 ``target = 20``，返回 ``false``。\n\n \n\n**限制：**\n\n``0 <= n <= 1000``\n\n``0 <= m <= 1000``\n\n<!--more-->\n\n#### 题解\n\n##### 解题思路一：暴力\n\n如果不考虑二维数组排好序的特点，则直接遍历整个二维数组的每一个元素，判断目标值是否在二维数组中存在。\n\n依次遍历二维数组的每一行和每一列。如果找到一个元素等于目标值，则返回 true。如果遍历完毕仍未找到等于目标值的元素，则返回 false。**（不推荐）**\n\n```java\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int rows = matrix.length, columns = matrix[0].length;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < columns; j++) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n##### 解题思路二：二分查找\n\n由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。\n\n从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 `true`。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。\n\n可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。\n\n- 若数组为空，返回 `false`\n\n- 初始化行下标为 `0`，列下标为二维数组的列数减` 1`\n  - 重复下列步骤，直到行下标或列下标超出边界\n  - 获得当前下标位置的元素 `num`\n  - 如果 `num` 和 `target `相等，返回 `true`\n  - 如果 `num` 大于 `target`，列下标减 `1`\n  - 如果 `num` 小于 `target`，行下标加 `1`\n- 循环体执行完毕仍未找到元素等于 `target` ，说明不存在这样的元素，返回 `false`。\n\n```java\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        int long1 = matrix[0].length;\n        int high1 = matrix.length;\n        int long2 = long1 - 1;\n        int high2 = 0;\n        while(high2 < high1 && long2 >= 0){\n            if(matrix[high2][long2] == target){\n                return true;\n            }else if(matrix[high2][long2] < target){\n                high2++;\n            }else{\n                long2--;\n            }\n        }\n        return false;\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。\n\n给你一个可能存在 重复 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为 `1`。  \n\n注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`。\n\n \n\n**示例 1：**\n\n```java\n输入：numbers = [3,4,5,1,2]\n输出：1\n```\n\n**示例 2：**\n\n```java\n输入：numbers = [2,2,2,0,1]\n输出：0\n```\n\n\n\n**提示：**\n\n- `n == numbers.length`\n- `1 <= n <= 5000`\n- `-5000 <= numbers[i] <= 5000`\n- `numbers` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转\n\n#### 题解\n\n##### 解题思路：二分查找\n\n一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：\n\n<img src=\"查找算法/1.png\" alt=\"fig1\"  />\n\n其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标。\n\n我们考虑数组中的最后一个元素 `x`：在最小值右侧的元素，它们的值一定都小于等于 `x`；而在最小值左侧的元素，它们的值一定都大于等于 `x`。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。\n\n在二分查找的每一步中，左边界为 `low`，右边界为 `high`，区间的中点为 `pivot`，最小值就在该区间内。我们将中轴元素 `numbers[pivot]` 与右边界元素 `numbers[high]` 进行比较，可能会有以下的三种情况：\n\n第一种情况是 `numbers[pivot]<numbers[high]`。如下图所示，这说明 `numbers[pivot]` 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。\n\n<img src=\"查找算法/2.png\" alt=\"fig2\"  />\n\n第二种情况是`numbers[pivot]>numbers[high]`。如下图所示，这说明 `numbers[pivot]`是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。\n\n![fig3](查找算法/3.png)\n\n第三种情况是 `numbers[pivot]==numbers[high]`。如下图所示，由于重复元素的存在，我们并不能确定`numbers[pivot]` 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 `numbers[high]` 是不是最小值，都有一个它的「替代品」`numbers[pivot]`，因此我们可以忽略二分查找区间的右端点。\n\n![fig4](查找算法/4.png)\n\n当二分查找结束时，我们就得到了最小值所在的位置。\n\n```java\nclass Solution {\n    public int minArray(int[] numbers) {\n        int start = 0;\n        int end = numbers.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(numbers[mid] > numbers[end]){\n                start = mid + 1;\n            }else if(numbers[mid] < numbers[end]){\n                end = mid;\n            }else{\n                end--;\n            }\n        }\n        return numbers[start];\n    }\n}\n```\n\n----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：LeetCode-Solution\n\n","tags":["算法","数组","二分查找"],"categories":["LeetCode学习","查找算法"]},{"title":"链表","url":"/2022/05/09/链表/","content":"\n### 例题一\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n**示例**\n\n```java\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n**限制：**\n\n```java\n0 <= 节点个数 <= 5000\n```\n\n<!--more-->\n\n#### 题解\n\n##### 解题思路一：迭代\n\n假设链表为 `1→2→3→∅`，我们想要把它改成`∅←1←2←3`。\n\n在遍历链表时，将当前节点的`next`指针改为指向前一个节点。由于该节点没有引用其前一个节点，因此需要事先准备一个空节点储存前一个节点，在更改引用之前还需要存储后一个节点。最后返回新的头节点。\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode p = null;      //用来储存倒叙\n        ListNode c = head;      \n        ListNode n = null;      \n        while(c != null){\n            n = c.next;\n            c.next = p;\n            p = c;\n            c = n;\n        }\n        return p;\n    }\n}\n```\n\n##### 解题思路二：递归\n\n- 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 `newHead` .\n- 此后，每次函数在返回的过程中，让当前结点的下一个结点的 `next`指针指向当前节点。\n- 同时让当前结点的 `next` 指针指向 `null` ，从而实现从链表尾部开始的局部反转\n- 当递归函数全部出栈后，链表反转完成。\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newHead;\n    }\n}\n```\n\n**递归较难理解，用笔演算一遍会好一点。**\n\n-----\n\n\n\n### 例题二\n\n请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。\n\n**示例1**\n\n![img](链表/e1.png)\n\n```java\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n```\n\n**示例2**\n\n<img src=\"链表/e2.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n```java\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n```\n\n**示例3**\n\n<img src=\"链表/e3.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n```java\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n```\n\n**示例 4：**\n\n```java\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n```\n\n **提示：**\n\n- `-10000 <= Node.val <= 10000`\n- `Node.random` 为空（null）或指向链表中的节点。\n- 节点数目不超过 1000 。\n\n#### 解题思路\n\n**回溯+哈希表**\n\n如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。\n\n具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。\n\n在实际代码中，我们需要特别判断给定节点为空节点的情况。\n\n```java\nclass Solution {\n    Map<Node, Node> cachedNode = new HashMap<Node, Node>();\n\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n        if (!cachedNode.containsKey(head)) {\n            Node headNew = new Node(head.val);\n            cachedNode.put(head, headNew);\n            headNew.next = copyRandomList(head.next);\n            headNew.random = copyRandomList(head.random);\n        }\n        return cachedNode.get(head);\n    }\n}\n```\n\n-----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：jyd\n\n","tags":["算法","链表","哈希表"],"categories":["LeetCode学习","链表"]},{"title":"栈与队列","url":"/2022/05/04/栈与队列/","content":"\n### 例题一\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n**示例 1：**\n\n```java\n输入：\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[]]\n输出：\n[null,null,3,-1]\n```\n\n<!--more-->\n\n**示例 2：**\n\n```java\n输入：\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n输出：\n[null,-1,null,null,5,2]\n```\n\n**提示：**\n\n- `1 <= values <= 10000`\n- `最多会对 appendTail、deleteHead 进行 10000 次调用`\n\n#### 题解\n\n##### 解题思路\n\n- **栈无法实现队列功能:**\t栈为先进后出，队列为先进先出\n- **双栈可实现列表倒叙:**    用栈B元素实现对栈A的倒叙\n- **利用栈B删除队首元素**    B出栈相当于删除栈A的栈底元素，及队列首元素\n\n##### 函数设计\n\n- **加入队首`appendTail()`函数：**将数字val加入栈`A`即可。\n- **删除队尾`deleteHead()`:**分几种情况。\n  1. **当栈B不为空：**B中仍有已完成倒叙的元素，因此只需要返回B中的栈顶元素即可。\n  2. **否则，当A为空时：**当两个栈都为空时，无元素，返回-1。\n  3. **否则：**将栈A所有元素转移到栈B中，实现元素倒叙，并返回栈B元素的栈顶元素。\n\n##### 代码\n\n```java\nclass CQueue {\n    Stack<Integer> in,out;\n    public CQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void appendTail(int value) {\n        in.push(value);\n    }\n    \n    public int deleteHead() {\n        //当out栈不为空时，返回栈顶元素\n        if(!out.isEmpty()){\n            return out.pop();\n        }\n        //当in栈为空时，返回-1\n        if(in.isEmpty()){\n            return -1;\n        }\n        //当out栈为空时，将in栈中元素转到out栈中\n        while(!in.isEmpty()){\n            out.push(in.pop());\n        }\n        return out.pop();\n    }\n}\n```\n\n-----\n\n\n\n### 例题二\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n \n\n**示例:**\n\n```java\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.min();   --> 返回 -2.\n```\n\n**提示：**\n\n各函数的调用总次数不超过 20000 次\n\n\n\n#### 题解\n\n##### 解题思路\n\n对于栈来说，如果一个元素 `a` 在入栈时，栈里有其它的元素 `b, c, d`，那么无论这个栈在之后经历了什么操作，只要 `a` 在栈中，`b, c, d` 就一定在栈中，因为在 `a` 被弹出之前，b, c, d 不会被弹出。\n\n因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 `a, b, c, d`。\n\n那么，我们可以在每个元素 `a` 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 `a`，我们就可以直接返回存储的最小值 `m`。\n\n##### 算法\n\n按照上面的思路，我们只需要设计一个数据结构，使得每个元素`a`与其相应的最小值 `m` 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。\n\n- 当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；\n\n\n- 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；\n- 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。\n\n##### 代码\n\n```java\nclass MinStack {\n    /** initialize your data structure here. */\n\n    Stack<Integer> A,B;\n    public MinStack() {\n        A = new Stack<>();\n        B = new Stack<>();\n    }\n    \n    public void push(int x) {\n        A.push(x);\n        if(B.empty() || B.peek() >= x){\n            B.push(x);\n        }\n    }\n    \n    public void pop() {\n        if(A.pop().equals(B.peek())){\n            B.pop();\n        }\n    }\n    \n    public int top() {\n        return A.peek();\n    }\n    \n    public int min() {\n        return B.peek();\n    }\n}\n\n```\n\n----\n\n\n\n> 参考来源：力扣（LeetCode）\n>\n> 作者：LeetCode-Solution\n\n","tags":["算法","栈与队列"],"categories":["LeetCode学习","栈"]},{"title":"Hello World","url":"/2022/05/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n   <!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]